---
categories: ["análisis espacial","R","R:principante", "gis"]
title: Distancias geográficas
date: '2020-01-19'
slug: distancia-geografica
tags: ["distancia","puntos","ciudades"]
header:
  caption: ''
  image: 'distance_capitals.png'
lang: es
summary: "El primer post del año 2020, lo dedicaré a una consulta que me hicieron recientemente. Me plantearon la pregunta de cómo se podría calcular la distancia más corta entre diferentes puntos y cómo saber cúal es el punto más próximo a uno dado. Cuando trabajamos con datos espaciales en R, en la actualidad lo más fácil es usar el paquete ``sf`` en combinación con la colección de paquetes ``tidyverse``. Además usamos el paquete ``units`` que es muy útil para trabajar con unidades de medida."
---

El primer post del año 2020, lo dedicaré a una consulta que me hicieron recientemente. Me plantearon la pregunta de cómo se podría calcular la distancia más corta entre diferentes puntos y cómo saber cúal es el punto más próximo a uno dado. Cuando trabajamos con datos espaciales en R, en la actualidad lo más fácil es usar el paquete ``sf`` en combinación con la colección de paquetes ``tidyverse``. Además usamos el paquete ``units`` que es muy útil para trabajar con unidades de medida. 

## Paquetes

```{r echo=FALSE,message=FALSE,error=FALSE,warning=FALSE}
library(knitr)

tb <- data.frame(paquete=c("tidyverse","sf","units","maps","rnaturalearth"),
                 descripcion=c("Conjunto de paquetes (visualización y manipulación de datos): ggplot2, dplyr, purrr,etc.",
                               "Simple Feature: importar, exportar y manipular datos vectoriales",
                               "Proporciona unidades de medida para vectores R: conversión, derivación, simplificación",
                               "Mapas geográficos y conjuntos de datos",
                               "Mapas vectoriales del mundo 'Natural Earth'"))

kable(tb,booktabs = TRUE,col.names=c("Paquete","Descripción"))

```

```{r, message=FALSE,error=FALSE,warning=FALSE}
# instalamos los paquetes necesarios
if(!require("tidyverse")) install.packages("tidyverse")
if(!require("units")) install.packages("units")
if(!require("sf")) install.packages("sf")
if(!require("maps")) install.packages("maps")
if(!require("rnaturalearth")) install.packages("rnaturalearth")

# cargamos los paquetes
library(maps)
library(sf) 
library(tidyverse)
library(units)
library(rnaturalearth)
```

## Unidades de medida

El uso de vectores y matrices de clase ``units`` nos permite calcular y transformar unidades de medida.

```{r}
# longitud
l <- set_units(1:10, m)
l

# convertir a otras unidades
set_units(l, cm)

# sumar diferentes unidades
set_units(l, cm) + l

# area
a <- set_units(355, ha)
set_units(a, km2)

# velocidad
vel <- set_units(seq(20, 50, 10), km/h)
set_units(vel, m/s)

```


## Capitales del mundo

Vamos a usar las capitales de todo el mundo con el objetivo de calcular la distancia a la capital más próxima y indicar el nombre de la ciudad.  

```{r}
# conjunto de ciudades del mundo con coordenadas
head(world.cities) # proviene del paquete maps
```

Para convertir puntos con longitud y latitud en un objeto espacial de clase ``sf``, empleamos la función ``st_as_sf()``, indicando las columnas de las coordenadas y el sistema de referencia de coordenadas (WSG84, epsg:4326).

```{r}
# convertimos los puntos en un objeto sf con CRS WSG84
cities <- st_as_sf(world.cities, coords = c("long", "lat"), crs = 4326)
cities
```

En el próximo paso, simplemente filtramos por las capitales codificadas en la columna `capital` con 1. La ventaja del paquete ``sf`` es la posibilidad de aplicar funciones de la colección ``tidyverse`` para manipular los atributos. Además, añadimos una columna con nuevas etiquetas usando la función ``str_c()`` del paquete ``stringr``, la cúal es similar a la de *R Base* ``paste()``.  

```{r}
# filtramos por las capitales
capitals <- filter(cities, capital == 1)

# creamos una nueva etiqueta combinando nombre y país
capitals <- mutate(capitals, city_country = str_c(name, " (", country.etc, ")"))

capitals 

```

## Calcular distancias

La distancia geográfica (euclidiana o de gran círculo) se calcula con la función ``st_distance()``, o bien entre dos puntos, entre un punto y otros múltiples o entre todos. En el último caso obtenemos una matriz simétrica de distancias (NxN), tomados por pares de un conjunto. En la diagonal encontramos las combinaciones entre los mismos puntos dando todas nulas. 

```{r echo=FALSE,message=FALSE,error=FALSE,warning=FALSE}
library(knitr)

m <- matrix(round(rnorm(9, 300, 100)), nrow = 3)
diag(m) <- 0

m[lower.tri(m)]<- m[upper.tri(m)]

m <- rbind(c("",LETTERS[1:3]), cbind(LETTERS[1:3], m))

kable(m)
```

Cuando queremos saber, por ejemplo, la distancia de Amsterdam a Abu Dhabi, Washington y Tokyo pasamos dos objetos espaciales. 

```{r}
# calcular la distancia
dist_amsterdam <- st_distance(slice(capitals, 10), 
                              slice(capitals, c(2, 220, 205)))

dist_amsterdam # distancia en metros
```

El resultado es una matriz de una fila o de una columna (en función del orden de los objetos) con clase de ``units``. Así es posible cambiar fácilmente a otra unidad de medida. Si queremos obtener un vector sin clase ``units``, únicamente aplicamos la función ``as.vector()``.

```{r}
# cambiamos de m a km
set_units(dist_amsterdam, "km")

# units class a vector
as.vector(dist_amsterdam)
```

A continuación estimamos la matriz de distancia entre todas las capitales. Es importante convertir los valores nulos a ``NA`` para obtener posteriormente el índice correcto de la matriz. 

```{r}
# calcular la distancia
m_distance <- st_distance(capitals)

# matriz
dim(m_distance)

# cambiamos de m a km
m_distance_km <- set_units(m_distance, km)

# reemplazamos la distance de 0 con NA
m_distance_km[m_distance_km == set_units(0, km)] <- NA
```

{{% alert note %}}
Cuando el resultado es de clase ``units`` es necesario usar la misma clase para poder hacer consultas logicas. Por ejemplo, ``set_units(1, m) == set_units(1, m)`` vs. ``set_units(1, m) == 1``.
{{% /alert %}}

Con el objetivo de obtener la distancia más corta, además de la posición de la misma, usamos la función ``apply()`` que a su vez nos permite aplicar la función ``which.min()`` y ``min()`` sobre cada fila. También sería posible emplear la función sobre columnas que daría el mismo resulado. Para finalizar, añadimos los resultados como nuevas columnas con la función ``mutate()``. Las posiciones en *pos* nos permiten obtener los nombres de las ciudades más próximas. 

```{r}
# obtenemos la posición de la ciudad y la distancia
pos <- apply(m_distance_km, 1, which.min)
dist <- apply(m_distance_km, 1, min, na.rm = TRUE)

# añadimos la distancia y obtenemos el nombre de la ciudad
capitals <- mutate(capitals, nearest_city =  city_country[pos], 
                             geometry_nearest = geometry[pos],
                             distance_city = dist)

```

## Mapa de distancias a la próxima capital

Por último, construimos un mapa representando la distancia en circulos proporcionales. Para ello, usamos la gramática habitual de ``ggplot()`` añadiendo la geometría ``geom_sf()``, primero para el mapamundi de fondo y después para los circulos de las ciudades. En ``aes()`` indicamos con el argumento ``size = distance_city`` la variable que debe ser mapeado proporcionalmente. La función ``theme_void()`` elimina todos los elementos de estilo. Además, definimos con la función ``coord_sf()`` una nueva proyección indicando el formato *proj4*. 

```{r}
# mapamundi
world <- ne_countries(scale = 10, returnclass = "sf")

# mapa 
ggplot(world) +
   geom_sf(fill = "black", colour = "white") +
   geom_sf(data = capitals, 
           aes(size = distance_city),
           alpha = 0.7,
           fill = "#bd0026",
           shape = 21,
           show.legend = 'point') +
   coord_sf(crs = "+proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs") +
  labs(size = "Distance (km)", title = "Distance to the next capital") +
  theme_void()


```



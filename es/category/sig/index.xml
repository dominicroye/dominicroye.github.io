<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sig | Dr. Dominic Royé</title>
    <link>https://dominicroye.github.io/es/category/sig/</link>
      <atom:link href="https://dominicroye.github.io/es/category/sig/index.xml" rel="self" type="application/rss+xml" />
    <description>sig</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>es-ES</language><copyright>© 2018-2022 Dominic Royé. All rights reserved</copyright><lastBuildDate>Mon, 20 Dec 2021 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://dominicroye.github.io/media/logo_hu6637600e1c36fe7812a10a6623aaebda_116520_300x300_fit_lanczos_3.png</url>
      <title>sig</title>
      <link>https://dominicroye.github.io/es/category/sig/</link>
    </image>
    
    <item>
      <title>Visualizar el ciclo de día-noche en un mapamundi</title>
      <link>https://dominicroye.github.io/es/2021/visualizar-el-ciclo-de-dia-noche-en-un-mapamundi/</link>
      <pubDate>Mon, 20 Dec 2021 00:00:00 +0000</pubDate>
      <guid>https://dominicroye.github.io/es/2021/visualizar-el-ciclo-de-dia-noche-en-un-mapamundi/</guid>
      <description>
&lt;script src=&#34;https://dominicroye.github.io/es/2021/visualizar-el-ciclo-de-dia-noche-en-un-mapamundi/index.es_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;En abril de este año he hecho una animación de la temperatura media de 24 horas de enero 2020 mostrando también el ciclo día-noche.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;The average temperature of 24 hours in January 2020 with the day/night cycle. You can see a lot of geographic patterns. I love this kind of hypnotic temperature gifs. &lt;a href=&#34;https://twitter.com/hashtag/rstats?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#rstats&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/rspatial?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#rspatial&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/dataviz?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#dataviz&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/climate?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#climate&lt;/a&gt; &lt;a href=&#34;https://t.co/NA5haUlnie&#34;&gt;pic.twitter.com/NA5haUlnie&lt;/a&gt;&lt;/p&gt;&amp;mdash; Dr. Dominic Royé (@dr_xeo) &lt;a href=&#34;https://twitter.com/dr_xeo/status/1383486611707494406?ref_src=twsrc%5Etfw&#34;&gt;April 17, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;p&gt;Mi mayor problema consistía en encontrar una forma para proyectar correctamente el área de noche sin que rompa la geometría. La solución más fácil que encontré fue rasterizar el polígono de noche y posteriormente, reproyectarlo. Seguramente se podría usar un enfoque vectorial, pero aquí he preferido el uso de datos raster.&lt;/p&gt;
&lt;div id=&#34;paquetes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Paquetes&lt;/h1&gt;
&lt;p&gt;Usaremos los siguientes paquetes:&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;10%&#34; /&gt;
&lt;col width=&#34;89%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Paquete&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tidyverse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Conjunto de paquetes (visualización y manipulación de datos): ggplot2, dplyr, purrr,etc.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Simple Feature: importar, exportar y manipular datos vectoriales&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;lubridate&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fácil manipulación de fechas y tiempos&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;hms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Proporciona una clase simple para almacenar duraciones o valores de hora del día y mostrarlos en el formato hh:mm:ss&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;terra&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Importar, exportar y manipular raster (paquete sucesor de raster)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;lwgeom&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Acceso a la librería liblwgeom con funciones vectoriales adicionales para sf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;rnaturalearth&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Mapas vectoriales del mundo ‘Natural Earth’&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;gifski&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Creación de animaciones en formato gif&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# instalamos los paquetes si hace falta

if(!require(&amp;quot;tidyverse&amp;quot;)) install.packages(&amp;quot;tidyverse&amp;quot;)
if(!require(&amp;quot;sf&amp;quot;)) install.packages(&amp;quot;sf&amp;quot;)
if(!require(&amp;quot;lubridate&amp;quot;)) install.packages(&amp;quot;lubridate&amp;quot;)
if(!require(&amp;quot;hms&amp;quot;)) install.packages(&amp;quot;hms&amp;quot;)
if(!require(&amp;quot;terra&amp;quot;)) install.packages(&amp;quot;terra&amp;quot;)
if(!require(&amp;quot;lwgeom&amp;quot;)) install.packages(&amp;quot;lwgeom&amp;quot;)
if(!require(&amp;quot;rnaturalearth&amp;quot;)) install.packages(&amp;quot;rnaturalearth&amp;quot;)
if(!require(&amp;quot;gifski&amp;quot;)) install.packages(&amp;quot;gifski&amp;quot;)



# paquetes
library(rnaturalearth)
library(tidyverse)
library(lwgeom)
library(sf)
library(terra)
library(lubridate)
library(hms)
library(gifski)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Para usar la resolución de 50 y 10 m del paquete &lt;code&gt;{rnaturalearth}&lt;/code&gt; es necesario instalar los siguientes paquetes adicionales. Debe estar instalado el paquete &lt;code&gt;{devtools}&lt;/code&gt;.
&lt;code&gt;devtools::install_github(&amp;ldquo;ropensci/rnaturalearthdata&amp;rdquo;)&lt;/code&gt;
&lt;code&gt;devtools::install_github(&amp;ldquo;ropensci/rnaturalearthhires&amp;rdquo;)&lt;/code&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;preparación&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Preparación&lt;/h1&gt;
&lt;div id=&#34;funciones-externas&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Funciones externas&lt;/h2&gt;
&lt;p&gt;Las funciones para estimar la línea separador entre día y noche se basan en un javascript &lt;em&gt;L.Terminator.js&lt;/em&gt; del paquete &lt;code&gt;{Leaflet}&lt;/code&gt; que encontré en &lt;a href=&#34;https://stackoverflow.com/questions/48384058/world-map-showing-day-and-night-regions&#34;&gt;stackoverflow&lt;/a&gt;. El script con las funciones lo podéis descargar &lt;a href=&#34;https://dominicroye.github.io/files/terminator.R&#34;&gt;aquí&lt;/a&gt; o acceder en &lt;a href=&#34;https://github.com/JoGall/terminator/blob/master/terminator.R&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;source(&amp;quot;terminator.R&amp;quot;) # importamos las funciones&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;funciones-personalizadas&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Funciones personalizadas&lt;/h2&gt;
&lt;p&gt;La función principal &lt;code&gt;terminator()&lt;/code&gt; basada en el javascript de &lt;code&gt;{Leaflet}&lt;/code&gt; necesita como argumentos: la fecha con la hora, la extensión mínima y máxima de longitud así como la resolución o el intervalo de longitud.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t0 &amp;lt;- Sys.time() # fecha y hora de nuestro sistema operativo
t0&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2021-12-23 11:33:08 CET&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;coord_nightday &amp;lt;- terminator(t0, -180, 180, 0.2) # estimamos la línea día-noche

# lo convertimos en un objecto espacial de clase sf
line_nightday &amp;lt;- st_linestring(as.matrix(coord_nightday)) %&amp;gt;% st_sfc(crs = 4326) 

# ploteamos
plot(line_nightday)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2021/visualizar-el-ciclo-de-dia-noche-en-un-mapamundi/index.es_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;En el sigiente paso obtenemos los polígonos que corresponden al día y la noche que separa la línea estimada anteriormente. Para ello creamos un rectángulo cubriendo todo el planeta y empleamos la función &lt;code&gt;st_split()&lt;/code&gt; del paquete &lt;code&gt;{lwgeom}&lt;/code&gt; que divide el rectángulo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# rectángulo 
wld_bbx &amp;lt;- st_bbox(c(xmin = -180, xmax = 180,
                       ymin = -90, ymax = 90), 
                     crs = 4326) %&amp;gt;% 
             st_as_sfc()

# divisón con la línea día-noche
poly_nightday &amp;lt;-  st_split(wld_bbx, line_nightday) %&amp;gt;% 
                      st_collection_extract(c(&amp;quot;POLYGON&amp;quot;)) %&amp;gt;% 
                       st_sf() 

# ploteamos 
plot(poly_nightday)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2021/visualizar-el-ciclo-de-dia-noche-en-un-mapamundi/index.es_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;La pregunta que ahora surge es cuál de los dos poligonos corresponde a la noche y cúal al día. Eso dependerá en qué día del año estamos, dado los cambios de posición de la Tierra con respecto al Sol. Entre el equinoccio de primeravera y el equinoccio de otoño corresponde con el primer polígono, cuándo también podemos observar el día polar en el polo norte, y en el caso contrario sería el segundo. El paquete &lt;code&gt;{terra}&lt;/code&gt; sólo acepta la clase vectorial propia llamada &lt;code&gt;SpatVector&lt;/code&gt;, por eso convertimos el objeto vectorial sf con la función &lt;code&gt;vect()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# selecionamos el segundo polígono
poly_nightday &amp;lt;- slice(poly_nightday, 2) %&amp;gt;% 
                    mutate(daynight = 1)

# creamos el raster con una resolución de 0,5º y la extensión del mundo
r &amp;lt;- rast(vect(wld_bbx), resolution = .5)

# rasterizamos el polígono de noche 
night_rast &amp;lt;- rasterize(vect(poly_nightday), r) 

# resultado en formato raster
plot(night_rast)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2021/visualizar-el-ciclo-de-dia-noche-en-un-mapamundi/index.es_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;En el último paso reproyectamos el raster a &lt;a href=&#34;https://epsg.io/54009&#34;&gt;Mollweide&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# definimos la proyección del raster (WGS84)
crs(night_rast) &amp;lt;- &amp;quot;EPSG:4326&amp;quot;

# reproyectamos
night_rast_prj &amp;lt;- project(night_rast, &amp;quot;ESRI:54009&amp;quot;, 
                          mask = TRUE, 
                          method = &amp;quot;near&amp;quot;)
# mapa
plot(night_rast_prj)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2021/visualizar-el-ciclo-de-dia-noche-en-un-mapamundi/index.es_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Finalmente incluimos los pasos individuales que hemos hecho en una función personalizada.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rast_determiner &amp;lt;- function(x_min, date, res) {
  
  # crea fecha con hora añadiendo el número de minutos
  t0 &amp;lt;- as_date(date) + minutes(x_min) 
  # estimamos las coordenadas de la línea que separa día y noche 
  night_step &amp;lt;- terminator(t0, -180, 180, 0.2) %&amp;gt;% as.matrix()
  # pasamos los puntos a línea
  night_line &amp;lt;- st_linestring(night_step) %&amp;gt;% st_sfc(crs = 4326)
  
  # definimos el rectángulo del planeta
  wld_bbx &amp;lt;- st_bbox(c(xmin = -180, xmax = 180,
                       ymin = -90, ymax = 90), 
                     crs = 4326) %&amp;gt;% 
             st_as_sfc()
  
  # dividimos el polígono con la línea de día-noche
  poly_nightday &amp;lt;-  st_split(wld_bbx, night_line) %&amp;gt;% 
                      st_collection_extract(c(&amp;quot;POLYGON&amp;quot;)) %&amp;gt;% 
                       st_sf()  
  
  # seleccionamos el polígono según la fecha
  if(date &amp;lt;= make_date(year(date), 3, 20) | date &amp;gt;= make_date(year(date), 9, 23)) {
    
    poly_nightday &amp;lt;- slice(poly_nightday, 2) %&amp;gt;% 
      mutate(daynight = 1)
    
  } else {
    
    poly_nightday &amp;lt;- slice(poly_nightday, 1) %&amp;gt;% 
      mutate(daynight = 1)
  }
  
  # creamos el raster con la resolución del argumento res
  r &amp;lt;- rast(vect(wld_bbx), resolution = res)
  
  # rasterizamos el polígono de noche
  night_rast &amp;lt;- rasterize(vect(poly_nightday), r) 
  
  return(night_rast)
  
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dado que queremos obtener el área de noche para diferentes horas del día construimos una segunda función para aplicar la primera sobre diferentes intervalos del día (en minutos).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;night_determinator &amp;lt;- function(time_seq, # minutos 
                               date = Sys.Date(), # fecha (por defecto del sistema)
                               res = .5) { # resolución del raster 0.5º

# aplicamos la primera función sobre un vector de minutos
night_raster &amp;lt;-  map(time_seq, 
                     rast_determiner,
                     date = date, 
                     res = res)

# convertimos el raster en un objeto de tantas capas como unidades de minutos
night_raster &amp;lt;- rast(night_raster)

# definimos la proyección WGS84
crs(night_raster) &amp;lt;- &amp;quot;EPSG:4326&amp;quot;

return(night_raster)
  
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;cear-un-ciclo-día-noche&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Cear un ciclo día-noche&lt;/h1&gt;
&lt;p&gt;Primero creamos el área de noches para el día de nuestro sistema operativo con intervalos de 30 minutos. Después lo reproyectamos a &lt;a href=&#34;https://epsg.io/54019&#34;&gt;Winkel II&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# aplicamos nuestra función para un día de 24 horas en intervalos de 30 minutos
night_rast &amp;lt;- night_determinator(seq(0, 1410, 30), Sys.Date(), res = .5)

# proyectamos a Winkel II
night_raster_winkel &amp;lt;- project(night_rast, 
                               &amp;quot;ESRI:54019&amp;quot;, 
                                mask = TRUE,
                                method = &amp;quot;near&amp;quot;)
# mapa de los primeros 5
plot(night_raster_winkel, maxnl = 5)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2021/visualizar-el-ciclo-de-dia-noche-en-un-mapamundi/index.es_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;animación-del-ciclo-día-noche&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Animación del ciclo día-noche&lt;/h1&gt;
&lt;div id=&#34;preparación-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Preparación&lt;/h2&gt;
&lt;p&gt;Para crear una animación de 24 horas mostrando el movimiento de la noche sobre la Tierra debemos hacer unos pasos previos. Primero obtenemos los límites del mundo con la función &lt;code&gt;ne_countries()&lt;/code&gt; y los reproyectamos a la nueva proyección Winkel II. Después convertimos los datos raster en un &lt;code&gt;data.frame&lt;/code&gt; indicando que mantenga valores ausentes. Podemos observar que cada capa del raster (de cada intervalo de 30 minutos) es una columna en el &lt;code&gt;data.frame&lt;/code&gt;. Renombramos las columnas y convertimos la tabla en un formato largo empleando la función &lt;code&gt;pivot_longer()&lt;/code&gt;. Lo que hacemos es fusionar todas las columnas de las capas en una única. Como último paso excluimos los valores ausentes con la función &lt;code&gt;filter()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# límites de países
wld &amp;lt;- ne_countries(scale = 10, returnclass = &amp;quot;sf&amp;quot;) %&amp;gt;% 
         st_transform(&amp;quot;ESRI:54019&amp;quot;)

# convertimos el raster a un data.frame con xyz
df_winkel &amp;lt;- as.data.frame(night_raster_winkel, xy = TRUE, na.rm = FALSE)

# renombramos todas las columnas correspondientes a los intervalos del día
names(df_winkel)[3:length(df_winkel)] &amp;lt;- str_c(&amp;quot;H&amp;quot;, as_hms(seq(0, 1410, 30)*60))

# cambiamos a un formato largo de tabla
df_winkel &amp;lt;- pivot_longer(df_winkel, 3:length(df_winkel), names_to = &amp;quot;hour&amp;quot;, values_to = &amp;quot;night&amp;quot;) 

# excluimos los valores ausentes para reducir el tamaño de la tabla
df_winkel &amp;lt;- filter(df_winkel, !is.na(night))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sólo resta crear una retícula y obtener la extensión del mapamundi.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# retícula
grid &amp;lt;- st_graticule() %&amp;gt;%   st_transform(&amp;quot;ESRI:54019&amp;quot;)

# obtenemos la extensión del mundo
bbx &amp;lt;- st_bbox(wld)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;mapa&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Mapa&lt;/h2&gt;
&lt;p&gt;El mapa de cualquier hora lo construimos con &lt;code&gt;ggplot2&lt;/code&gt; añadiendo la geometría vectorial con &lt;code&gt;geom_sf()&lt;/code&gt; (los límites y la retícula) y con &lt;code&gt;geom_raster()&lt;/code&gt; los datos raster. En el título estamos usando un símbolo unicode como reloj. Además definimos la extensión del mapa en &lt;code&gt;coord_sf()&lt;/code&gt; para mantenerlo constante sobre todos los mapas en la animación. Por último, hacemos uso de &lt;code&gt;{{ }}&lt;/code&gt; de &lt;a href=&#34;https://www.tidyverse.org/blog/2019/06/rlang-0-4-0/&#34;&gt;{rlang}&lt;/a&gt; dentro de la función &lt;code&gt;filter()&lt;/code&gt; para poder filtrar nuestros datos raster en forma de tabla. Con el objetivo de que nuestra función pueda evaluar correctamente los valores que pasamos en &lt;code&gt;x&lt;/code&gt; (los intervalos del día) es necesario usar esta gramatica de &lt;em&gt;tidy evaluation&lt;/em&gt; por &lt;em&gt;data masking&lt;/em&gt; de &lt;code&gt;tidyverse&lt;/code&gt;. Es un tema para otro post.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# ejemplo 5 UTC
x &amp;lt;- &amp;quot;H05:00:00&amp;quot;

# mapa
ggplot() +
  # límites
  geom_sf(data = wld,
        fill = &amp;quot;#74a9cf&amp;quot;, 
        colour = &amp;quot;white&amp;quot;,
          size = .1) +
  # retícula
  geom_sf(data = grid, size = .1) +
  # datos raster filtrados 
  geom_raster(data = filter(df_winkel, hour == {{x}}), 
              aes(x, y), 
            fill = &amp;quot;grey90&amp;quot;,
            alpha = .6) +
  # título
  labs(title = str_c(&amp;quot;\U1F551&amp;quot;, str_remove(x, &amp;quot;H&amp;quot;), &amp;quot; UTC&amp;quot;)) + 
  # límites de extensión
  coord_sf(xlim = bbx[c(1, 3)], 
           ylim = bbx[c(2, 4)])  +
  # estilo del mapa
  theme_void() +
  theme(plot.title = element_text(hjust = .1, vjust = .9))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2021/visualizar-el-ciclo-de-dia-noche-en-un-mapamundi/index.es_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;animación&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Animación&lt;/h2&gt;
&lt;p&gt;Creamos la animación aplicando la función &lt;code&gt;walk()&lt;/code&gt;, que a su vez pasará por el vector de intervalos para filtrar nuestros datos y mapear cada paso haciendo uso de &lt;code&gt;ggplot&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;walk(str_c(&amp;quot;H&amp;quot;, as_hms(seq(0, 1410, 30)*60)), function(step){
  
g &amp;lt;- ggplot() +
  geom_sf(data = wld,
        fill = &amp;quot;#74a9cf&amp;quot;, 
        colour = &amp;quot;white&amp;quot;,
          size = .1) +
  geom_sf(data = grid,
          size = .1) +
  geom_raster(data = filter(df, hour == !!step), aes(x, y), 
            fill = &amp;quot;grey90&amp;quot;,
            alpha = .6) +
  labs(title = str_c(&amp;quot;\U1F551&amp;quot;, str_remove(x, &amp;quot;H&amp;quot;), &amp;quot; UTC&amp;quot;)) + 
  coord_sf(xlim = bbx[c(1, 3)], ylim = bbx[c(2, 4)])  +
  theme_void() +
  theme(plot.title = element_text(hjust = .1, vjust = .9))


ggsave(str_c(&amp;quot;wld_night_&amp;quot;, str_remove_all(step, &amp;quot;:&amp;quot;), &amp;quot;.png&amp;quot;), g,
       height = 4.3, width = 8.4, bg = &amp;quot;white&amp;quot;, dpi = 300, units = &amp;quot;in&amp;quot;)

})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La creación del gif final lo hacemos con &lt;code&gt;gifski()&lt;/code&gt; pasándole los nombres de las imagenes en el orden como deben aparecer en la animación.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;files &amp;lt;- str_c(&amp;quot;wld_night_&amp;quot;, str_remove_all(as_hms(seq(0, 710, 30)*60), &amp;quot;:&amp;quot;), &amp;quot;.png&amp;quot;)

gifski(files, &amp;quot;night_day.gif&amp;quot;, width = 807, height = 409, loop = TRUE, delay = 0.1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;night_day.gif&#34; /&gt;&lt;!-- --&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Cartografía firefly</title>
      <link>https://dominicroye.github.io/es/2021/cartografia-firefly/</link>
      <pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate>
      <guid>https://dominicroye.github.io/es/2021/cartografia-firefly/</guid>
      <description>
&lt;script src=&#34;https://dominicroye.github.io/es/2021/cartografia-firefly/index.es_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;div id=&#34;cartografía-firefly&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Cartografía &lt;em&gt;firefly&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;Los mapas &lt;em&gt;firefly&lt;/em&gt; (lampíridos ingl.) son promocionados y descritos por
&lt;a href=&#34;https://twitter.com/John_M_Nelson&#34;&gt;John Nelson&lt;/a&gt; quien publicó un &lt;a href=&#34;https://adventuresinmapping.com/2016/10/17/firefly-cartography/&#34;&gt;post&lt;/a&gt; en 2016 sobre sus características. No obstante, este tipo de mapas están vinculados a ArcGIS, lo que me ha llevado a intentar recrearlos en R. La reciente extensión de &lt;code&gt;ggplot2&lt;/code&gt; con el paquete &lt;a href=&#34;https://github.com/marcmenem/ggshadow&#34;&gt;&lt;code&gt;ggshadow&lt;/code&gt;&lt;/a&gt; nos facilitará la creación de este estilo cartográfico. Se caracteriza por tres elementos 1) un mapa base oscuro y desaturado (p.j. imágenes satelitales) 2) una viñeta y área resaltada enmascarada y 3) una única capa temática brillante. Lo esencial son los colores y el brillo que se logra con colores fríos, habitualmente colores neón. John Nelson explica más detalles en este &lt;a href=&#34;https://www.esri.com/arcgis-blog/products/mapping/mapping/steal-this-firefly-style-please/&#34;&gt;post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;¿Para qué sirve el estilo &lt;em&gt;firefly&lt;/em&gt;? En palabras de &lt;a href=&#34;https://www.esri.com/arcgis-blog/products/mapping/mapping/steal-this-firefly-style-please/&#34;&gt;John Nelson&lt;/a&gt;: “the map style that captures our attention and dutifully honors the First Law of Geography”. John hace referencia a lo dicho por Waldo Tobler
“everything is related to everything else, but near things are more related than distant things” (Tobler 1970).&lt;/p&gt;
&lt;p&gt;En este post visualizaremos todos los terremotos registrados en el suroeste de Europa con una magnitud mayor de 3.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;paquetes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Paquetes&lt;/h1&gt;
&lt;p&gt;Usaremos los siguientes paquetes:&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;13%&#34; /&gt;
&lt;col width=&#34;86%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Paquete&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tidyverse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Conjunto de paquetes (visualización y manipulación de datos): ggplot2, dplyr, purrr,etc.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;plotwidgets&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Contiene funciones para la conversión de colores (RGB, HSL)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;terra&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Importar, exportar y manipular raster (paquete sucesor de raster)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;raster&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Importar, exportar y manipular raster&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Simple Feature: importar, exportar y manipular datos vectoriales&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ggshadow&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Extensión de ggplot2 para geometrías con sombreado&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ggspatial&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Extensión de ggplot2 para objetos espaciales&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ggnewscale&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Extensión de ggplot2 para crear multiples scalas&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;janitor&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Funciones sencillas para examinar y limpiar datos&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;rnaturalearth&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Mapas vectoriales del mundo ‘Natural Earth’&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# instalamos los paquetes si hace falta

if(!require(&amp;quot;tidyverse&amp;quot;)) install.packages(&amp;quot;tidyverse&amp;quot;)
if(!require(&amp;quot;sf&amp;quot;)) install.packages(&amp;quot;sf&amp;quot;)
if(!require(&amp;quot;terra&amp;quot;)) install.packages(&amp;quot;terra&amp;quot;)
if(!require(&amp;quot;raster&amp;quot;)) install.packages(&amp;quot;raster&amp;quot;)
if(!require(&amp;quot;plotwidgets&amp;quot;)) install.packages(&amp;quot;plotwidgets&amp;quot;)
if(!require(&amp;quot;ggshadow&amp;quot;)) install.packages(&amp;quot;ggshadow&amp;quot;)
if(!require(&amp;quot;ggspatial&amp;quot;)) install.packages(&amp;quot;ggspatial&amp;quot;)
if(!require(&amp;quot;ggnewscale&amp;quot;)) install.packages(&amp;quot;ggnewscale&amp;quot;)
if(!require(&amp;quot;janitor&amp;quot;)) install.packages(&amp;quot;janitor&amp;quot;)
if(!require(&amp;quot;rnaturalearth&amp;quot;)) install.packages(&amp;quot;rnaturalearth&amp;quot;)

# paquetes

library(raster)
library(terra)
library(sf)
library(tidyverse)
library(plotwidgets)
library(ggshadow)
library(ggspatial)
library(ggnewscale)
library(janitor)
library(rnaturalearth)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;preparación&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Preparación&lt;/h1&gt;
&lt;div id=&#34;datos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Datos&lt;/h2&gt;
&lt;p&gt;Primero descargamos todos los datos necesarios. Para el mapa de base usaremos la Blue Marble vía el acceso a worldview.earthdata.nasa.gov donde me he descargado una selección del área de interés en formato geoTiff con una resolución de 1 km. Es importante ajustar la resolución al detalle necesario del mapa.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Selección de Blue Marble via &lt;a href=&#34;https://worldview.earthdata.nasa.gov&#34;&gt;worldview.earthdata.nasa.gov&lt;/a&gt; (~66 MB) &lt;a href=&#34;https://www.dropbox.com/s/bt8qfkzw339q13l/snapshot-2017-11-30T00_00_00Z.tiff?dl=0&#34;&gt;descarga&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Registros de terremotos históricos en el suroeste de Europa del &lt;a href=&#34;https://www.ign.es/web/ign/portal/sis-catalogo-terremotos&#34;&gt;IGN&lt;/a&gt; &lt;a href=&#34;https://dominicroye.github.io/files/catalogoComunSV_1621713848556.csv&#34;&gt;descarga&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;importar&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Importar&lt;/h2&gt;
&lt;p&gt;Lo primero que hacemos es importar el raster RGB &lt;em&gt;Blue Marble&lt;/em&gt; y los datos de los terremotos. Para importar el raster hago uso del nuevo paquete &lt;a href=&#34;https://rspatial.org/terra/pkg/index.html&#34;&gt;&lt;code&gt;terra&lt;/code&gt;&lt;/a&gt; que es el sucesor del paquete &lt;code&gt;raster&lt;/code&gt;. Podéis encontrar una comparación reciente &lt;a href=&#34;https://www.r-bloggers.com/2021/05/a-comparison-of-terra-and-raster-packages/&#34;&gt;aquí&lt;/a&gt;. No todos los paquetes son compatibles todavía con la nueva clase de &lt;code&gt;SpatRaster&lt;/code&gt;, por eso, nos hace falta también el paquete &lt;code&gt;raster&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# terremotos

terremotos &amp;lt;- read.csv2(&amp;quot;catalogoComunSV_1621713848556.csv&amp;quot;)
str(terremotos)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    149724 obs. of  10 variables:
##  $ Evento       : chr  &amp;quot;          33&amp;quot; &amp;quot;          34&amp;quot; &amp;quot;          35&amp;quot; &amp;quot;          36&amp;quot; ...
##  $ Fecha        : chr  &amp;quot;  02/03/1373&amp;quot; &amp;quot;  03/03/1373&amp;quot; &amp;quot;  08/03/1373&amp;quot; &amp;quot;  19/03/1373&amp;quot; ...
##  $ Hora         : chr  &amp;quot;    00:00:00&amp;quot; &amp;quot;    00:00:00&amp;quot; &amp;quot;    00:00:00&amp;quot; &amp;quot;    00:00:00&amp;quot; ...
##  $ Latitud      : chr  &amp;quot;     42.5000&amp;quot; &amp;quot;     42.5000&amp;quot; &amp;quot;     42.5000&amp;quot; &amp;quot;     42.5000&amp;quot; ...
##  $ Longitud     : chr  &amp;quot;      0.7500&amp;quot; &amp;quot;      0.7500&amp;quot; &amp;quot;      0.7500&amp;quot; &amp;quot;      0.7500&amp;quot; ...
##  $ Prof...Km.   : int  NA NA NA NA NA NA NA NA NA NA ...
##  $ Inten.       : chr  &amp;quot;     VIII-IX&amp;quot; &amp;quot;            &amp;quot; &amp;quot;            &amp;quot; &amp;quot;            &amp;quot; ...
##  $ Mag.         : chr  &amp;quot;            &amp;quot; &amp;quot;            &amp;quot; &amp;quot;            &amp;quot; &amp;quot;            &amp;quot; ...
##  $ Tipo.Mag.    : int  NA NA NA NA NA NA NA NA NA NA ...
##  $ LocalizaciÃ³n: chr  &amp;quot;RibagorÃ§a.L&amp;quot; &amp;quot;RibagorÃ§a.L&amp;quot; &amp;quot;RibagorÃ§a.L&amp;quot; &amp;quot;RibagorÃ§a.L&amp;quot; ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Blue Marble RGB raster

bm &amp;lt;- rast(&amp;quot;snapshot-2017-11-30T00_00_00Z.tiff&amp;quot;)
bm # contiene tres capas (red, green, blue)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class       : SpatRaster 
## dimensions  : 7156, 7156, 3  (nrow, ncol, nlyr)
## resolution  : 0.008789272, 0.008789272  (x, y)
## extent      : -33.49823, 29.39781, 15.77547, 78.67151  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=longlat +datum=WGS84 +no_defs 
## source      : snapshot-2017-11-30T00_00_00Z.tiff 
## red-grn-blue: 1, 2, 3 
## names       : sna_1, sna_2, sna_3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# plot

plotRGB(bm)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2021/cartografia-firefly/index.es_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;2100&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# límites países

limits &amp;lt;- ne_countries(scale = 50, returnclass = &amp;quot;sf&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;terremotos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Terremotos&lt;/h2&gt;
&lt;p&gt;En este paso limpiamos los datos importados de los terremotos. 1) Convertimos en númerico longitud, latitud y magnitud usando la función &lt;code&gt;parse_number()&lt;/code&gt; y limpiampos los nombres de las columnas con la función &lt;code&gt;clean_names()&lt;/code&gt;, 2) Creamos un objeto espacial &lt;code&gt;sf&lt;/code&gt; y lo proyectamos usando el EPSG:3035 correspondiendo a ETRS89-extended/LAEA Europe.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# limpiamos los datos y creamos un objeto sf

terremotos &amp;lt;-  terremotos %&amp;gt;% clean_names() %&amp;gt;%
               mutate(across(c(mag, latitud, longitud),                                                                                                  parse_number)) %&amp;gt;%
               st_as_sf(coords = c(&amp;quot;longitud&amp;quot;, &amp;quot;latitud&amp;quot;), 
                       crs = 4326) %&amp;gt;% 
               st_transform(3035) # proyectamos a Laea &lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;mapa-de-fondo-blue-marble&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Mapa de fondo Blue Marble&lt;/h2&gt;
&lt;p&gt;Recortamos el mapa de fondo a una extensión menor, pero todavía no limitamos el área final.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# recortamos al área deseada

bm &amp;lt;- crop(bm, extent(-20, 10, 30, 50))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para obtener una versión desaturada del raster RGB de Blue Marble, debemos aplicar una función creada con este fin. En ésta usamos la función &lt;code&gt;rgb2hsl()&lt;/code&gt; del paquete &lt;code&gt;plotwidgets&lt;/code&gt;, que nos ayuda en convertir RGB a HSL y viceversa. El modelo HSL se define con Hue (tono), Saturation (saturación), Lightness (luminosidad). Los últimos dos parametros se expresan en ratio o porcentaje. El tono está definido en una rueda de color de 0 a 360º. 0 es rojo, 120 es verde, 240 es azul. Para cambiar la saturación únicamente debemos bajar el valor de S.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# función para cambiar la saturación desde RGB

saturation &amp;lt;- function(rgb, s = .5){
  
  hsl &amp;lt;- rgb2hsl(as.matrix(rgb))
  hsl[2, ] &amp;lt;- s
  
  rgb_new &amp;lt;- as.vector(t(hsl2rgb(hsl)))
  
  return(rgb_new)
  
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Empleamos nuestra función &lt;code&gt;saturation()&lt;/code&gt; usando otra función &lt;code&gt;app()&lt;/code&gt; que la aplica a cada píxel con las tres capas de RGB. Añadimos el argumento &lt;code&gt;s&lt;/code&gt;, el que define el nivel de saturación deseada. Este paso puede tardar varios minutos. Después proyectamos nuestra imagen RGB.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# aplicamos la función para desaturar con un 5%

bm_desat &amp;lt;- app(bm, saturation, s = .05)

# plot nuevo imagen RGB

plotRGB(bm_desat)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2021/cartografia-firefly/index.es_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;2100&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# proyectamos 

bm_desat &amp;lt;- terra::project(bm_desat, &amp;quot;epsg:3035&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;construcción-del-mapa-firefly&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Construcción del mapa &lt;em&gt;firefly&lt;/em&gt;&lt;/h1&gt;
&lt;div id=&#34;límites-y-gradícula&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Límites y gradícula&lt;/h2&gt;
&lt;p&gt;Antes de empezar a construir el mapa, creamos una gradícula y estabelecemos la extensión final del mapa.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# definimos los límites finales del mapa

bx &amp;lt;- tibble(x = c(-13, 6.7), y = c(31, 47)) %&amp;gt;% 
       st_as_sf(coords = c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;), crs = 4326) %&amp;gt;%
        st_transform(3035) %&amp;gt;% 
         st_bbox()

# crearmos una gradícula del mapa

grid &amp;lt;- st_graticule(terremotos) &lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;mapa-con-fondo-de-imagen&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Mapa con fondo de imagen&lt;/h2&gt;
&lt;p&gt;La función &lt;code&gt;layer_spatial()&lt;/code&gt; de &lt;code&gt;ggspatial&lt;/code&gt; nos permite añadir un raster RGB sin grandes problemas, no obstante, todavía no apoya la nueva clase &lt;code&gt;SpatRaster&lt;/code&gt;. Por eso, debemos convertirlo en la clase &lt;code&gt;stack&lt;/code&gt; con la función &lt;code&gt;stack()&lt;/code&gt;. También es posible usar en lugar de &lt;code&gt;geom_sf()&lt;/code&gt;, la función &lt;code&gt;layer_spatial()&lt;/code&gt; para objetos vectoriales de clase &lt;code&gt;sf&lt;/code&gt; o &lt;code&gt;sp&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  layer_spatial(data = stack(bm_desat)) + # mapa de fondo Blue Marble
  geom_sf(data = limits, fill = NA, size = .3, colour = &amp;quot;white&amp;quot;) + # límites países
  coord_sf(xlim = bx[c(1, 3)], 
           ylim = bx[c(2, 4)], 
           crs = 3035,
           expand = FALSE) +
  theme_void()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2021/cartografia-firefly/index.es_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;4500&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;mapa-con-fondo-y-los-terremotos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Mapa con fondo y los terremotos&lt;/h2&gt;
&lt;p&gt;Para crear el efecto del brillo en los mapas &lt;em&gt;firefly&lt;/em&gt;, hacemos uso de la función &lt;code&gt;geom_glowpoint()&lt;/code&gt; del paquete &lt;code&gt;ggshadow&lt;/code&gt;. También existe la misma función para líneas. Dado que nuestros datos son espaciales de clase &lt;code&gt;sf&lt;/code&gt; y la geometría no apoya directamente el uso de &lt;code&gt;sf&lt;/code&gt;, debemos indicar como argumento &lt;code&gt;stats = &#34;sf_coordinates&#34;&lt;/code&gt; y dentro de &lt;code&gt;aes()&lt;/code&gt; indicar &lt;code&gt;geometry = geometry&lt;/code&gt;. Mapearemos el tamaño de los puntos en función de la magnitud. Además, filtramos aquellos terremotos con una magnitud mayor del 3.&lt;/p&gt;
&lt;p&gt;Dentro de la función &lt;code&gt;geom_glowpoint()&lt;/code&gt;, 1) definimos el color deseado para el punto y el brillo, 2) el grado de transparencia con &lt;code&gt;alpha&lt;/code&gt; bien para el punto o bien para el brillo. Por último, en la función &lt;code&gt;scale_size()&lt;/code&gt; estabelecemos el rango (mínimo, máximo) del tamaño que tendrán los puntos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  layer_spatial(data = stack(bm_desat)) +
  geom_sf(data = limits, fill = NA, size = .3, colour = &amp;quot;white&amp;quot;) +
  geom_sf(data = grid, colour = &amp;quot;white&amp;quot;, size = .1, alpha = .5) +
  geom_glowpoint(data = filter(terremotos, mag &amp;gt; 3),
                 aes(geometry = geometry, size = mag), 
                   alpha = .8,
                   color = &amp;quot;#6bb857&amp;quot;,
                   shadowcolour = &amp;quot;#6bb857&amp;quot;,
                   shadowalpha = .1,
                   stat = &amp;quot;sf_coordinates&amp;quot;,
                   show.legend = FALSE) +
  scale_size(range = c(.1, 1.5)) +
  coord_sf(xlim = bx[c(1, 3)], 
           ylim = bx[c(2, 4)], 
           crs = 3035,
           expand = FALSE) +
  theme_void()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2021/cartografia-firefly/index.es_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;4500&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;mapa-final&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Mapa final&lt;/h2&gt;
&lt;p&gt;El brillo de los mapas &lt;em&gt;firefly&lt;/em&gt; se caracteriza por tener un tono blanco o un tono más claro en el centro de los puntos. Para lograrlo, debemos duplicar la capa anterior creada, cambiando únicamente el color y hacer los puntos con su brillo más pequeños.&lt;/p&gt;
&lt;p&gt;Por defecto, &lt;code&gt;ggplot2&lt;/code&gt; no permite emplear diferentes escalas para la misma caracteristica (tamaño, color, etc) de distintas capas. Pero el paquete &lt;code&gt;ggnewscale&lt;/code&gt; nos da la posibilidad de incorporar múltiples escalas de una característica de distintas capas. Lo único importante para lograrlo es el orden en el que se añade cada capa y escala. Primero debemos poner la geometría y despúes su escala correspondiente. Indicamos con &lt;code&gt;new_scale(&#39;size&#39;)&lt;/code&gt; que la siguiente capa y escala es una nueva independiente de la anterior. Si usaramos &lt;code&gt;colour&lt;/code&gt; o &lt;code&gt;fill&lt;/code&gt; sería con &lt;code&gt;new_scale_*()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  layer_spatial(data = stack(bm_desat)) +
  geom_sf(data = limits, fill = NA, size = .3, colour = &amp;quot;white&amp;quot;) +
  geom_sf(data = grid, colour = &amp;quot;white&amp;quot;, size = .1, alpha = .5) +
  geom_glowpoint(data = filter(terremotos, mag &amp;gt; 3),
                   aes(geometry = geometry, size = mag), 
                   alpha = .8,
                   color = &amp;quot;#6bb857&amp;quot;,
                   shadowcolour = &amp;quot;#6bb857&amp;quot;,
                   shadowalpha = .1,
                   stat = &amp;quot;sf_coordinates&amp;quot;,
                   show.legend = FALSE) +
  scale_size(range = c(.1, 1.5)) +
  new_scale(&amp;quot;size&amp;quot;) +
  geom_glowpoint(data = filter(terremotos, mag &amp;gt; 3),
                   aes(geometry = geometry, size = mag), 
                   alpha = .6,
                   shadowalpha = .05,
                   color = &amp;quot;#ffffff&amp;quot;,
                   stat = &amp;quot;sf_coordinates&amp;quot;,
                   show.legend = FALSE) +
  scale_size(range = c(.01, .7)) +
  labs(title = &amp;quot;TERREMOTOS&amp;quot;) +
  coord_sf(xlim = bx[c(1, 3)], ylim = bx[c(2, 4)], crs = 3035,
           expand = FALSE) +
  theme_void() +
  theme(plot.title = element_text(size = 50, vjust = -5, colour = &amp;quot;white&amp;quot;, hjust = .95))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2021/cartografia-firefly/index.es_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;4500&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggsave(&amp;quot;firefly_map.png&amp;quot;, width = 15, height = 15, units = &amp;quot;in&amp;quot;, dpi = 300)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Mapa dasimétrico bivariante</title>
      <link>https://dominicroye.github.io/es/2021/mapa-dasimetrico-bivariante/</link>
      <pubDate>Mon, 01 Mar 2021 00:00:00 +0000</pubDate>
      <guid>https://dominicroye.github.io/es/2021/mapa-dasimetrico-bivariante/</guid>
      <description>
&lt;script src=&#34;https://dominicroye.github.io/es/2021/mapa-dasimetrico-bivariante/index.es_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;div id=&#34;consideraciones-iniciales&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Consideraciones iniciales&lt;/h1&gt;
&lt;p&gt;Una desventaja de los mapas coropletas es que estos suelen distorsionar la relación entre la verdadera geografía subyacente y la variable representada. Se debe a que las divisiones administrativas no suelen coincidir con la realidad geográfica, donde la gente vive. Además, grandes áreas aparentan tener un peso con poca población que no tienen realmente. Para reflejar mejor la realidad se hace uso de distribuciones más realista de la población como puede ser el uso de suelo. Con técnicas de Sistemas de Información Geográfica es posible redistribuir la variable de interés en función de una variable a menor unidad espacial.&lt;/p&gt;
&lt;p&gt;Cuando disponemos de datos de puntos, el proceso de redistribución simplemente es recortar áreas de puntos con población a base del uso de suelo, normalmente clasificado como urbano. En caso de polígonos también podríamos recortar con polígonos de uso de suelo, pero una alternativa interesante son los mismos datos en formato raster. Veremos cómo podemos realizar un mapa dasimétrico usando datos raster con una resolución de 100 m. En este post usaremos datos de secciones censales de la renta media y el índice de Gini de España. No sólo haremos un mapa dasimétrico, sino también bivariante, representando con dos gamas de colores ambas variables en el mismo mapa.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;paquetes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Paquetes&lt;/h1&gt;
&lt;p&gt;En este post usaremos los siguientes paquetes:&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;10%&#34; /&gt;
&lt;col width=&#34;89%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Paquete&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tidyverse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Conjunto de paquetes (visualización y manipulación de datos): ggplot2, dplyr, purrr,etc.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;patchwork&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Simple gramática para combinar ggplots separados en el mismo gráfico&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;raster&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Importar, exportar y manipular raster&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Simple Feature: importar, exportar y manipular datos vectoriales&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;biscale&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Herramientas y paletas para mapeo temático bivariado&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sysfonts&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Cargar fuentes en R&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;showtext&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Usar fuentes más fácilmente en gráficos R&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# instalamos los paquetes si hace falta
if(!require(&amp;quot;tidyverse&amp;quot;)) install.packages(&amp;quot;tidyverse&amp;quot;)
if(!require(&amp;quot;patchwork&amp;quot;)) install.packages(&amp;quot;patchwork&amp;quot;)
if(!require(&amp;quot;sf&amp;quot;)) install.packages(&amp;quot;sf&amp;quot;)
if(!require(&amp;quot;raster&amp;quot;)) install.packages(&amp;quot;raster&amp;quot;)
if(!require(&amp;quot;biscale&amp;quot;)) install.packages(&amp;quot;biscale&amp;quot;)
if(!require(&amp;quot;sysfonts&amp;quot;)) install.packages(&amp;quot;sysfonts&amp;quot;)
if(!require(&amp;quot;showtext&amp;quot;)) install.packages(&amp;quot;showtext&amp;quot;)

# paquetes
library(tidyverse)
library(sf)
library(readxl)
library(biscale)
library(patchwork)
library(raster)
library(sysfonts)
library(showtext)
library(raster)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;preparación&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Preparación&lt;/h1&gt;
&lt;div id=&#34;datos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Datos&lt;/h2&gt;
&lt;p&gt;Primero descargamos todos los datos necesarios. Con excepción de los datos CORINE Land Cover (~200 MB), se pueden obtener los datos almacenados en este blog directamente vía los enlaces indicados .&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CORINE Land Cover 2018 (geotiff): &lt;a href=&#34;https://land.copernicus.eu/pan-european/corine-land-cover/clc2018?tab=download&#34;&gt;COPERNICUS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Datos de renta e índice Gini (excel) [INE]: &lt;a href=&#34;https://dominicroye.github.io/files/renta.zip&#34;&gt;descarga&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Límites censales de España (vectorial) [INE]: &lt;a href=&#34;https://dominicroye.github.io/files/SECC_CE_20200101.zip&#34;&gt;descarga&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;importar&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Importar&lt;/h2&gt;
&lt;p&gt;Lo primero que hacemos es importar el raster del uso de suelo, los datos de renta e índice de Gini y los límites censales.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# raster de CORINE LAND COVER 2018
urb &amp;lt;- raster(&amp;quot;U2018_CLC2018_V2020_20u1.tif&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in showSRID(uprojargs, format = &amp;quot;PROJ&amp;quot;, multiline = &amp;quot;NO&amp;quot;, prefer_proj
## = prefer_proj): Discarded datum Unknown based on GRS80 ellipsoid in Proj4
## definition&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# datos de renta y Gini
renta &amp;lt;- read_excel(&amp;quot;30824.xlsx&amp;quot;)
gini &amp;lt;- read_excel(&amp;quot;37677.xlsx&amp;quot;)

# límites censales del INE
limits &amp;lt;- read_sf(&amp;quot;SECC_CE_20200101.shp&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;usos-de-suelo&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Usos de suelo&lt;/h2&gt;
&lt;p&gt;En este primer paso filtramos las secciones censales para obtener aquellas de la Comunidad Autónoma de Madrid, y creamos los límites municipales. Para disolver los polígonos de secciones censales aplicamos la función &lt;code&gt;group_by()&lt;/code&gt; en combinación con &lt;code&gt;summarise()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# filtramos la Comunidad Autónoma de Madrid
limits &amp;lt;- filter(limits, NCA == &amp;quot;Comunidad de Madrid&amp;quot;)

# obtenemos los límites municipales
mun_limit &amp;lt;- group_by(limits, CUMUN) %&amp;gt;% summarise()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En el siguiente paso recortamos el raster de uso de suelo con los límites de Madrid. Recomiendo usar siempre primero la función &lt;code&gt;crop()&lt;/code&gt; y después &lt;code&gt;mask()&lt;/code&gt;, la primera recorta a la extensión requerida y la segunda enmascara. Posteriormente, eliminamos todos los valores que correspondan a 1 o 2 (urbano continuo, discontinuo). Por último, proyectamos el raster.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# proyectamos los límites 
limits_prj &amp;lt;- st_transform(limits, projection(urb))

# acortamos y enmascaramos 
urb_mad &amp;lt;- crop(urb, limits_prj) %&amp;gt;% 
              mask(limits_prj)

# eliminamos píxeles no urbanos 
urb_mad[!urb_mad %in% 1:2] &amp;lt;- NA 

# plot del raster
plot(urb_mad)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2021/mapa-dasimetrico-bivariante/index.es_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;2100&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# proyectamos 
urb_mad &amp;lt;- projectRaster(urb_mad, crs = CRS(&amp;quot;+proj=longlat +datum=WGS84 +no_defs&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En este siguiente paso, convertimos los datos raster en un objeto &lt;code&gt;sf&lt;/code&gt; de puntos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# transformamos el raster a xyz y objeto sf 
urb_mad &amp;lt;- as.data.frame(urb_mad, xy = TRUE, na.rm = TRUE) %&amp;gt;%
                st_as_sf(coords = c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;), crs = 4326)

# añadimos las columnas de las coordinadas
urb_mad &amp;lt;- urb_mad %&amp;gt;% rename(urb = 1) %&amp;gt;% cbind(st_coordinates(urb_mad))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;renta-media-e-índice-de-gini&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Renta media e índice de Gini&lt;/h2&gt;
&lt;p&gt;El formato de los Excels no coincide con el original del INE, dado que he limpiado el formato antes con el objetivo de hacer más fácil este post. Lo que nos queda es crear una columna con los códigos de las secciones censales y excluir datos que corresponden a otro nivel administrativo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## datos renta y gini INE

renta_sec &amp;lt;- mutate(renta, NATCODE = str_extract(CUSEC, &amp;quot;[0-9]{5,10}&amp;quot;), 
                nc_len = str_length(NATCODE),
                mun_name = str_remove(CUSEC, NATCODE) %&amp;gt;% str_trim()) %&amp;gt;%
             filter(nc_len &amp;gt; 5)

gini_sec &amp;lt;- mutate(gini, NATCODE = str_extract(CUSEC, &amp;quot;[0-9]{5,10}&amp;quot;), 
               nc_len = str_length(NATCODE),
               mun_name = str_remove(CUSEC, NATCODE) %&amp;gt;% str_trim()) %&amp;gt;%
             filter(nc_len &amp;gt; 5)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En el siguiente paso unimos ambas tablas con las secciones censales usando &lt;code&gt;left_join()&lt;/code&gt; y convertimos columnas de interés en modo numérico.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# unimos ambas tablas de renta y Gini con los límites censales
mad &amp;lt;- left_join(limits, renta_sec, by = c(&amp;quot;CUSEC&amp;quot;=&amp;quot;NATCODE&amp;quot;)) %&amp;gt;% 
          left_join(gini_sec, by = c(&amp;quot;CUSEC&amp;quot;=&amp;quot;NATCODE&amp;quot;))

# convertimos columnas en numérico 
mad &amp;lt;- mutate_at(mad, c(23:27, 30:31), as.numeric)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;variable-bivariante&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Variable bivariante&lt;/h2&gt;
&lt;p&gt;Para crear un mapa bivariante debemos construir una única variable que combina diferentes clases de dos variables. Normalmente son tres de cada una lo que lleva a nueve clases en total. En nuestro caso, la renta media y el índice Gini. El paquete &lt;code&gt;biscale&lt;/code&gt; incluye funciones auxiliares para llevar a cabo este proceso. Con la función &lt;code&gt;bi_class()&lt;/code&gt; creamos esta variable de clasificación usando cuantiles como algoritmo. Dado que en ambas variables encontramos valores ausentes, corregimos aquellas combinaciones entre ambas variables donde aparece un &lt;code&gt;NA&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## creamos clasificación bivariante
mapbivar &amp;lt;- bi_class(mad, GINI_2017, RNMP_2017, style = &amp;quot;quantile&amp;quot;, dim = 3) %&amp;gt;% 
             mutate(bi_class = ifelse(str_detect(bi_class, &amp;quot;NA&amp;quot;), NA, bi_class))

# resultado
head(dplyr::select(mapbivar, GINI_2017, RNMP_2017, bi_class))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 6 features and 3 fields
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: 415538.9 ymin: 4451487 xmax: 469341.7 ymax: 4552422
## projected CRS:  ETRS89 / UTM zone 30N
## # A tibble: 6 x 4
##   GINI_2017 RNMP_2017 bi_class                                          geometry
##       &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                                   &amp;lt;MULTIPOLYGON [m]&amp;gt;
## 1      NA          NA &amp;lt;NA&amp;gt;     (((446007.9 4552348, 446133.7 4552288, 446207.8 ~
## 2      31       13581 2-2      (((460243.8 4487756, 460322.4 4487739, 460279 44~
## 3      30       12407 2-2      (((457392.5 4486262, 457391.6 4486269, 457391.1 ~
## 4      34.3     13779 3-2      (((468720.8 4481374, 468695.5 4481361, 468664.6 ~
## 5      33.5      9176 3-1      (((417140.2 4451736, 416867.5 4451737, 416436.8 ~
## 6      26.2     10879 1-1      (((469251.9 4480826, 469268.1 4480797, 469292.6 ~&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Terminamos redistribuyendo la variable de desigualdad sobre los píxeles del uso de suelo urbano. La función &lt;code&gt;st_join()&lt;/code&gt; une los datos con los puntos del uso de suelo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## redistribuimos los píxeles urbanos a la desigualdad
mapdasi &amp;lt;- st_join(urb_mad, st_transform(mapbivar, 4326))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;construcción-del-mapa&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Construcción del mapa&lt;/h1&gt;
&lt;div id=&#34;leyenda-y-fuente&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Leyenda y fuente&lt;/h2&gt;
&lt;p&gt;Antes de construir ambos mapas debemos crear la leyenda usando la función &lt;code&gt;bi_legend()&lt;/code&gt;. En la función definimos los títulos para cada variable, el número de dimensiones y la gama de colores. Por último, añadimos la fuente de Montserrat para los títulos del gráfico final.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# leyenda bivariante
legend2 &amp;lt;- bi_legend(pal = &amp;quot;DkViolet&amp;quot;,
                     dim = 3,
                     xlab = &amp;quot;Más desigual&amp;quot;,
                     ylab = &amp;quot;Más renta&amp;quot;,
                     size = 9)


#descarga de fuente
font_add_google(&amp;quot;Montserrat&amp;quot;, &amp;quot;Montserrat&amp;quot;)
showtext_auto()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;mapa-dasimétrico&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Mapa dasimétrico&lt;/h2&gt;
&lt;p&gt;Este mapa construimos usando &lt;code&gt;geom_tile()&lt;/code&gt; para los píxeles y &lt;code&gt;geom_sf()&lt;/code&gt; para los límites municipales. Además, será el mapa de la derecha donde ubicamos también la leyenda. Para añadir la leyenda hacemos uso de la función &lt;code&gt;annotation_custom()&lt;/code&gt; indicando la posición en las coordenadas geográficas del mapa. El paquete &lt;code&gt;biscale&lt;/code&gt; también nos ayuda con la definición del color a través de la función &lt;code&gt;bi_scale_fill()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p2 &amp;lt;- ggplot(mapdasi) + 
  geom_tile(aes(X, Y, 
                fill = bi_class), 
            show.legend = FALSE) +
  geom_sf(data = mun_limit,  
          color = &amp;quot;grey80&amp;quot;, 
          fill = NA, 
          size = 0.2) +
  annotation_custom(ggplotGrob(legend2), 
                    xmin = -3.25, xmax = -2.65,
                    ymin = 40.55, ymax = 40.95) +
  bi_scale_fill(pal = &amp;quot;DkViolet&amp;quot;, 
                dim = 3, 
                na.value = &amp;quot;grey90&amp;quot;) +
  labs(title = &amp;quot;dasimétrico&amp;quot;, x = &amp;quot;&amp;quot;, y =&amp;quot;&amp;quot;) +
  bi_theme() +
  theme(plot.title = element_text(family = &amp;quot;Montserrat&amp;quot;, size = 30, face = &amp;quot;bold&amp;quot;)) +
  coord_sf(crs = 4326)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;mapa-coropleta&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Mapa coropleta&lt;/h2&gt;
&lt;p&gt;El mapa coropleta se construye de forma similar al mapa anterior con la diferencia de que usamos &lt;code&gt;geom_sf()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p1 &amp;lt;- ggplot(mapbivar) + 
  geom_sf(aes(fill = bi_class), 
          colour = NA, 
          size = .1, 
          show.legend = FALSE) +
  geom_sf(data = mun_limit,  
          color = &amp;quot;white&amp;quot;, 
          fill = NA, 
          size = 0.2) +
  bi_scale_fill(pal = &amp;quot;DkViolet&amp;quot;, 
                dim = 3, 
                na.value = &amp;quot;grey90&amp;quot;) +
  labs(title = &amp;quot;coroplético&amp;quot;,  x = &amp;quot;&amp;quot;, y =&amp;quot;&amp;quot;) +
  bi_theme() +
  theme(plot.title = element_text(family = &amp;quot;Montserrat&amp;quot;, size = 30, face = &amp;quot;bold&amp;quot;)) +
  coord_sf(crs = 4326)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;combinar-ambos-mapas&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Combinar ambos mapas&lt;/h2&gt;
&lt;p&gt;Con ayuda del paquete &lt;code&gt;patchwork&lt;/code&gt; combinamos ambos mapas en una única fila, primero el mapa coropleta y a su derecha el mapa dasimétrico. Más detalles de la gramática que se usa para la combinación de gráficos &lt;a href=&#34;https://patchwork.data-imaginist.com/&#34;&gt;aquí&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Combinamos 
p &amp;lt;- p1 | p2

p&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2021/mapa-dasimetrico-bivariante/index.es_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;3300&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Direcciones del flujo fluvial</title>
      <link>https://dominicroye.github.io/es/2020/direcciones-del-flujo-fluvial/</link>
      <pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate>
      <guid>https://dominicroye.github.io/es/2020/direcciones-del-flujo-fluvial/</guid>
      <description>
&lt;script src=&#34;https://dominicroye.github.io/es/2020/direcciones-del-flujo-fluvial/index.es_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;Recientemente creé una visualización de la distribución de las direcciones del flujo fluvial y también de las orientaciones costeras. A raíz de su publicación en los RRSS (&lt;a href=&#34;https://twitter.com/dr_xeo/status/1277978724034465798?s=2&#34;&gt;aquí&lt;/a&gt;) me pidieron que hiciera un post acerca de cómo lo hice. Pues bien, aquí vamos para empezar con un ejemplo de los ríos, la orientación costera es algo más compleja. Lo mismo hice para una selección de ríos europeos aquí en este &lt;a href=&#34;https://twitter.com/dr_xeo/status/1277243216828473345?s=20&#34;&gt;tweet&lt;/a&gt;. No obstante, originalmente empecé con la orientación de las costas europeas.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Have you ever wondered where the European &lt;a href=&#34;https://twitter.com/hashtag/coasts?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#coasts&lt;/a&gt; are oriented? &lt;a href=&#34;https://twitter.com/hashtag/rstats?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#rstats&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/ggplot2?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#ggplot2&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/geography?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#geography&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/dataviz?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#dataviz&lt;/a&gt; &lt;a href=&#34;https://t.co/tpWVxSoHlw&#34;&gt;pic.twitter.com/tpWVxSoHlw&lt;/a&gt;&lt;/p&gt;&amp;mdash; Dr. Dominic Royé (@dr_xeo) &lt;a href=&#34;https://twitter.com/dr_xeo/status/1265286552525180929?ref_src=twsrc%5Etfw&#34;&gt;May 26, 2020&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;div id=&#34;paquetes&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Paquetes&lt;/h2&gt;
&lt;p&gt;En este post usaremos los siguientes paquetes:&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;11%&#34; /&gt;
&lt;col width=&#34;88%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Paquete&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tidyverse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Conjunto de paquetes (visualización y manipulación de datos): ggplot2, dplyr, purrr,etc.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;remotes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Instalación desde repositorios remotos&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;qgisprocess&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Interfaz entre R y QGIS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Simple Feature: importar, exportar y manipular datos vectoriales&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ggtext&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Soporte para la representación de texto mejorado con ggplot2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sysfonts&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Cargar fuentes en R&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;showtext&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Usar fuentes más fácilmente en gráficos R&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;circular&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Funciones para trabajar con datos circulares&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;geosphere&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Trigonometría esférica para aplicaciones geográficas&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;En el caso del paquete &lt;code&gt;qgisprocess&lt;/code&gt; es necesario instalar QIGS &amp;gt;= 3.16 &lt;a href=&#34;https://download.qgis.org/&#34;&gt;aquí&lt;/a&gt;. Más adelante explicaré la razón del uso de QGIS.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# instalamos los paquetes si hace falta
if(!require(&amp;quot;tidyverse&amp;quot;)) install.packages(&amp;quot;tidyverse&amp;quot;)
if(!require(&amp;quot;remotes&amp;quot;)) install.packages(&amp;quot;remotes&amp;quot;)
if(!require(&amp;quot;qgisprocess&amp;quot;)) remotes::install_github(&amp;quot;paleolimbot/qgisprocess&amp;quot;)
if(!require(&amp;quot;sf&amp;quot;)) install.packages(&amp;quot;sf&amp;quot;)
if(!require(&amp;quot;ggtext&amp;quot;)) install.packages(&amp;quot;ggtext&amp;quot;)
if(!require(&amp;quot;circular&amp;quot;)) install.packages(&amp;quot;circular&amp;quot;)
if(!require(&amp;quot;geosphere&amp;quot;)) install.packages(&amp;quot;geosphere&amp;quot;)
if(!require(&amp;quot;sysfonts&amp;quot;)) install.packages(&amp;quot;sysfonts&amp;quot;)
if(!require(&amp;quot;showtext&amp;quot;)) install.packages(&amp;quot;showtext&amp;quot;)

# paquetes
library(sf)
library(tidyverse)
library(ggtext)
library(circular)
library(geosphere)
library(qgisprocess)
library(showtext)
library(sysfonts)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;consideraciones-iniciales&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Consideraciones iniciales&lt;/h1&gt;
&lt;p&gt;Los ángulos en líneas vectoriales se basan en el ángulo entre dos vértices, y el número de vértices depende de la complejidad, y en consecuencia de la resolución, de los datos vectoriales. Por tanto, puede haber diferencias en usar distintas resoluciones de una línea vectorial, sea de la costa o del río como en este ejemplo. Una línea recta simplemente se construye con dos puntos de longitud y latitud.&lt;/p&gt;
&lt;p&gt;Relacionado con ello está la fractalidad, una estructura aparentemente irregular pero que se repite a diferentes escalas, de la línea de costa o también del río. La característica más paradójica es que la longitud de una línea costera depende de la escala de medida, cuanto menor es el incremento de medida, la longitud medida se incrementa.&lt;/p&gt;
&lt;p&gt;Existen dos posibiliades de obtener los ángulos de los vértices. En la primera calculamos el ángulo entre todos los vértices consecutivos.&lt;/p&gt;
&lt;p&gt;Por ejemplo, imaginémonos dos puntos, Madrid (-3.71, 40.43) y Barcelona (2.14, 41.4).&lt;/p&gt;
&lt;p&gt;¿Cuál es el ángulo de su línea recta?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bearingRhumb(c(-3.71, 40.43), c(2.14, 41.4))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 77.62391&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vemos que es el de 77º, o sea, dirección noreste. Pero, ¿y si voy de Barcelona a Madrid?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bearingRhumb(c(2.14, 41.4), c(-3.71, 40.43))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 257.6239&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El angúlo es diferente porque nos &lt;em&gt;movemos&lt;/em&gt; desde el noreste al suroeste. Podemos invertir fácilmente el ángulo para obtener el &lt;em&gt;movimiento&lt;/em&gt; contrario.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# ángulo contrario de Barcelona -&amp;gt; Madrid
bearingRhumb(c(2.14, 41.4), c(-3.71, 40.43)) - 180&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 77.62391&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# ángulo contrario de Madrid -&amp;gt; Barcelona
bearingRhumb(c(-3.71, 40.43), c(2.14, 41.4)) + 180&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 257.6239&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La dirección en la que calculamos los ángulos es importante. En el caso de los ríos se espera que sea la dirección de flujo de origen a la desembocadura, ahora bien, un problema puede ser que los vértices, que construyen las líneas, no estén ordenados geográficamente en la tabla de atributos. Otro problema puede ser que los vértices empiecen en la desembocadura lo que daría al angúlo inverso como lo hemos visto antes.&lt;/p&gt;
&lt;p&gt;Sin embargo, hay una forma más fácil. Podemos aprovechar los atributos de los sistemas de coordenadas proyectados (proyección Robinson, etc) que incluyen el ángulo entre los vértices. Este último enfoque lo vamos usar en este post. Aún así, debemos prestar mucha atención a los resultados según lo dicho anteriormente.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;preparación&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Preparación&lt;/h1&gt;
&lt;div id=&#34;datos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Datos&lt;/h2&gt;
&lt;p&gt;Descargamos las líneas centrales de los ríos más grandes del mundo (&lt;a href=&#34;https://dominicroye.github.io/files/RiverHRCenterlinesCombo.zip&#34;&gt;descarga&lt;/a&gt;), accesible también en &lt;a href=&#34;https://www.sciencebase.gov/catalog/item/5a145fdde4b09fc93dcfd36c&#34;&gt;Zeenatul Basher et al. 2018&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;importar-y-proyectar&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Importar y proyectar&lt;/h2&gt;
&lt;p&gt;Lo primero que hacemos es importar, proyectar y eliminar la tercera dimensión &lt;em&gt;Z&lt;/em&gt;, usando el encadenamiento de las siguientes functions: &lt;code&gt;st_read()&lt;/code&gt; nos ayuda a importar cualquier formato vectorial, &lt;code&gt;st_zm()&lt;/code&gt; elimina la dimensión Z o M de una geometría vectorial y &lt;code&gt;st_transform()&lt;/code&gt; proyecta los datos vectoriales a la nueva proyección en formato &lt;em&gt;proj4&lt;/em&gt;. La combinación de las funciones la realizamos con el famoso &lt;em&gt;pipe&lt;/em&gt; (&lt;code&gt;%&amp;gt;%&lt;/code&gt;) que facilita la aplicación de una secuencia de funciones sobre un conjunto de datos, más detalles en este &lt;a href=&#34;https://dominicroye.github.io/es/2020/una-muy-breve-introducci%C3%B3n-a-tidyverse/&#34;&gt;post&lt;/a&gt;. Todas las funciones del paquete &lt;code&gt;sf&lt;/code&gt; comienzan por &lt;code&gt;st_*&lt;/code&gt; haciendo referencia al carácter espacial de su aplicación, similar a &lt;em&gt;PostGIS.&lt;/em&gt; Igualmente, y al mismo estilo que &lt;em&gt;PostGIS&lt;/em&gt;, se usan verbos como nombres de función.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;proj_rob &amp;lt;- &amp;quot;+proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m no_defs&amp;quot;

river_line &amp;lt;- st_read(&amp;quot;RiverHRCenterlinesCombo.shp&amp;quot;) %&amp;gt;% 
                 st_zm() %&amp;gt;% 
                    st_transform(proj_rob)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Reading layer `RiverHRCenterlinesCombo&amp;#39; from data source 
##   `E:\GitHub\blog_update_2021\content\es\post\2020-07-24-direcciones-del-flujo-fluvial\RiverHRCenterlinesCombo.shp&amp;#39; 
##   using driver `ESRI Shapefile&amp;#39;
## Simple feature collection with 78 features and 6 fields
## Geometry type: MULTILINESTRING
## Dimension:     XYZ
## Bounding box:  xmin: -164.7059 ymin: -36.97094 xmax: 151.5931 ymax: 72.64474
## z_range:       zmin: 0 zmax: 0
## Geodetic CRS:  WGS 84&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;extraer-los-ángulos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Extraer los ángulos&lt;/h2&gt;
&lt;p&gt;En el siguiente paso debemos extraer los ángulos de los vértices. Desgraciadamente, hasta donde sepa, no es posible extraer los atributos con alguna función del paquete &lt;code&gt;sf&lt;/code&gt;. Aunque la función &lt;code&gt;st_coordinates()&lt;/code&gt; nos devuelve las coordenadas, no incluye otros atributos. Por eso, debemos usar otra forma, y es que el open software Quantum GIS extrae todos los atributos de los vértices. Podríamos importar los datos vectoriales en QGIS Desktop y exportar los vértices desde allí, pero también es posible acceder a las funciones de QGIS desde R directamente.&lt;/p&gt;
&lt;p&gt;Para ello, tenemos que tener instalado QGIS en OSGeo4W. El paquete &lt;code&gt;qgisprocess&lt;/code&gt; nos permite de forma muy fácil usar las funciones del programa en R. Primero empleamos la función &lt;code&gt;qgis_configure()&lt;/code&gt; para definir todas las rutas necesarias de QGIS.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# rutas a QGIS
qgis_configure()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## getOption(&amp;#39;qgisprocess.path&amp;#39;) was not found.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Sys.getenv(&amp;#39;R_QGISPROCESS_PATH&amp;#39;) was not found.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Trying &amp;#39;qgis_process&amp;#39; on PATH&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Success!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## QGIS version: 3.18.1-Zürich&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Metadata of 986 algorithms queried and stored in cache.
## Run `qgis_algorithms()` to see them.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La función &lt;code&gt;qgis_algorithms()&lt;/code&gt; nos ayuda a buscar diferentes herramientas de QGIS. Además la función &lt;code&gt;qgis_show_help()&lt;/code&gt; especifica la forma de uso con todos los argumentos requeridos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# buscar herramientas
qgis_algorithms()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 986 x 5
##    provider provider_title algorithm         algorithm_id    algorithm_title    
##    &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt;             &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;              
##  1 3d       QGIS (3D)      3d:tessellate     tessellate      Tessellate         
##  2 gdal     GDAL           gdal:aspect       aspect          Aspect             
##  3 gdal     GDAL           gdal:assignproje~ assignprojecti~ Assign projection  
##  4 gdal     GDAL           gdal:buffervecto~ buffervectors   Buffer vectors     
##  5 gdal     GDAL           gdal:buildvirtua~ buildvirtualra~ Build virtual rast~
##  6 gdal     GDAL           gdal:buildvirtua~ buildvirtualve~ Build virtual vect~
##  7 gdal     GDAL           gdal:cliprasterb~ cliprasterbyex~ Clip raster by ext~
##  8 gdal     GDAL           gdal:cliprasterb~ cliprasterbyma~ Clip raster by mas~
##  9 gdal     GDAL           gdal:clipvectorb~ clipvectorbyex~ Clip vector by ext~
## 10 gdal     GDAL           gdal:clipvectorb~ clipvectorbypo~ Clip vector by mas~
## # ... with 976 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# uso de la herramienta
qgis_show_help(&amp;quot;native:extractvertices&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Extract vertices (native:extractvertices)
## 
## ----------------
## Description
## ----------------
## This algorithm takes a line or polygon layer and generates a point layer with points representing the vertices in the input lines or polygons. The attributes associated to each point are the same ones associated to the line or polygon that the point belongs to.
## 
## Additional fields are added to the point indicating the vertex index (beginning at 0), the vertex’s part and its index within the part (as well as its ring for polygons), distance along original geometry and bisector angle of vertex for original geometry.
## 
## ----------------
## Arguments
## ----------------
## 
## INPUT: Input layer
##  Argument type:  source
##  Acceptable values:
##      - Path to a vector layer
## OUTPUT: Vertices
##  Argument type:  sink
##  Acceptable values:
##      - Path for new vector layer
## 
## ----------------
## Outputs
## ----------------
## 
## OUTPUT: &amp;lt;outputVector&amp;gt;
##  Vertices&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En nuestro caso la herramienta para extraer los vértices es simple y sólo lleva una entrada y una salida. La función &lt;code&gt;qgis_run_algorithm()()&lt;/code&gt; ejecuta una herramienta de QGIS indicando el algoritmo y sus argumentos. La ventaja de usar el algoritmo directamente desde R es que podemos pasar objetos de clase &lt;code&gt;sf&lt;/code&gt; (o &lt;code&gt;sp&lt;/code&gt;) y &lt;code&gt;raster&lt;/code&gt; que tenemos importados o creados en R. Como salida creamos un &lt;code&gt;geojson&lt;/code&gt;, también podría ser de otro formato vectorial, y lo guardamos en una carpeta temporal. Para obtener el resultado de QGIS sólo necesitamos emplear la función &lt;code&gt;qgis_output()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;river_vertices &amp;lt;- qgis_run_algorithm(alg = &amp;quot;native:extractvertices&amp;quot;,
               INPUT = river_line,
               OUTPUT = file.path(tempdir(), &amp;quot;rivers_world_vertices.geojson&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Running cmd.exe /c call qgis_process run &amp;quot;native:extractvertices&amp;quot; \
##   &amp;quot;--INPUT=C:\Users\xeo19\AppData\Local\Temp\RtmpSg3M8l\file57ec4c224632\file57ec66d44605.gpkg&amp;quot; \
##   &amp;quot;--OUTPUT=C:\Users\xeo19\AppData\Local\Temp\RtmpSg3M8l/rivers_world_vertices.geojson&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## proj_create_from_database: Cannot find proj.db
## proj_create_from_database: Cannot find proj.db&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## proj_create_from_wkt: Cannot find proj.db&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## proj_identify: Cannot find proj.db&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## proj_get_authorities_from_database: Cannot find proj.db&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## proj_as_wkt: Cannot find proj.db&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## ----------------
## Inputs
## ----------------
## 
## INPUT:   C:\Users\xeo19\AppData\Local\Temp\RtmpSg3M8l\file57ec4c224632\file57ec66d44605.gpkg
## OUTPUT:  C:\Users\xeo19\AppData\Local\Temp\RtmpSg3M8l/rivers_world_vertices.geojson
## 
## 
## 0...10...20...30...40...50...60...70...80...90...
## ----------------
## Results
## ----------------
## 
## OUTPUT:  C:\Users\xeo19\AppData\Local\Temp\RtmpSg3M8l/rivers_world_vertices.geojson&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;river_vertices &amp;lt;- st_read(qgis_output(river_vertices, &amp;quot;OUTPUT&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Reading layer `rivers_world_vertices&amp;#39; from data source 
##   `C:\Users\xeo19\AppData\Local\Temp\RtmpSg3M8l\rivers_world_vertices.geojson&amp;#39; 
##   using driver `GeoJSON&amp;#39;
## Simple feature collection with 339734 features and 12 fields
## Geometry type: POINT
## Dimension:     XY
## Bounding box:  xmin: -12117400 ymin: -3953778 xmax: 13751910 ymax: 7507359
## Geodetic CRS:  WGS 84&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Actualmente en Windows parece haber problemas con la librería de &lt;em&gt;proj&lt;/em&gt;. En principio si termina creando el objeto &lt;code&gt;river_vertices&lt;/code&gt; no debes preocuparte.
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;selección&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Selección&lt;/h2&gt;
&lt;p&gt;Antes de seguir con la estimación de la distribución de los ángulos, filtramos algunos ríos de interés. Las funciones de la colección &lt;code&gt;tidyverse&lt;/code&gt; son compatibles con el paquete &lt;code&gt;sf&lt;/code&gt;. En el último post hice una introducción a &lt;code&gt;tidyverse&lt;/code&gt; &lt;a href=&#34;https://dominicroye.github.io/es/2020/una-muy-breve-introducci%C3%B3n-a-tidyverse/&#34;&gt;aquí&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;river_vertices &amp;lt;-  filter(river_vertices, 
                          NAME %in% c(&amp;quot;Mississippi&amp;quot;, &amp;quot;Colorado&amp;quot;, 
                                      &amp;quot;Amazon&amp;quot;, &amp;quot;Nile&amp;quot;, &amp;quot;Orange&amp;quot;, 
                                      &amp;quot;Ganges&amp;quot;, &amp;quot;Yangtze&amp;quot;, &amp;quot;Danube&amp;quot;,
                                      &amp;quot;Mackenzie&amp;quot;, &amp;quot;Lena&amp;quot;, &amp;quot;Murray&amp;quot;, 
                                      &amp;quot;Niger&amp;quot;)
                          ) 

river_vertices &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 94702 features and 12 fields
## Geometry type: POINT
## Dimension:     XY
## Bounding box:  xmin: -10377520 ymin: -3953778 xmax: 13124340 ymax: 7507359
## Geodetic CRS:  WGS 84
## First 10 features:
##    fid NAME SYSTEM name_alt scalerank rivernum Length_km vertex_index
## 1    6 Nile   &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;         1        4  3343.871            0
## 2    6 Nile   &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;         1        4  3343.871            1
## 3    6 Nile   &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;         1        4  3343.871            2
## 4    6 Nile   &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;         1        4  3343.871            3
## 5    6 Nile   &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;         1        4  3343.871            4
## 6    6 Nile   &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;         1        4  3343.871            5
## 7    6 Nile   &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;         1        4  3343.871            6
## 8    6 Nile   &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;         1        4  3343.871            7
## 9    6 Nile   &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;         1        4  3343.871            8
## 10   6 Nile   &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;         1        4  3343.871            9
##    vertex_part vertex_part_index  distance      angle                geometry
## 1            0                 0     0.000  31.096005 POINT (3037149 1672482)
## 2            0                 1  1208.130  22.456672 POINT (3037772 1673517)
## 3            0                 2  2324.160   8.602259 POINT (3038039 1674600)
## 4            0                 3  3656.452   8.573580 POINT (3038118 1675930)
## 5            0                 4  5735.538  24.406889 POINT (3038612 1677950)
## 6            0                 5  6758.322  25.134763 POINT (3039200 1678787)
## 7            0                 6 10432.834   6.998982 POINT (3040164 1682333)
## 8            0                 7 14865.136   4.239641 POINT (3040070 1686764)
## 9            0                 8 16563.207 358.730530 POINT (3040356 1688438)
## 10           0                 9 18376.526 347.480822 POINT (3039972 1690210)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;estimar-la-distribución&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Estimar la distribución&lt;/h1&gt;
&lt;p&gt;Para visualizar la distribución podemos usar, o bien un histograma o un gráfico de densidad. Pero en el caso de estimar la función de densidad de probabilidad nos encontramos con un problema matemático a la hora de aplicarlo a datos circulares. No debemos usar la función estandar de R &lt;code&gt;density()&lt;/code&gt; dado que en nuestros datos una dirección de 360º es la misma a 0º, lo que provocaría errores en este rango de valores. Es un problema general para diferentes métricas estadísticas. Más detalles estadísticos se explican en el paquete &lt;code&gt;circular&lt;/code&gt;. Este paquete permite definir las características de los datos circulares (unidad, tipo de datos, rotación, etc.) como una clase de objeto en R.&lt;/p&gt;
&lt;p&gt;Por tanto, lo que hacemos es construir una función que estime la densidad y devuelva una tabla con los ángulos (x) y las estimaciones de densidad (y). Dado que los ríos tienen diferentes longitudes, y queremos ver diferencias independientemente de ello, normalizamos las estimaciones usando el valor máximo. A diferencia de la función &lt;code&gt;density()&lt;/code&gt;, en la que el ancho de banda de suavizado &lt;code&gt;bw&lt;/code&gt; es optimizado, aquí es requerido indicarlo. Es similar a definir el ancho de barra en un histograma. Existe una función de optimización para la banda, &lt;code&gt;bw.nrd.circular()&lt;/code&gt; que se podría emplear aquí.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dens_circ &amp;lt;- function(x){
  
  dens &amp;lt;- density.circular(circular(x$angle, units = &amp;quot;degrees&amp;quot;),
                                     bw = 70, kernel = &amp;quot;vonmises&amp;quot;,
                                     control.circular = list(units = &amp;quot;degrees&amp;quot;))
  
  df &amp;lt;- data.frame(x = dens$x, y = dens$y/max(dens$y))
  
  return(df)
  
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para finalizar, estimamos la densidad de cada río de nuestra selección. Empleamos la función &lt;code&gt;split()&lt;/code&gt; de &lt;em&gt;R Base&lt;/em&gt; para obtener una tabla de cada río en una lista. Después aplicamos con la función &lt;code&gt;map_df()&lt;/code&gt; del paquete &lt;code&gt;purrr&lt;/code&gt; nuestra función de estimación de densidad a la lista. El sufijo &lt;code&gt;_df&lt;/code&gt; permite que obtengamos una tabla unida, en lugar de una lista con los resultados de cada río. No obstante, es necesario indicar el nombre de la columna con el argumento &lt;code&gt;.id&lt;/code&gt;, la que contendrá el nombre de cada río. En caso contrario no sabríamos diferenciar los resultados. También aquí recomiendo leer más detalles en el último post sobre &lt;code&gt;tidyverse&lt;/code&gt; &lt;a href=&#34;https://dominicroye.github.io/es/2020/una-muy-breve-introducci%C3%B3n-a-tidyverse/&#34;&gt;aquí&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dens_river &amp;lt;- split(river_vertices, river_vertices$NAME) %&amp;gt;% 
                  map_df(dens_circ, .id = &amp;quot;river&amp;quot;)

# resultado
head(dens_river)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    river        x         y
## 1 Amazon 0.000000 0.2399907
## 2 Amazon 0.704501 0.2492548
## 3 Amazon 1.409002 0.2585758
## 4 Amazon 2.113503 0.2679779
## 5 Amazon 2.818004 0.2774859
## 6 Amazon 3.522505 0.2871232&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;visualización&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Visualización&lt;/h1&gt;
&lt;p&gt;Ahora ya sólo nos queda la visualización mediante el famoso paquete &lt;code&gt;ggplot&lt;/code&gt;. Primero añadimos una nueva fuente &lt;em&gt;Montserrat&lt;/em&gt; para usarla en este gráfico.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# descarga de fuente
font_add_google(&amp;quot;Montserrat&amp;quot;, &amp;quot;Montserrat&amp;quot;)

# usar showtext para fuentes
showtext_opts(dpi = 200)
showtext_auto() &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En el siguiente paso creamos dos objetos con el título y con una nota de pie. En el título estamos usando un código html para dar color a una parte de texto en sustitución de una leyenda. Se puede usar html de forma muy fácil con el paquete &lt;code&gt;ggtext&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# título con html 
title &amp;lt;- &amp;quot;Relative distribution of river &amp;lt;span style=&amp;#39;color:#011FFD;&amp;#39;&amp;gt;&amp;lt;strong&amp;gt;flow direction&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt; in the world&amp;quot;


caption &amp;lt;- &amp;quot;Based on data from Zeenatul Basher, 20180215&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La cuadrícula de fondo que crea &lt;code&gt;ggplot&lt;/code&gt; por defecto para coordenadas polares no me convenció, por eso creamos una tabla con las líneas de fondo del eje x.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;grid_x &amp;lt;- tibble(x = seq(0, 360 - 22.5, by = 22.5), 
                 y = rep(0, 16), 
                 xend = seq(0, 360 - 22.5, by = 22.5), 
                 yend = rep(Inf, 16))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A continuación definimos todos los estilos del gráfico. Lo más importante en este paso es la función &lt;code&gt;element_textbox()&lt;/code&gt; del paquete &lt;code&gt;ggtext&lt;/code&gt; para poder interpretar nuestro código html incorporado al título.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;theme_polar &amp;lt;- function(){ 
               theme_minimal() %+replace%
               theme(axis.title.y = element_blank(),
                     axis.text.y = element_blank(),
                     legend.title = element_blank(),
                     plot.title = element_textbox(family = &amp;quot;Montserrat&amp;quot;, 
                                                   hjust = 0.5, 
                                                   colour = &amp;quot;white&amp;quot;, 
                                                   size = 15),
                     plot.caption = element_text(family = &amp;quot;Montserrat&amp;quot;, 
                                                 colour = &amp;quot;white&amp;quot;),
                     axis.text.x = element_text(family = &amp;quot;Montserrat&amp;quot;, 
                                                 colour = &amp;quot;white&amp;quot;),
                     strip.text = element_text(family = &amp;quot;Montserrat&amp;quot;, 
                                               colour = &amp;quot;white&amp;quot;, 
                                               face = &amp;quot;bold&amp;quot;),
                     panel.background = element_rect(fill = &amp;quot;black&amp;quot;),
                     plot.background = element_rect(fill = &amp;quot;black&amp;quot;),
                     panel.grid = element_blank()
                    )
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para terminar construimos el gráfico: 1) Usamos la función &lt;code&gt;geom_hline()&lt;/code&gt; con diferentes puntos de intersección en &lt;em&gt;y&lt;/em&gt; para crear la cuadrícula de fondo. La función &lt;code&gt;geom_segment()&lt;/code&gt; crea la cuadrícula en &lt;em&gt;x&lt;/em&gt;. 2) El área de densidad la creamos usando la función &lt;code&gt;geom_area()&lt;/code&gt;. 3) En &lt;code&gt;scale_x_continous()&lt;/code&gt; definimos un límite inferior
negativo para que no colapse en un punto pequeño. Las etiquetas de las ocho direcciones principales las indicamos en la función &lt;code&gt;scale_y_continous()&lt;/code&gt;, y 4) Por último, cambiamos a un sistema de coordenadas polar y fijamos la variable para crear facetas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  geom_hline(yintercept = c(0, .2, .4, .6, .8, 1), colour = &amp;quot;white&amp;quot;) +
  geom_segment(data = grid_x , 
               aes(x = x, y = y, xend = xend, yend = yend), 
               linetype = &amp;quot;dashed&amp;quot;, col = &amp;quot;white&amp;quot;) +
  geom_area(data = dens_river, 
            aes(x = x, y = y, ymin = 0, ymax = y), 
            alpha = .7, 
            colour = NA, 
            show.legend = FALSE,
            fill = &amp;quot;#011FFD&amp;quot;) + 
  scale_y_continuous(limits = c(-.2, 1), expand = c(0, 0)) +
  scale_x_continuous(limits = c(0, 360), 
                     breaks = seq(0, 360 - 22.5, by = 22.5),
                     minor_breaks = NULL,
                     labels = c(&amp;quot;N&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;NE&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;E&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;SE&amp;quot;, &amp;quot;&amp;quot;,
                                &amp;quot;S&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;SW&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;W&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;NW&amp;quot;, &amp;quot;&amp;quot;)) +
  coord_polar() + 
  facet_wrap(river ~ ., ncol = 4) +
  labs(title = title, caption = caption, x = &amp;quot;&amp;quot;) +
  theme_polar()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Ignoring unknown aesthetics: ymin, ymax&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2020/direcciones-del-flujo-fluvial/index.es_files/figure-html/unnamed-chunk-19-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Calcular la distancia al mar en R</title>
      <link>https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/</link>
      <pubDate>Tue, 08 Jan 2019 00:00:00 +0000</pubDate>
      <guid>https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/</guid>
      <description>
&lt;script src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;En geografía, la distancia al mar es una variable fundamental, especialmente relevante a la hora de modelizar. Por ejemplo, en interpolaciones de la temperatura del aire habitualmente se hace uso de la distancia al mar como variable predictora, ya que existe una relación casual entre ambas que explica la variación espacial. ¿Cómo podemos estimar la distancia (más corta) a la costa en R?&lt;/p&gt;
&lt;div id=&#34;paquetes&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Paquetes&lt;/h2&gt;
&lt;p&gt;En este post usaremos los siguientes paquetes:&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;14%&#34; /&gt;
&lt;col width=&#34;85%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Paquete&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tidyverse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Conjunto de librerías (visualización y manipulación de datos): ggplot2, dplyr, etc.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Simple Feature: importar, exportar y manipular datos vectoriales&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;raster&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Importar, exportar y manipular raster&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;rnaturalearth&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Conjunto de mapas vectoriales ‘natural earth’&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;RColorBrewer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Paletas de colores&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#instalamos los paquetes si hace falta
if(!require(&amp;quot;tidyverse&amp;quot;)) install.packages(&amp;quot;tidyverse&amp;quot;)
if(!require(&amp;quot;sf&amp;quot;)) install.packages(&amp;quot;sf&amp;quot;)
if(!require(&amp;quot;raster&amp;quot;)) install.packages(&amp;quot;raster&amp;quot;)
if(!require(&amp;quot;rnaturalearth&amp;quot;)) install.packages(&amp;quot;rnaturalearth&amp;quot;)

#paquetes
library(rnaturalearth)
library(sf)
library(raster)
library(tidyverse)
library(RColorBrewer)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;la-costa-de-islandia-como-ejemplo&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;La costa de Islandia como ejemplo&lt;/h2&gt;
&lt;p&gt;Nuestro ejemplo en este post será Islandia, como es un territorio insular facilitará el ensayo y de este modo es posible mostrar el proceso de forma sencilla. La librería &lt;em&gt;rnaturalearth&lt;/em&gt; permite importar los límites de países (con diferentes niveles administrativos) de todo el mundo. Los datos vienen de la plataforma &lt;a href=&#34;http://www.naturalearthdata.com/&#34;&gt;naturalearthdata.com&lt;/a&gt;. Recomiendo explorar la librería, más info &lt;a href=&#34;https://github.com/ropensci/rnaturalearth&#34;&gt;aquí&lt;/a&gt;. La función &lt;code&gt;ne_countries( )&lt;/code&gt; importa los límites de países. En este caso indicamos con el argumento &lt;em&gt;scale&lt;/em&gt; la resolución (10,50 o 110m), con &lt;em&gt;country&lt;/em&gt; indicamos el país concreto de interés y con &lt;em&gt;returnclass&lt;/em&gt; determinamos que clase queremos (&lt;em&gt;sf&lt;/em&gt; o &lt;em&gt;sp&lt;/em&gt;), en nuestro caso &lt;em&gt;sf&lt;/em&gt; (simple feature).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;world &amp;lt;- ne_countries(scale = 50) #mapamundi con 50m de resolución

plot(world) #tiene clase sp por defecto&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#importamos los límites de Islandia 
iceland &amp;lt;- ne_countries(scale = 10,country = &amp;quot;Iceland&amp;quot;, returnclass = &amp;quot;sf&amp;quot;)

#info del objeto vectorial
iceland&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 1 feature and 94 fields
## Geometry type: MULTIPOLYGON
## Dimension:     XY
## Bounding box:  xmin: -24.53991 ymin: 63.39671 xmax: -13.50292 ymax: 66.56415
## CRS:           +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0
##          featurecla scalerank labelrank sovereignt sov_a3 adm0_dif level
## 188 Admin-0 country         0         3    Iceland    ISL        0     2
##                  type   admin adm0_a3 geou_dif geounit gu_a3 su_dif subunit
## 188 Sovereign country Iceland     ISL        0 Iceland   ISL      0 Iceland
##     su_a3 brk_diff    name name_long brk_a3 brk_name brk_group  abbrev postal
## 188   ISL        0 Iceland   Iceland    ISL  Iceland      &amp;lt;NA&amp;gt; Iceland     IS
##               formal_en formal_fr name_ciawf note_adm0 note_brk name_sort
## 188 Republic of Iceland      &amp;lt;NA&amp;gt;    Iceland      &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;   Iceland
##     name_alt mapcolor7 mapcolor8 mapcolor9 mapcolor13 pop_est pop_rank
## 188     &amp;lt;NA&amp;gt;         1         4         4          9  339747       10
##     gdp_md_est pop_year lastcensus gdp_year                    economy
## 188      16150     2017         NA     2016 2. Developed region: nonG7
##               income_grp wikipedia fips_10_ iso_a2 iso_a3 iso_a3_eh iso_n3
## 188 1. High income: OECD        NA       IC     IS    ISL       ISL    352
##     un_a3 wb_a2 wb_a3   woe_id woe_id_eh                   woe_note adm0_a3_is
## 188   352    IS   ISL 23424845  23424845 Exact WOE match as country        ISL
##     adm0_a3_us adm0_a3_un adm0_a3_wb continent region_un       subregion
## 188        ISL         NA         NA    Europe    Europe Northern Europe
##                 region_wb name_len long_len abbrev_len tiny homepart min_zoom
## 188 Europe &amp;amp; Central Asia        7        7          7   NA        1        0
##     min_label max_label      ne_id wikidataid name_ar name_bn name_de name_en
## 188         2         7 1159320917       Q189    &amp;lt;NA&amp;gt;    &amp;lt;NA&amp;gt;  Island Iceland
##      name_es name_fr name_el name_hi name_hu  name_id name_it name_ja name_ko
## 188 Islandia Islande    &amp;lt;NA&amp;gt;    &amp;lt;NA&amp;gt;  Izland Islandia Islanda    &amp;lt;NA&amp;gt;    &amp;lt;NA&amp;gt;
##     name_nl  name_pl  name_pt name_ru name_sv name_tr name_vi name_zh
## 188 IJsland Islandia Islândia    &amp;lt;NA&amp;gt;  Island Izlanda Iceland    &amp;lt;NA&amp;gt;
##                           geometry
## 188 MULTIPOLYGON (((-14.56363 6...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#aquí Islandia
plot(iceland)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/figure-html/unnamed-chunk-3-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Por defecto, la función &lt;code&gt;plot( )&lt;/code&gt; con la clase &lt;em&gt;sf&lt;/em&gt; nos crea tantas facetas del mapa como variables tiene. Para limitarlo podemos usar o bien con el nombre de una variable &lt;code&gt;plot(iceland[&#34;admin&#34;])&lt;/code&gt; o el argumento &lt;em&gt;max.plot&lt;/em&gt; &lt;code&gt;plot(iceland,max.plot=1)&lt;/code&gt;. Con el argumento &lt;em&gt;max.plot=1&lt;/em&gt; la función usa la primera variable disponible del mapa.&lt;/p&gt;
&lt;p&gt;Además, vemos en la información del objeto &lt;em&gt;sf&lt;/em&gt; que la proyección es WGS84 con grados decimales (código EPSG:4326). Para el cálculo de distancias es más conveniente usar metros en lugar de grados. Debido a ello, lo primero que hacemos es transformar el mapa de Islandia a UTM Zona 27 (código EPSG:3055). Más información sobre EPSG y proyecciones &lt;a href=&#34;http://spatialreference.org/ref/epsg/wgs-84/&#34;&gt;aquí&lt;/a&gt;. Con ese objetivo, usamos la función &lt;code&gt;st_transform( )&lt;/code&gt;. Simplemente indicamos el mapa y el código EPSG.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#transformamos a UTM
iceland &amp;lt;- st_transform(iceland, 3055)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;crear-una-red-de-puntos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Crear una red de puntos&lt;/h2&gt;
&lt;p&gt;Todavía necesitamos los puntos donde queremos conocer la distancia. En nuestro caso será una red regular de puntos en Islandia con una resolución de 5km. Esa tarea la hacemos con la función &lt;code&gt;st_make_grid( )&lt;/code&gt;, indicando con el argumento &lt;em&gt;cellsize&lt;/em&gt; la resolución en la unidad del sistema de coordenadas (metros en nuestro caso) y qué geometría nos gustaría crear &lt;em&gt;what&lt;/em&gt; (poligonos, centros o esquinas).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#crear red de puntos
grid &amp;lt;- st_make_grid(iceland,cellsize = 5000, what = &amp;quot;centers&amp;quot;)

#nuestra red sobre la extensión de Islandia
plot(grid)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#exraemos sólamente los puntos en los límites de Islandia
grid &amp;lt;- st_intersection(grid, iceland)   

#nuestra red ahora
plot(grid)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;calcular-la-distancia&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Calcular la distancia&lt;/h2&gt;
&lt;p&gt;Para estimar la distancia usamos la función &lt;code&gt;st_distance( )&lt;/code&gt; que nos devuelve un vector de distancias para todos nuestros puntos de la red. Pero antes es necesario transformar el mapa de Islandia de una forma de polígono (MULTIPOLYGON) a línea (MULTILINESTRING). Más detalles con &lt;code&gt;?st_cast&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#convertimos Islandia de geometría poligono a línea
iceland &amp;lt;- st_cast(iceland, &amp;quot;MULTILINESTRING&amp;quot;)

#cálculo de la distancia entre la costa y nuestros puntos
dist &amp;lt;- st_distance(iceland, grid)

#distancia con unidad en metros
head(dist[1,])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Units: [m]
## [1]  790.7906 1151.4360 1270.7603 3128.9057 2428.5677 4197.7472&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;visualizar-la-distancia-calculada&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Visualizar la distancia calculada&lt;/h2&gt;
&lt;p&gt;Una vez obtenida la distancia para nuestros puntos, podemos combinarlos con las coordenadas y plotearlos en &lt;em&gt;ggplot2&lt;/em&gt;. Para ello, creamos un &lt;em&gt;data.frame&lt;/em&gt;. El objeto &lt;em&gt;dist&lt;/em&gt; es una matriz de una columna, por eso, tenemos que convertirla a vector con la función &lt;code&gt;as.vector( )&lt;/code&gt;. Además, dividimos por 1000 para convertir la distancia en metros a km. La función &lt;code&gt;st_coordinates( )&lt;/code&gt; extrae las coordenadas de nuestros puntos. Para la visualización usamos un vector de colores con la gama RdGy (más &lt;a href=&#34;http://colorbrewer2.org&#34;&gt;aquí&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#creamos un data.frame con la distancia y las coorendas de los puntos
df &amp;lt;- data.frame(dist = as.vector(dist)/1000,
                    st_coordinates(grid))

#estructura
str(df)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    4104 obs. of  3 variables:
##  $ dist: num  0.791 1.151 1.271 3.129 2.429 ...
##  $ X   : num  608796 613796 583796 588796 593796 ...
##  $ Y   : num  7033371 7033371 7038371 7038371 7038371 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#colores 
col_dist &amp;lt;- brewer.pal(11, &amp;quot;RdGy&amp;quot;)


ggplot(df, aes(X, Y,fill = dist))+ #variables
         geom_tile()+ #geometría
           scale_fill_gradientn(colours = rev(col_dist))+ #colores para la distancia
             labs(fill = &amp;quot;Distance (km)&amp;quot;)+ #nombre de la leyenda
             theme_void()+ #estilo del mapa
              theme(legend.position = &amp;quot;bottom&amp;quot;) #posición de la leyenda&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;exportar-la-distancia-como-raster&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Exportar la distancia como raster&lt;/h2&gt;
&lt;p&gt;Para poder exportar la distancia con respecto al mar de Islandia, debemos usar la función &lt;code&gt;rasterize( )&lt;/code&gt; de la librería &lt;em&gt;raster&lt;/em&gt;.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Primero, es necesario crear un raster vacío. En este raster debemos indicar la resolución, en nuestro caso es de 5000m, la proyección y la extensión del raster.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: lower-alpha&#34;&gt;
&lt;li&gt;&lt;p&gt;La proyección la podemos extraer de la información del mapa de Islandia.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;La extensión la conseguimos extraer de nuestros puntos &lt;em&gt;grid&lt;/em&gt; con la función &lt;code&gt;extent( )&lt;/code&gt;. No obstante, esta última función necesita la clase &lt;em&gt;sp&lt;/em&gt;, por eso pasamos el objeto &lt;em&gt;grid&lt;/em&gt; en formato &lt;em&gt;sf&lt;/em&gt;, únicamente para ello, a la clase &lt;em&gt;sp&lt;/em&gt; usando la función &lt;code&gt;as( )&lt;/code&gt; y el argumento “Spatial”.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Además de lo anterior, el &lt;em&gt;data.frame&lt;/em&gt; &lt;strong&gt;df&lt;/strong&gt; que creamos antes debemos convertir en clase &lt;em&gt;sf&lt;/em&gt;. Por eso, aplicamos la función &lt;code&gt;st_as_sf( )&lt;/code&gt; con el argumento &lt;em&gt;coords&lt;/em&gt; indicando los nombres de las coordenadas. Adicionalmente, también definimos el sistema de coordenadas que conocemos.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#obtenemos la extensión
ext &amp;lt;- extent(as(grid, &amp;quot;Spatial&amp;quot;))

#objeto extent
ext&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class      : Extent 
## xmin       : 338795.6 
## xmax       : 848795.6 
## ymin       : 7033371 
## ymax       : 7383371&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#raster destino
r &amp;lt;- raster(resolution = 5000, ext = ext, crs = &amp;quot;+proj=utm +zone=27 +ellps=intl +towgs84=-73,47,-83,0,0,0,0 +units=m +no_defs&amp;quot;)

#convertimos los puntos a un spatial object clase sf
dist_sf &amp;lt;- st_as_sf(df, coords = c(&amp;quot;X&amp;quot;,&amp;quot;Y&amp;quot;)) %&amp;gt;%
                      st_set_crs(3055)

#creamos el raster de la distancia
dist_raster &amp;lt;- rasterize(dist_sf, r, &amp;quot;dist&amp;quot;, fun = mean)

#raster
dist_raster&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class      : RasterLayer 
## dimensions : 70, 102, 7140  (nrow, ncol, ncell)
## resolution : 5000, 5000  (x, y)
## extent     : 338795.6, 848795.6, 7033371, 7383371  (xmin, xmax, ymin, ymax)
## crs        : +proj=utm +zone=27 +ellps=intl +units=m +no_defs 
## source     : memory
## names      : layer 
## values     : 0.006124901, 115.1712  (min, max)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#plotear el raster
plot(dist_raster)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#exportamos el raster
writeRaster(dist_raster, file = &amp;quot;dist_islandia.tif&amp;quot;, format = &amp;quot;GTiff&amp;quot;, overwrite = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La función &lt;code&gt;rasterize( )&lt;/code&gt; está pensada para crear rasters a partir de un grid irregular. En caso que tengamos un grid regular, como este mismo, podemos usar una alternativa más fácil. La función &lt;code&gt;rasterFromXYZ( )&lt;/code&gt; convierte un &lt;em&gt;data.frame&lt;/em&gt; con longitud, latitud y la variable &lt;em&gt;Z&lt;/em&gt; en un raster. Es importante que el orden debe ser longitud, latitud, variables.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;r &amp;lt;- rasterFromXYZ(df[, c(2:3, 1)], crs = &amp;quot;+proj=utm +zone=27 +ellps=intl +towgs84=-73,47,-83,0,0,0,0 +units=m +no_defs&amp;quot;)

plot(r)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Con el cálculo de la distancia podemos llegar crear &lt;em&gt;arte&lt;/em&gt;, como se ve en la cabezera de este post, que incluye un mapamundi únicamente con la distancia al mar de todos los continentes. Una perspectiva diferente a nuestro mundo (&lt;a href=&#34;https://www.geografiainfinita.com/2017/06/una-radiografia-del-mundo-a-traves-de-la-distancia-al-mar/&#34;&gt;aquí más&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>

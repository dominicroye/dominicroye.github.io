---
categories: ["estadistica","R","R:avanzado"]
title: Resumir tests de correlaciones en R
date: '2019-04-17'
slug: resumir-tests-correlaciones-en-r
tags: ["correlación","variables","resumir","tests","limpio"]
header:
  caption: ''
  image: 'corr_matrix.png'
lang: es
summary: "Cuando pretendemos estimar la correlación entre múltiples variables, la tarea se complica para obtener un resultado simple y limpio. Una forma sencilla es usar la función ``tidy()`` del paquete *{broom}*. Como ejemplo, en este post vamos a estimar la correlación entre la precipitación anual de varias ciudades españolas y varios índices de teleconexiones climáticas."
---

Cuando pretendemos estimar la correlación entre múltiples variables, la tarea se complica para obtener un resultado simple y limpio. Una forma sencilla es usar la función ``tidy()`` del paquete *{broom}*. Como ejemplo, en este post vamos a estimar la correlación entre la precipitación anual de varias ciudades españolas y varios índices de teleconexiones climáticas: [descarga](/files/teleconnections_indices.zip). Los datos de las teleconexiones están preprocesados, pero pueden ser descargados directamente desde [crudata.uea.ac.uk](https://crudata.uea.ac.uk/cru/data/pci.htm). La preciptiación diaria proviene de [ECA&D](https://www.ecad.eu//dailydata/index.php).

## Paquetes

En este post usaremos los siguientes paquetes:
  
```{r echo=FALSE,message=FALSE,error=FALSE,warning=FALSE}
library(knitr)

tb <- data.frame(paquete=c("tidyverse","broom","fs","lubridate"),
                 descripcion=c("Conjunto de paquetes (visualización y manipulación de datos): ggplot2, dplyr, purrr,etc.",
                               "Convierte resultados de funciones estadísticas (lm, t.test, cor.test, etc.) en bonitas tablas",
                               "Proporciona una interfaz uniforme y multiplataforma para las operaciones del sistema de archivos",
                               "Fácil manipulación de fechas y tiempos"
                                ))

kable(tb,booktabs = TRUE,col.names=c("Paquete","Descripción"))

```

```{r,message=FALSE,error=FALSE,warning=FALSE}
#instalamos los paquetes si hace falta
if(!require("tidyverse")) install.packages("tidyverse")
if(!require("broom")) install.packages("broom")
if(!require("fs")) install.packages("fs")
if(!require("lubridate")) install.packages("lubridate")

#paquetes
library(tidyverse)
library(broom)
library(fs)
library(lubridate)
```


## Importar datos 

Primero debemos importar la precipitación diaria de las estaciones meteorológicas seleccionadas. 

1. Creamos un vector con todos los archivos de precipitación con la función ``dir_ls()`` del paquete *{fs}*. 
2. Importamos los datos con ayuda de la función ``map_df()`` del paquete *{purrr}* que aplica otra función a un vector o lista, y los une en una única tabla. 
3. a) Seleccionamos únicamente las columnas que nos interesan, b) Convertimos la fecha en objeto *date* con la función ``ymd()`` del paquete *{lubridate}*, c) Creamos una nueva columna *yr* con el año, d) Dividimos la precipitación entre 10 y reclasificamos valores ausentes -9999 por NA, e) Por último, reclasificamos la ID de cada estación meteorológica, creando un factor con nuevas etiquetas. 

Más detalles sobre el uso de las funciones ``dir_ls()`` y ``map_df()`` en este último [post](https://dominicroye.github.io/es/2019/importar-varias-hojas-excel-en-r/).

```{r}
#archivos de la precipitación
files <- dir_ls(regexp = "txt")
files

#importamos todos, uniéndolos en una única tabla
pr <- files %>% map_df(read_csv, skip = 20)
pr

#creamos los niveles del factor 
id <- unique(pr$STAID)

#las etiquetas correspondientes
lab <- c("Bilbao", "Santiago", "Barcelona", "Madrid", "Valencia")

#primeros cambios
pr <- select(pr, STAID, DATE, RR)%>% 
        mutate(DATE = ymd(DATE), 
               RR = ifelse(RR == -9999, NA, RR/10), 
               STAID = factor(STAID, id, lab), 
               yr = year(DATE)) 
pr

```

Lo que todavía nos hace falta es filtrar y calcular la suma anual de precipitación. En principio, no es lo más correcto sumar la precipitación sin tener en cuenta que haya valores ausentes, pero nos sirve igualmente para este ensayo. Después, cambiamos el formato de la tabla con la función ``spread()``, pasando de una tabla larga a una ancha, es decir, queremos obtener una columna por estación meteorológica. 

```{r}
pr_yr <- filter(pr, DATE >= "1950-01-01", DATE < "2018-01-01") %>%
           group_by(STAID, yr) %>%
             summarise(pr = sum(RR, na.rm = TRUE))
pr_yr

pr_yr <- spread(pr_yr, STAID, pr)
pr_yr
```

El siguiente paso es importar los índices de las teleconexiones.

```{r}
#teleconexiones
telecon <- read_csv("teleconnections_indices.csv")
telecon
```

Por último nos falta unir ambas tablas por año. 

```{r}
data_all <- left_join(pr_yr, telecon, by = "yr")
data_all
```

## Test de correlación

Un test de correlación lo podemos hacer con la función ``cor.test()`` de *R Base*. En este caso entre la precipitación anual de Bilbao y el índice de NAO. 
```{r}
cor_nao_bil <- cor.test(data_all$Bilbao, data_all$NAO,
                        method="spearman")
cor_nao_bil

str(cor_nao_bil)
```

Vemos que el resultado está en un formato poco manejable. Nos resume la correlación con todos los parametros estadísticos necesarios para sacar una conclusión sobre la relación. La estructura orginal es una lista de vectores. No obstante, la función ``tidy()`` del paquete *{broom}* nos permite convertir el resultado en formato de tabla. 

```{r}
tidy(cor_nao_bil)
```

## Aplicar el test de correlación a múltiples variables

El objetivo es aplicar el test de correlación a todas las estaciones meteorológicas e índices de teleconexión. 

Primero, debemos pasar la tabla al formato largo, o sea, crear una columna de la ciudad y el valor de la precipitación correspondiente. Después lo repetimos para las teleconexiones. 

```{r}
data <- gather(data_all, city, pr, Bilbao:Valencia) %>%
                     gather(telecon, index, NAO:AO)
data
```

Para poder aplicar el test a todas las ciudades, debemos tener las correspondientes agrupaciones. Por ello, usamos la función ``group_by()`` indicando los dos grupos (*city* y *telecon*), y además, aplicamos la función ``nest()`` del paquete *{tidyr}*, colección *{tidyverse}*, con el objetivo de crear listas de tablas encajadas por fila. En otras palabras, en cada fila de cada ciudad y teleconexión tendremos una nueva tabla que contiene  correspondientemente el año, la precipitación y el valor del índice. 

```{r}

data_nest <- group_by(data, city, telecon) %>% nest()
data_nest

str(slice(data_nest, 1))

```

El siguiente paso es crear una función, en la que definimos el test de correlación y lo pasamos al formato limpio, que aplicamos a cada agrupación. 

```{r}

cor_fun <- function(df) cor.test(df$pr, df$index, method="spearman") %>% tidy()

```

Ahora sólo nos queda por aplicar nuestra función a la columna que contiene las tablas por cada combinación entre ciudad y teleconexión. Para ello, usamos la función ``map()`` que aplica otra función sobre un vector o lista. Lo que hacemos es crear una nueva columna que contiene el resultado, una tabla del resumen estadístico, por cada fila de cada combinación. 

```{r,message=FALSE,error=FALSE,warning=FALSE}
data_nest <- mutate(data_nest, model = map(data, cor_fun))
data_nest

str(slice(data_nest, 1))
```

¿Cómo podemos deshacer la lista de tablas en cada fila de nuestra tabla?

Pues bien, primero eliminamos la columna con los datos y después aplicamos simplemente la función ``unnest()``. 

```{r}
corr_pr <- select(data_nest, -data) %>% unnest()
corr_pr
```

El resultado es una tabla en la que podemos ver las correlaciones y su significación estadística para cada ciudad y teleconexiones. 

## Heatmap de los resultados

Finalmente, hacemos un *heatmap* del resultado obtenido. Antes creamos una columna que indica si la correlación es significativa con p-valor menor de 0,05.

```{r}
corr_pr <- mutate(corr_pr, sig = ifelse(p.value < 0.05, "Sig.", "Non Sig."))
```

```{r,dpi=300}
ggplot()+
  geom_tile(data = corr_pr,
            aes(city, telecon, fill = estimate),
            size = 1,
            colour = "white")+
  geom_tile(data = filter(corr_pr, sig == "Sig."),
            aes(city, telecon),
            size = 1,
            colour = "black",
            fill = "transparent")+
  geom_text(data = corr_pr,
            aes(city, telecon, label = round(estimate, 2),
            fontface = ifelse(sig == "Sig.", "bold", "plain")))+
  scale_fill_gradient2(breaks = seq(-1, 1, 0.2))+
  labs(x = "", y = "", fill = "", p.value = "")+
  theme_minimal()+
  theme(panel.grid.major = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        axis.ticks = element_blank())
```

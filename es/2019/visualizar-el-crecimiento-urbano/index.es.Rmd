---
categories: ["visualización","R","R:principante", "gis"]
title: Visualizar el crecimiento urbano
date: '2019-11-01'
slug: visualizar-crecimiento-urbano
tags: ["crecimiento urbano","ciudad","geografia urbana"]
header:
  caption: ''
  image: 'valencia_desarrollo.png'
lang: es
summary: "La Dirección General del Catastro de España dispone de información espacial de toda la edificación a excepción del País Vasco y Navarra. Este conjunto de datos forma parte de la implantación de [INSPIRE](https://inspire.ec.europa.eu/), la Infraestructura de Información Espacial en Europa. Más información podemos encontrar [aquí](http://www.catastro.meh.es/webinspire/index.html). Utilizaremos los enlaces (*urls*) en formato *ATOM*, que es un formato de redifusión de tipo RSS, permitiéndonos obtener el enlace de descarga para cada municipio."
---

La Dirección General del Catastro de España dispone de información espacial de toda la edificación a excepción del País Vasco y Navarra. Este conjunto de datos forma parte de la implantación de [INSPIRE](https://inspire.ec.europa.eu/), la Infraestructura de Información Espacial en Europa. Más información podemos encontrar [aquí](http://www.catastro.meh.es/webinspire/index.html). Utilizaremos los enlaces (*urls*) en formato *ATOM*, que es un formato de redifusión de tipo RSS, permitiéndonos obtener el enlace de descarga para cada municipio. 

{{% alert note %}}
Esta entrada de blog es una versión reducida del caso práctico que podéis encontrar en nuestra reciente publicación - [Introducción a los SIG con R](https://dominicroye.github.io/es/publication/manual_rgis_2019/) - publicado por Dominic Royé y Roberto Serrano-Notivoli.
{{% /alert %}}

## Paquetes

```{r echo=FALSE,message=FALSE,error=FALSE,warning=FALSE}
library(knitr)

tb <- data.frame(paquete=c("tidyverse","sf","fs","lubridate","feedeR", "tmap", "classInt", "sysfonts", "showtext"),
                 descripcion=c("Conjunto de paquetes (visualización y manipulación de datos): ggplot2, dplyr, purrr,etc.",
                               "Simple Feature: importar, exportar y manipular datos vectoriales",
                               "Proporciona una interfaz uniforme y multiplataforma para las operaciones del sistema de archivos",
                               "Fácil manipulación de fechas y tiempos",
                               "Importar formatos de redifusión RSS",
                               "Fácil creación de mapas temáticos", 
                               "Para crear intervalos de clase univariantes",
                                "Carga familias tipográficas del sistema y de Google",
                               "Usar familias tipográficas más fácilmente en gráficos R"
                                ))

kable(tb,booktabs = TRUE,col.names=c("Paquete","Descripción"))

```

```{r, message=FALSE,error=FALSE,warning=FALSE}
# instalamos los paquetes necesarios
if(!require("tidyverse")) install.packages("tidyverse")
if(!require("feedeR")) install.packages("feedeR")
if(!require("fs")) install.packages("fs")
if(!require("lubridate")) install.packages("lubridate")
if(!require("fs")) install.packages("fs")
if(!require("tmap")) install.packages("tmap")
if(!require("classInt")) install.packages("classInt")
if(!require("showtext")) install.packages("showtext")
if(!require("sysfonts")) install.packages("sysfonts")
if(!require("rvest")) install.packages("rvest")

# cargamos los paquetes
library(feedeR)
library(sf) 
library(fs)
library(tidyverse)
library(lubridate)
library(classInt)
library(tmap)
library(rvest)
```

## Enlaces de descarga

La primera *url* nos dará acceso a un listado de provincias, sedes territoriales (no siempre coinciden con la provincia), con nuevos enlaces RSS los cuales incluyen los enlaces finales de descarga para cada municipio. En este caso, descargaremos el edificado de Valencia. Los datos del Catastro se actualizan cada seis meses. 

```{r}
url <- "http://www.catastro.minhap.es/INSPIRE/buildings/ES.SDGC.bu.atom.xml"

# importamos los RSS con enlaces de provincias
prov_enlaces <- feed.extract(url)
str(prov_enlaces) #estructura es lista

# extraemos la tabla con los enlaces
prov_enlaces_tab <- as_tibble(prov_enlaces$items) %>% 
                       mutate(title = repair_encoding(title))
prov_enlaces_tab
```

Accedemos y descargamos los datos de Valencia. Para encontrar el enlace final de descarga usamos la función `filter()` del paquete `dplyr` buscando el nombre de la sede territorial y posteriormente el nombre del municipio en mayúsculas con la función `str_detect()` de `stringr`. La función `pull()` nos permite extraer una columna de un `data.frame`. 

{{% alert note %}}
Actualmente la función ``feed.extract()`` no importa correctamente en el *encoding* UTF-8 (Windows). Por eso, en algunas ciudades pueden aparecer una mala codificación de caracteres especiales "CÃ¡diz". Para subsanar este problema aplicamos la función `repair_encoding()` del paquete `rvest`. 
{{% /alert %}}


```{r}
# filtramos la provincia y obtenemos la url RSS
val_atom <- filter(prov_enlaces_tab, str_detect(title, "Valencia")) %>% pull(link)

# importamos la RSS
val_enlaces <- feed.extract(val_atom)

# obtenemos la tabla con los enlaces de descarga
val_enlaces_tab <- val_enlaces$items
val_enlaces_tab <- mutate(val_enlaces_tab, title = repair_encoding(title),
                          link = repair_encoding(link)) 

# filtramos la tabla con el nombre de la ciudad
val_link <- filter(val_enlaces_tab, str_detect(title, "VALENCIA")) %>% pull(link)
val_link
```

## Descarga de datos

La descarga se realiza con la función `download.file()` que únicamente tiene dos argumentos principales, el enlace de descarga y la ruta con el nombre del archivo. En este caso hacemos uso de la función `tempfile()`, que nos es útil para crear archivos temporales, es decir, archivos que únicamente existen en la memoría RAM por un tiempo determinado. 
El archivo que descargamos tiene extensión `*.zip`, por lo que debemos descomprimirlo con otra función (`unzip()`), que requiere el nombre del archivo y el nombre de la carpeta donde lo queremos descomprimir. Por último, la función `URLencode()` codifica una dirección *URL* que contiene caracteres especiales.

```{r}
# creamos un archivo temporal 
temp <- tempfile()

# descargamos los datos
download.file(URLencode(val_link), temp)

# descomprimimos a una carpeta llamda buildings
unzip(temp, exdir = "buildings")

```

## Importar los datos

Para importar los datos utilizamos la función `dir_ls()` del paquete `fs`, que nos permite obtener los archivos y carpetas de una ruta concreta al mismo tiempo que filtramos por un patrón de texto (*regexp*: expresión regular). Aplicamos la función `st_read()` del paquete `sf` al archivo espacial de formato *Geography Markup Language* (GML). 

```{r}
# obtenemos la ruta con el archivo
file_val <- dir_ls("buildings", regexp = "building.gml")

# importamos los datos
buildings_val <- st_read(file_val)
```


## Preparación de los datos

Únicamente convertimos la columna de la edad del edificio (*beginning*) en clase `Date`. La columna de la fecha contiene algunas fechas en formato `--01-01` lo que no corresponde a ninguna fecha reconocible. Por eso, reemplazamos el primer `-` por `0000`. 

```{r}
# 
buildings_val <- mutate(buildings_val, 
               beginning = str_replace(beginning, "^-", "0000") %>% 
                            ymd_hms() %>% as_date()
               )
```

## Gráfico de distribución 

Antes de crear el mapa de la edad del edificado, lo que reflejará el crecimiento urbano, haremos un gráfico de distribución de la fecha de construcción de los edificios. Podremos identificar claramente períodos de expansión urbana. Usaremos el paquete `ggplot2` con la geometría de `geom_density()` para este objetivo. La función `font_add_google()` del paquete `sysfonts` nos permite descargar e incluir familias tipográficas de Google.

```{r fonts, message=FALSE}
#descarga de familia tipográfica
sysfonts::font_add_google("Montserrat", "Montserrat")

#usar showtext para familias tipográficas
showtext::showtext_auto() 
```


```{r, fig.showtext=TRUE}

#limitamos al periodo posterior a 1750
filter(buildings_val, beginning >= "1750-01-01") %>%
 ggplot(aes(beginning)) + 
    geom_density(fill = "#2166ac", alpha = 0.7) +
  scale_x_date(date_breaks = "20 year", 
               date_labels = "%Y") +
  theme_minimal() +
  theme(title = element_text(family = "Montserrat"),
        axis.text = element_text(family = "Montserrat")) +
  labs(y = "",x = "", title = "Evolución del desarrollo urbano")


```


## Buffer de 2,5 km de Valencia

Para poder visualizar bien la distribución del crecimiento, limitamos el mapa a un radio de 2,5 km desde el centro de la ciudad. Usamos la función `geocode_OSM()` del paquete `tmaptools` para obtener las coordenadas de Valencia en clase `sf`. Después proyectamos los puntos al sistema que usamos para el edificado (EPSG:25830). Como último paso creamos con la función `st_buffer()` un *buffer* con 2500 m y la intersección con nuestros datos de los edificios. También es posible crear un buffer en forma de un rectángulo indicando el tipo de estilo con el argumento `endCapStyle = "SQUARE"`.

```{r}
# obtenemos las coordinadas de Valencia
ciudad_point <- tmaptools::geocode_OSM("Valencia", 
                                      as.sf = TRUE)

# proyectamos los datos
ciudad_point <- st_transform(ciudad_point, 25830)

# creamos un buffer
point_bf <- st_buffer(ciudad_point, 2500)


# obtenemos la intersección entre el buffer y la edificación
buildings_val25 <- st_intersection(buildings_val, point_bf)

```

## Preparar los datos para el mapas

Para poder visualizar bien las diferentes épocas de crecimiento, categorizamos el año en 15 grupos empleando cuartiles. 

```{r}
#encontrar 15 clases
br <- classIntervals(year(buildings_val25$beginning), 15, "quantile")

#crear etiquetas
lab <- names(print(br, under = "<", over = ">", cutlabels = FALSE))

#categorizar el año
buildings_val25 <- mutate(buildings_val25, 
               yr_cl = cut(year(beginning), br$brks, labels = lab, include.lowest = TRUE))
```

## Mapa de Valencia

El mapa creamos con el paquete `tmap`. Es una interesante alternativa a `ggplot2`. Se trata de un paquete de funciones especializadas en crear mapas temáticos. La filosofía del paquete sigue a la de `ggplot2`, creando multiples capas con diferentes funciones, que siempre empiezan con `tm_*` y se combinan con `+`. La construcción de un mapa con `tmap` siempre comienza con `tm_shape()`, donde se definen los datos que queremos dibujar. Luego agregamos la geometría correspondiente al tipo de datos (`tm_polygon()`, `tm_border()`, `tm_dots()` o incluso `tm_raster()`). La función `tm_layout()` ayuda a configurar el estilo del mapa.


Cuando necesitamos más colores del máximo permitido por `RColorBrewer` podemos pasar los colores a la función `colorRampPalette()`. Esta función interpola para un mayor número más colores de la gama.

```{r}
#colores
col_spec <- RColorBrewer::brewer.pal(11, "Spectral")

#función de una gama de colores
col_spec_fun <- colorRampPalette(col_spec)


#crear los mapas
tm_shape(buildings_val25) +
  tm_polygons("yr_cl", 
              border.col = "transparent",
              palette = col_spec_fun(15),
              textNA = "Sin dato",
              title = "") +
 tm_layout(bg.color = "black",
           outer.bg.color = "black",
           legend.outside = TRUE,
           legend.text.color = "white",
           legend.text.fontfamily = "Montserrat", 
            panel.label.fontfamily = "Montserrat",
            panel.label.color = "white",
            panel.label.bg.color = "black",
            panel.label.size = 5,
            panel.label.fontface = "bold")

```


## Mapa dinámico en leaflet

Una ventaja muy interesante es la función `tmap_leaflet()` del paquete `tmap` para pasar de forma sencilla un mapa creado en el mismo marco a `leaflet`. 

```{r, eval = FALSE}
#mapa tmap de Santiago
m <-   tm_shape(buildings_val25) +
          tm_polygons("yr_cl", 
              border.col = "transparent",
              palette = col_spec_fun(15),
              textNA = "Without data",
              title = "")


#mapa dinámico
tmap_leaflet(m)

```


```{r, echo=FALSE}
include_url("/files/urban_growth_leaflet.html", height = "500px")

```
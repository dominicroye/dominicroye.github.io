<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R on Dominic Royé</title>
    <link>/es/categories/r/</link>
    <description>Recent content in R on Dominic Royé</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2018-2020 Dominic Royé. All rights reserved.</copyright>
    <lastBuildDate>Sun, 11 Oct 2020 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="/es/categories/r/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Animación climática de la temperatura máxima</title>
      <link>/es/2020/animaci%C3%B3n-clim%C3%A1tica-de-la-temperatura-m%C3%A1xima/</link>
      <pubDate>Sun, 11 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/2020/animaci%C3%B3n-clim%C3%A1tica-de-la-temperatura-m%C3%A1xima/</guid>
      <description>


&lt;p&gt;En el campo de la visualización de datos, la animación de datos espaciales en su dimensión temporal lleva a mostrar cambios y patrones fascinantes y muy visuales. A raíz de una de las últimas publicaciones que he realizado en los RRSS me pidieron que hiciera un post acerca de cómo lo creé. Pues bien, aquí vamos para empezar con datos de la España peninsular. Podéis encontrar más animaciones en la sección de &lt;a href=&#34;https://dominicroye.github.io/es/graphs/climate/&#34;&gt;gráficos&lt;/a&gt; de este mismo blog.&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;I couldn&amp;#39;t resist to make another animation. Smoothed daily maximum temperature throughout the year in Europe. &lt;a href=&#34;https://twitter.com/hashtag/rstats?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#rstats&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/ggplot2?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#ggplot2&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/dataviz?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#dataviz&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/climate?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#climate&lt;/a&gt; &lt;a href=&#34;https://t.co/ZC9L0vh3vR&#34;&gt;pic.twitter.com/ZC9L0vh3vR&lt;/a&gt;&lt;/p&gt;&amp;mdash; Dominic Royé (@dr_xeo) &lt;a href=&#34;https://twitter.com/dr_xeo/status/1259059168817930240?ref_src=twsrc%5Etfw&#34;&gt;May 9, 2020&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;paquetes&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Paquetes&lt;/h2&gt;
&lt;p&gt;En este post usaremos los siguientes paquetes:&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;13%&#34; /&gt;
&lt;col width=&#34;86%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Paquete&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tidyverse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Conjunto de paquetes (visualización y manipulación de datos): ggplot2, dplyr, purrr,etc.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;rnaturalearth&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Mapas vectoriales del mundo ‘Natural Earth’&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;lubridate&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fácil manipulación de fechas y tiempos&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Simple Feature: importar, exportar y manipular datos vectoriales&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;raster&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Importar, exportar y manipular raster&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ggthemes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Estilos para ggplot2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;gifski&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Crear gifs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;showtext&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Usar fuentes más fácilmente en gráficos R&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sysfonts&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Cargar fuentes del sistema y fuentes de Google&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# instalamos los paquetes si hace falta
if(!require(&amp;quot;tidyverse&amp;quot;)) install.packages(&amp;quot;tidyverse&amp;quot;)
if(!require(&amp;quot;rnaturalearth&amp;quot;)) install.packages(&amp;quot;rnaturalearth&amp;quot;)
if(!require(&amp;quot;lubridate&amp;quot;)) install.packages(&amp;quot;lubridate&amp;quot;)
if(!require(&amp;quot;sf&amp;quot;)) install.packages(&amp;quot;sf&amp;quot;)
if(!require(&amp;quot;ggthemes&amp;quot;)) install.packages(&amp;quot;ggthemes&amp;quot;)
if(!require(&amp;quot;gifski&amp;quot;)) install.packages(&amp;quot;gifski&amp;quot;)
if(!require(&amp;quot;raster&amp;quot;)) install.packages(&amp;quot;raster&amp;quot;)
if(!require(&amp;quot;sysfonts&amp;quot;)) install.packages(&amp;quot;sysfonts&amp;quot;)
if(!require(&amp;quot;showtext&amp;quot;)) install.packages(&amp;quot;showtext&amp;quot;)

# paquetes
library(raster)
library(tidyverse)
library(lubridate)
library(ggthemes)
library(sf)
library(rnaturalearth)
library(extrafont)
library(showtext)
library(RColorBrewer)
library(gifski)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para aquellos con menos experiencia con &lt;code&gt;tidyverse&lt;/code&gt;, recomiendo la breve introducción en este blog &lt;a href=&#34;https://dominicroye.github.io/es/2020/una-muy-breve-introducci%C3%B3n-a-tidyverse/&#34;&gt;post&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;preparación&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Preparación&lt;/h1&gt;
&lt;div id=&#34;datos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Datos&lt;/h2&gt;
&lt;p&gt;Descargamos los datos STEAD de la temperatura máxima (&lt;em&gt;tmax_pen.nc&lt;/em&gt;) en formato &lt;em&gt;netCDF&lt;/em&gt; desde el repositario del CSIC &lt;a href=&#34;https://digital.csic.es/handle/10261/177655&#34;&gt;aquí&lt;/a&gt; (el tamaño de los datos es de 2 GB). Se trata de un conjunto de datos con una resolución espacial de 5 km y comprenden las temperaturas máximas diarias desde 1901 a 2014. En la climatología y la meteorología, un formato de uso muy extendido es el de las bases de datos &lt;em&gt;netCDF&lt;/em&gt;, que permiten obtener una estructura multidimensional e intercambiar los datos de forma independiente al sistema operativo empleado. Se trata de un formato espacio-temporal con una cuadrícula regular o irregular. La estructura multidimensional en forma de matriz (&lt;em&gt;array&lt;/em&gt;) permite usar no sólo datos espacio-temporales sino también multivariables. En nuestros datos tendremos un cubo de tres dimensiones: longitud, latitud y tiempo de la temperatura máxima.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/3d_ncdf.es.png&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Royé 2015. Sémata: Ciencias Sociais e Humanidades 27:11-37&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;importar-los-datos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Importar los datos&lt;/h2&gt;
&lt;p&gt;El formato &lt;em&gt;netCDF&lt;/em&gt; con extensión &lt;em&gt;.nc&lt;/em&gt; lo podemos importar vía dos paquetes principales: 1) &lt;code&gt;ncdf4&lt;/code&gt; y 2) &lt;code&gt;raster&lt;/code&gt;. Aunque el paquete &lt;code&gt;raster&lt;/code&gt; realmente lo que hace es usar el primer paquete para importar los datos. En este post usaremos el paquete &lt;code&gt;raster&lt;/code&gt; dado que es algo más fácil, con algunas funciones muy útiles y más universales para todo tipo de formato &lt;em&gt;raster&lt;/em&gt;. Las funciones principales de importación son: &lt;code&gt;raster()&lt;/code&gt;, &lt;code&gt;stack()&lt;/code&gt; y &lt;code&gt;brick()&lt;/code&gt;. La primera función sólo permite importar una única capa, en cambio, las últimas dos funciones se emplean para datos multidimensionales. En nuestro caso sólo tenemos una variable, por tanto no sería necesario hacer uso del argumento &lt;code&gt;varname&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# importamos los datos ncdf
tmx &amp;lt;- brick(&amp;quot;tmax_pen.nc&amp;quot;, varname = &amp;quot;tx&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required namespace: ncdf4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tmx # metadatos&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class      : RasterBrick 
## dimensions : 190, 230, 43700, 41638  (nrow, ncol, ncell, nlayers)
## resolution : 0.0585, 0.045  (x, y)
## extent     : -9.701833, 3.753167, 35.64247, 44.19247  (xmin, xmax, ymin, ymax)
## crs        : +proj=longlat +datum=WGS84 +no_defs 
## source     : C:/Users/xeo19/Documents/GitHub/blogR_update/content/post/es/2020-10-11-animacion-climatica-temperatura-maxima/tmax_pen.nc 
## names      : X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14, X15, ... 
## Time (days since 1901-01-01): 1, 41638 (min, max)
## varname    : tx&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En la estructura del objeto &lt;code&gt;RasterBrick&lt;/code&gt; vemos todos los metadatos necesarios: desde la resolución, las dimensiones o el tipo de proyección, hasta el nombre de la variable. Además nos indica que únicamente apunta a los datos (&lt;em&gt;source&lt;/em&gt;) y no los ha importado a la memoria RAM lo que facilita el trabajo con grandes conjuntos de datos.&lt;/p&gt;
&lt;p&gt;Para acceder a cualquier capa hacemos uso de &lt;code&gt;[[ ]]&lt;/code&gt; con el índice correspondiente. Así podemos plotear fácilmente cualquier día de los 41.638 días de los que disponemos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# mapear cualquier día
plot(tmx[[200]], col = rev(heat.colors(7)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/es/2020-10-11-animacion-climatica-temperatura-maxima/index.es_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;calcular-el-promedio-de-la-temperatura&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Calcular el promedio de la temperatura&lt;/h2&gt;
&lt;p&gt;En este paso el objetivo es calcular el promedio de la temperatura para cada día del año. Por eso, lo primero que hacemos es crear un vector, indicando el día del año para toda la serie temporal. En el paquete &lt;code&gt;raster&lt;/code&gt; disponemos de la función &lt;code&gt;stackApply()&lt;/code&gt; que permite aplicar una función sobre grupos de capas, o mejor dicho, índices. Dado que nuestro conjunto de datos es grande, incluimos esta función en las funciones de paralelización.&lt;/p&gt;
&lt;p&gt;Empezamos con las funciones &lt;code&gt;beginClusterr()&lt;/code&gt; y &lt;code&gt;endCluster()&lt;/code&gt; que inician y finalizan la paralelización. En la primera debemos indicar el número de núcleos que queremos usar. En este caso uso 4 de 7 posibles núcleos, no obstante, se debe cambiar el número según las características de cada CPU, siendo la norma n-1. Entonces, la función &lt;code&gt;clusterR&lt;/code&gt; permite ejecutar funciones en paralelo con múltiples núcleos. El primer argumento corresponde al objeto raster, el segundo a la función empleada, y en forma de lista pasamos los argumentos de la función &lt;code&gt;stackApply()&lt;/code&gt;, los índices que crean los grupos y la función usada para cada uno de los grupos. Si añadimos el argumento &lt;code&gt;progress = &#39;text&#39;&lt;/code&gt; se muestra una barra de progreso del cálculo.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;Para el conjunto de datos de EEUU hice un preprocesamiento, el cálculo del promedio en la nube a través de &lt;a href=&#34;https://earthengine.google.com/&#34;&gt;Google Earth Engine&lt;/a&gt; lo que hace todo el proceso más rápido. En el caso de Australia, el preprocesamiento fue más complejo ya que el conjunto de datos esta en archivos netCDF para cada año.&lt;/p&gt;

&lt;/div&gt;

&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# convertimos las fechas entre 1901 y 2014 a días del año
time_days &amp;lt;- yday(seq(as_date(&amp;quot;1901-01-01&amp;quot;), as_date(&amp;quot;2014-12-31&amp;quot;), &amp;quot;day&amp;quot;))

# calculamos el promedio 
beginCluster(4)
tmx_mean &amp;lt;- clusterR(tmx, stackApply, args = list(indices = time_days, fun = mean))
endCluster()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;suavizar-la-variabilidad-de-las-temperaturas&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Suavizar la variabilidad de las temperaturas&lt;/h2&gt;
&lt;p&gt;Antes de pasar a suavizar las series temporales de nuestro &lt;em&gt;RasterBrick&lt;/em&gt;, un ejemplo del por qué lo hacemos. Extraemos un píxel de nuestro conjunto de datos en las coordenadas -1º de longitud y 40º de latitud usando la función &lt;code&gt;extract()&lt;/code&gt;. Dado que la función con el mismo nombre aparece en varios paquetes, debemos cambiar a la forma &lt;code&gt;nombre_paquete::nombre_función&lt;/code&gt;. El resultado es una matriz con una fila correspondiente al píxel y 366 columnas de los días del año. El siguiente paso es la creación de un &lt;em&gt;data.frame&lt;/em&gt; con una fecha &lt;em&gt;dummy&lt;/em&gt; y la temperatura máxima extraída.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# extraemos un píxel
point_ts &amp;lt;- raster::extract(tmx_mean, matrix(c(-1, 40), nrow = 1))
dim(point_ts) # dimensiones &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]   1 366&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# creamos un data.frame
df &amp;lt;- data.frame(date = seq(as_date(&amp;quot;2000-01-01&amp;quot;), as_date(&amp;quot;2000-12-31&amp;quot;), &amp;quot;day&amp;quot;),
                 tmx = point_ts[1,])

# visualizamos la temperatura máxima 
ggplot(df, 
       aes(date, tmx)) + 
     geom_line() + 
  scale_x_date(date_breaks = &amp;quot;month&amp;quot;, date_labels = &amp;quot;%b&amp;quot;) +
  scale_y_continuous(breaks = seq(5, 28, 2)) +
  labs(y = &amp;quot;Temperatura máxima&amp;quot;, x = &amp;quot;&amp;quot;, colour =  &amp;quot;&amp;quot;) +
  theme_minimal()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/es/2020-10-11-animacion-climatica-temperatura-maxima/index.es_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;El gráfico muestra claramente la todavía existente variabilidad, lo que haría fluctuar bastante una animación. Por eso, creamos una función de suavizado basado en un ajuste de regresión polinomial local (LOESS), más detalles los encontráis en la ayuda de la función &lt;code&gt;loess()&lt;/code&gt;. El argumento más importante es &lt;code&gt;span&lt;/code&gt; que determina el grado de suavizado de la función, cuanto más pequeño el valor menos suave será la curva. El mejor resultado me ha dado un valor del 0,5.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;daily_smooth &amp;lt;- function(x, span = 0.5){
  
  if(all(is.na(x))){
   
    return(x) 
   
  } else {
    
  df &amp;lt;- data.frame(yd = 1:366, ta = x)
  m &amp;lt;- loess(ta ~ yd, span = span, data = df)
  est &amp;lt;- predict(m, 1:366)

  return(est)
  
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Aplicamos nuestra nueva función de suavizado a la serie temporal extraída y hacemos algunos cambios para poder visualizar la diferencia entre los datos originales y suavizados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# suavizamos la temperatura
df &amp;lt;- mutate(df, tmx_smoothed = daily_smooth(tmx)) %&amp;gt;% 
          pivot_longer(2:3, names_to = &amp;quot;var&amp;quot;, values_to = &amp;quot;temp&amp;quot;)

# visualizamos la diferencia 
ggplot(df, 
       aes(date, temp, 
           colour = var)) + 
     geom_line() + 
  scale_x_date(date_breaks = &amp;quot;month&amp;quot;, date_labels = &amp;quot;%b&amp;quot;) +
  scale_y_continuous(breaks = seq(5, 28, 2)) +
  scale_colour_manual(values = c(&amp;quot;#f4a582&amp;quot;, &amp;quot;#b2182b&amp;quot;)) +
  labs(y = &amp;quot;Temperatura máxima&amp;quot;, x = &amp;quot;&amp;quot;, colour =  &amp;quot;&amp;quot;) +
  theme_minimal()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/es/2020-10-11-animacion-climatica-temperatura-maxima/index.es_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Como vemos en el gráfico la curva suavizada sigue muy bien la curva original. En el siguiente paso empleamos nuestra función sobre el &lt;em&gt;RasterBrick&lt;/em&gt; usando la función &lt;code&gt;calc()&lt;/code&gt;. La función devuelve tantas capas como las que devuelve la función empleada a cada de las series temporales.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# suavizar el RasterBrick
tmx_smooth &amp;lt;- calc(tmx_mean, fun = daily_smooth)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;visualización&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Visualización&lt;/h1&gt;
&lt;div id=&#34;preparación-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Preparación&lt;/h2&gt;
&lt;p&gt;Para visualizar las temperaturas máximas durante todo el año, primero, convertimos el &lt;em&gt;RasterBrick&lt;/em&gt; a un &lt;em&gt;data.frame&lt;/em&gt;, incluyendo longitud y latitud, pero eliminando todas las series temporales sin valores (&lt;code&gt;NA&lt;/code&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# convertir a data.frame
tmx_mat &amp;lt;- as.data.frame(tmx_smooth, xy = TRUE, na.rm = TRUE)

# renombrar las columnas
tmx_mat &amp;lt;- set_names(tmx_mat, c(&amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;, str_c(&amp;quot;D&amp;quot;, 1:366)))
str(tmx_mat[, 1:10])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    20676 obs. of  10 variables:
##  $ lon: num  -8.03 -7.98 -7.92 -7.86 -7.8 ...
##  $ lat: num  43.8 43.8 43.8 43.8 43.8 ...
##  $ D1 : num  10.5 10.3 10 10.9 11.5 ...
##  $ D2 : num  10.5 10.3 10.1 10.9 11.5 ...
##  $ D3 : num  10.5 10.3 10.1 10.9 11.5 ...
##  $ D4 : num  10.6 10.4 10.1 10.9 11.5 ...
##  $ D5 : num  10.6 10.4 10.1 11 11.6 ...
##  $ D6 : num  10.6 10.4 10.1 11 11.6 ...
##  $ D7 : num  10.6 10.4 10.2 11 11.6 ...
##  $ D8 : num  10.6 10.4 10.2 11 11.6 ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Segundo, importamos los límites administrativos con la función &lt;code&gt;ne_countries()&lt;/code&gt; del paquete &lt;code&gt;rnaturalearth&lt;/code&gt; limitando la extensión a la región de la Península Ibérica, el sur de Francia y el norte de África.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# importamos los límites globales
map &amp;lt;- ne_countries(scale = 10, returnclass = &amp;quot;sf&amp;quot;) %&amp;gt;% st_cast(&amp;quot;MULTILINESTRING&amp;quot;)

# limitamos la extensión
map &amp;lt;- st_crop(map, xmin = -10, xmax = 5, ymin = 35, ymax = 44) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## although coordinates are longitude/latitude, st_intersection assumes that they are planar&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: attribute variables are assumed to be spatially constant throughout all
## geometries&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# mapa de los límites
plot(map)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: plotting the first 9 out of 94 attributes; use max.plot = 94 to plot
## all&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/es/2020-10-11-animacion-climatica-temperatura-maxima/index.es_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Tercero, creamos un vector con etiquetas del día del año para incluirlas en la animación. Además, definimos los cortes de la temperatura máxima, adaptados a la distribución de nuestros datos, para obtener una categorización con un total de 20 clases.&lt;/p&gt;
&lt;p&gt;Cuarto, aplicamos la función &lt;code&gt;cut()&lt;/code&gt; con los cortes a todas las columnas con las temperaturas de cada día del año.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# etiquetas de los días del año
lab &amp;lt;- as_date(0:365, &amp;quot;2000-01-01&amp;quot;) %&amp;gt;% format(&amp;quot;%d %B&amp;quot;)

# cortes para la temperatura
ct &amp;lt;- c(-5, 0, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 40, 45)

# datos categorizados con los cortes fijados
tmx_mat_cat &amp;lt;- mutate_at(tmx_mat, 3:368, cut, breaks = ct)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Quinto, descargamos la fuente Montserrat y definimos los colores correspondientes a las clases creadas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# descarga de la fuente
font_add_google(&amp;quot;Montserrat&amp;quot;, &amp;quot;Montserrat&amp;quot;)

# uso de showtext con DPI 300
showtext_opts(dpi = 300)
showtext_auto()

# definimos una rampa de colores
col_spec &amp;lt;- colorRampPalette(rev(brewer.pal(11, &amp;quot;Spectral&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;mapa-estático&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Mapa estático&lt;/h2&gt;
&lt;p&gt;En esta primera visualización hacemos un mapa del 29 de mayo (día 150). No voy a explicar todos los detalles de la construcción con &lt;code&gt;ggplot2&lt;/code&gt;, no obstante, es importante destacar que hago uso de la función &lt;code&gt;aes_string()&lt;/code&gt; en lugar de &lt;code&gt;aes()&lt;/code&gt; para poder usar los nombres de las columnas en formato de carácter. Con la función &lt;code&gt;geom_raster()&lt;/code&gt; añadimos los datos en rejilla de temperatura como primera capa del gráfico y con &lt;code&gt;geom_sf()&lt;/code&gt; los límites de clase &lt;code&gt;sf&lt;/code&gt;. Por último, la función &lt;code&gt;guide_colorsteps()&lt;/code&gt; permite crear una bonita leyenda basada en las clases creadas por la función &lt;code&gt;cut()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(tmx_mat_cat) + 
         geom_raster(aes_string(&amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;, fill = &amp;quot;D150&amp;quot;)) +
         geom_sf(data = map,
                 colour = &amp;quot;grey50&amp;quot;, size = 0.2) +
  coord_sf(expand = FALSE) +
  scale_fill_manual(values = col_spec(20), drop = FALSE) +
  guides(fill = guide_colorsteps(barwidth = 30, 
                                 barheight = 0.5,
                                 title.position = &amp;quot;right&amp;quot;,
                                 title.vjust = .1)) +
   theme_void() +
   theme(legend.position = &amp;quot;top&amp;quot;,
      legend.justification = 1,
      plot.caption = element_text(family = &amp;quot;Montserrat&amp;quot;, 
                                  margin = margin(b = 5, t = 10, unit = &amp;quot;pt&amp;quot;)),                
      plot.title = element_text(family = &amp;quot;Montserrat&amp;quot;, 
                                size = 16, face = &amp;quot;bold&amp;quot;, 
                                margin = margin(b = 2, t = 5, unit = &amp;quot;pt&amp;quot;)),
     legend.text = element_text(family = &amp;quot;Montserrat&amp;quot;),
     plot.subtitle = element_text(family = &amp;quot;Montserrat&amp;quot;, 
                                  size = 13, 
                                  margin = margin(b = 10, t = 5, unit = &amp;quot;pt&amp;quot;))) +
   labs(title = &amp;quot;Promedio de la temperatura máxima durante el año en España&amp;quot;, 
     subtitle = lab[150], 
     caption = &amp;quot;Período de referencia 1901-2014. Datos: STEAD&amp;quot;,
     fill = &amp;quot;ºC&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/img/fig_1.es.png&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;animación-de-todo-el-año&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Animación de todo el año&lt;/h2&gt;
&lt;p&gt;La animación final consiste en crear un gif a partir de todas las imágenes de los 366 días, en principio, se podría usar el paquete &lt;code&gt;gganimate&lt;/code&gt;, pero en mi experiencia es más lento, dado que requiere un &lt;code&gt;data.frame&lt;/code&gt; en formato largo. En este ejemplo una tabla larga tendría más de siete millones de filas, por eso, lo que hacemos es usar un bucle sobre las columnas y unir todas las imágenes creadas con el paquete &lt;code&gt;gifski&lt;/code&gt; que también usa &lt;code&gt;gganimate&lt;/code&gt; para la reproducción en formato gif.&lt;/p&gt;
&lt;p&gt;Antes del bucle creamos un vector con los pasos temporales o nombres de las columnas y otro vector con el nombre de las imágenes, incluida el nombre de la carpeta. Con el objetivo de obtener una lista de imágenes ordenadas por su número debemos mantener tres cifras rellenando las posiciones a la izquierda con ceros.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;time_step &amp;lt;- str_c(&amp;quot;D&amp;quot;, 1:366)

files &amp;lt;- str_c(&amp;quot;./ta_anima/D&amp;quot;, str_pad(1:366, 3, &amp;quot;left&amp;quot;, &amp;quot;0&amp;quot;), &amp;quot;.png&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Por último, incluimos la construcción anterior del gráfico en un bucle &lt;em&gt;for&lt;/em&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;for(i in 1:366){

 ggplot(tmx_mat_cat) + 
         geom_raster(aes_string(&amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;, fill = time_step[i])) +
         geom_sf(data = map,
                 colour = &amp;quot;grey50&amp;quot;, size = 0.2) +
  coord_sf(expand = FALSE) +
  scale_fill_manual(values = col_spec(20), drop = FALSE) +
  guides(fill = guide_colorsteps(barwidth = 30, 
                                 barheight = 0.5,
                                 title.position = &amp;quot;right&amp;quot;,
                                 title.vjust = .1)) +
   theme_void() +
   theme(legend.position = &amp;quot;top&amp;quot;,
      legend.justification = 1,
      plot.caption = element_text(family = &amp;quot;Montserrat&amp;quot;, 
                                  margin = margin(b = 5, t = 10, unit = &amp;quot;pt&amp;quot;)),                
      plot.title = element_text(family = &amp;quot;Montserrat&amp;quot;, 
                                size = 16, face = &amp;quot;bold&amp;quot;, 
                                margin = margin(b = 2, t = 5, unit = &amp;quot;pt&amp;quot;)),
     legend.text = element_text(family = &amp;quot;Montserrat&amp;quot;),
     plot.subtitle = element_text(family = &amp;quot;Montserrat&amp;quot;, 
                                  size = 13, 
                                  margin = margin(b = 10, t = 5, unit = &amp;quot;pt&amp;quot;))) +
   labs(title = &amp;quot;Promedio de la temperatura máxima durante el año en España&amp;quot;, 
     subtitle = lab[i], 
     caption = &amp;quot;Período de referencia 1901-2014. Datos: STEAD&amp;quot;,
     fill = &amp;quot;ºC&amp;quot;)
  
  ggsave(files[i], width = 8.28, height = 7.33, type = &amp;quot;cairo&amp;quot;)
  
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Después de haber creado imágenes para cada día del año, únicamente nos queda por crear el gif.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gifski(files, &amp;quot;tmx_spain.gif&amp;quot;, width = 800, height = 700, loop = FALSE, delay = 0.05)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/img/tmx_spain.es.gif&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
      
            <category>animación</category>
      
            <category>temperatura</category>
      
            <category>clima</category>
      
            <category>SIG</category>
      
      
            <category>visualización</category>
      
            <category>R</category>
      
            <category>R:avanzado</category>
      
    </item>
    
    <item>
      <title>Direcciones del flujo fluvial</title>
      <link>/es/2020/direcciones-del-flujo-fluvial/</link>
      <pubDate>Fri, 24 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/2020/direcciones-del-flujo-fluvial/</guid>
      <description>


&lt;p&gt;Recientemente creé una visualización de la distribución de las direcciones del flujo fluvial y también de las orientaciones costeras. A raíz de su publicación en los RRSS (&lt;a href=&#34;https://twitter.com/dr_xeo/status/1277978724034465798?s=2&#34;&gt;aquí&lt;/a&gt;) me pidieron que hiciera un post acerca de cómo lo hice. Pues bien, aquí vamos para empezar con un ejemplo de los ríos, la orientación costera es algo más compleja. Lo mismo hice para una selección de ríos europeos aquí en este &lt;a href=&#34;https://twitter.com/dr_xeo/status/1277243216828473345?s=20&#34;&gt;tweet&lt;/a&gt;. No obstante, originalmente empecé con la orientación de las costas europeas.&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Have you ever wondered where the European &lt;a href=&#34;https://twitter.com/hashtag/coasts?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#coasts&lt;/a&gt; are oriented? &lt;a href=&#34;https://twitter.com/hashtag/rstats?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#rstats&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/ggplot2?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#ggplot2&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/geography?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#geography&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/dataviz?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#dataviz&lt;/a&gt; &lt;a href=&#34;https://t.co/tpWVxSoHlw&#34;&gt;pic.twitter.com/tpWVxSoHlw&lt;/a&gt;&lt;/p&gt;&amp;mdash; Dominic Royé (@dr_xeo) &lt;a href=&#34;https://twitter.com/dr_xeo/status/1265286552525180929?ref_src=twsrc%5Etfw&#34;&gt;May 26, 2020&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;paquetes&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Paquetes&lt;/h2&gt;
&lt;p&gt;En este post usaremos los siguientes paquetes:&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;10%&#34; /&gt;
&lt;col width=&#34;89%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Paquete&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tidyverse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Conjunto de paquetes (visualización y manipulación de datos): ggplot2, dplyr, purrr,etc.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;remotes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Instalación desde repositorios remotos&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;RQGIS3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Interfaz entre R y QGIS3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Simple Feature: importar, exportar y manipular datos vectoriales&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ggtext&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Soporte para la representación de texto mejorado con ggplot2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sysfonts&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Cargar fuentes en R&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;showtext&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Usar fuentes más fácilmente en gráficos R&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;circular&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Funciones para trabajar con datos circulares&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;geosphere&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Trigonometría esférica para aplicaciones geográficas&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;En el caso del paquete &lt;code&gt;RQGIS3&lt;/code&gt; es necesario instalar QGIS en OSGeo4W &lt;a href=&#34;https://www.qgis.org/es/site/forusers/download.html&#34;&gt;aquí&lt;/a&gt;. Más adelante explicaré la razón del uso de QGIS.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# instalamos los paquetes si hace falta
if(!require(&amp;quot;tidyverse&amp;quot;)) install.packages(&amp;quot;tidyverse&amp;quot;)
if(!require(&amp;quot;remotes&amp;quot;)) install.packages(&amp;quot;remotes&amp;quot;)
if(!require(&amp;quot;RQGIS3&amp;quot;)) remotes::install_github(&amp;quot;jannes-m/RQGIS3&amp;quot;)
if(!require(&amp;quot;sf&amp;quot;)) install.packages(&amp;quot;sf&amp;quot;)
if(!require(&amp;quot;ggtext&amp;quot;)) install.packages(&amp;quot;ggtext&amp;quot;)
if(!require(&amp;quot;circular&amp;quot;)) install.packages(&amp;quot;circular&amp;quot;)
if(!require(&amp;quot;geosphere&amp;quot;)) install.packages(&amp;quot;geosphere&amp;quot;)
if(!require(&amp;quot;sysfonts&amp;quot;)) install.packages(&amp;quot;sysfonts&amp;quot;)
if(!require(&amp;quot;showtext&amp;quot;)) install.packages(&amp;quot;showtext&amp;quot;)

# paquetes
library(sf)
library(tidyverse)
library(ggtext)
library(circular)
library(geosphere)
library(RQGIS3)
library(showtext)
library(sysfonts)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;consideraciones-iniciales&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Consideraciones iniciales&lt;/h1&gt;
&lt;p&gt;Los ángulos en líneas vectoriales se basan en el ángulo entre dos vértices, y el número de vértices depende de la complejidad, y en consecuencia de la resolución, de los datos vectoriales. Por tanto, puede haber diferencias en usar distintas resoluciones de una línea vectorial, sea de la costa o del río como en este ejemplo. Una línea recta simplemente se construye con dos puntos de longitud y latitud.&lt;/p&gt;
&lt;p&gt;Relacionado con ello está la fractalidad, una estructura aparentemente irregular pero que se repite a diferentes escalas, de la línea de costa o también del río. La característica más paradójica es que la longitud de una línea costera depende de la escala de medida, cuanto menor es el incremento de medida, la longitud medida se incrementa.&lt;/p&gt;
&lt;p&gt;Existen dos posibiliades de obtener los ángulos de los vértices. En la primera calculamos el ángulo entre todos los vértices consecutivos.&lt;/p&gt;
&lt;p&gt;Por ejemplo, imaginémonos dos puntos, Madrid (-3.71, 40.43) y Barcelona (2.14, 41.4).&lt;/p&gt;
&lt;p&gt;¿Cuál es el ángulo de su línea recta?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bearingRhumb(c(-3.71, 40.43), c(2.14, 41.4))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 77.62391&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vemos que es el de 77º, o sea, dirección noreste. Pero, ¿y si voy de Barcelona a Madrid?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bearingRhumb(c(2.14, 41.4), c(-3.71, 40.43))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 257.6239&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El angúlo es diferente porque nos &lt;em&gt;movemos&lt;/em&gt; desde el noreste al suroeste. Podemos invertir fácilmente el ángulo para obtener el &lt;em&gt;movimiento&lt;/em&gt; contrario.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# ángulo contrario de Barcelona -&amp;gt; Madrid
bearingRhumb(c(2.14, 41.4), c(-3.71, 40.43)) - 180&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 77.62391&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# ángulo contrario de Madrid -&amp;gt; Barcelona
bearingRhumb(c(-3.71, 40.43), c(2.14, 41.4)) + 180&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 257.6239&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La dirección en la que calculamos los ángulos es importante. En el caso de los ríos se espera que sea la dirección de flujo de origen a la desembocadura, ahora bien, un problema puede ser que los vértices, que construyen las líneas, no estén ordenados geográficamente en la tabla de atributos. Otro problema puede ser que los vértices empiecen en la desembocadura lo que daría al angúlo inverso como lo hemos visto antes.&lt;/p&gt;
&lt;p&gt;Sin embargo, hay una forma más fácil. Podemos aprovechar los atributos de los sistemas de coordenadas proyectados (proyección Robinson, etc) que incluyen el ángulo entre los vértices. Este último enfoque lo vamos usar en este post. Aún así, debemos prestar mucha atención a los resultados según lo dicho anteriormente.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;preparación&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Preparación&lt;/h1&gt;
&lt;div id=&#34;datos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Datos&lt;/h2&gt;
&lt;p&gt;Descargamos las líneas centrales de los ríos más grandes del mundo (&lt;a href=&#34;/files/RiverHRCenterlinesCombo.zip&#34;&gt;descarga&lt;/a&gt;), accesible también en &lt;a href=&#34;https://www.sciencebase.gov/catalog/item/5a145fdde4b09fc93dcfd36c&#34;&gt;Zeenatul Basher et al. 2018&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;importar-y-proyectar&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Importar y proyectar&lt;/h2&gt;
&lt;p&gt;Lo primero que hacemos es importar, proyectar y eliminar la tercera dimensión &lt;em&gt;Z&lt;/em&gt;, usando el encadenamiento de las siguientes functions: &lt;code&gt;st_read()&lt;/code&gt; nos ayuda a importar cualquier formato vectorial, &lt;code&gt;st_zm()&lt;/code&gt; elimina la dimensión Z o M de una geometría vectorial y &lt;code&gt;st_transform()&lt;/code&gt; proyecta los datos vectoriales a la nueva proyección en formato &lt;em&gt;proj4&lt;/em&gt;. La combinación de las funciones la realizamos con el famoso &lt;em&gt;pipe&lt;/em&gt; (&lt;code&gt;%&amp;gt;%&lt;/code&gt;) que facilita la aplicación de una secuencia de funciones sobre un conjunto de datos, más detalles en este &lt;a href=&#34;https://dominicroye.github.io/es/2020/una-muy-breve-introducci%C3%B3n-a-tidyverse/&#34;&gt;post&lt;/a&gt;. Todas las funciones del paquete &lt;code&gt;sf&lt;/code&gt; comienzan por &lt;code&gt;st_*&lt;/code&gt; haciendo referencia al carácter espacial de su aplicación, similar a &lt;em&gt;PostGIS.&lt;/em&gt; Igualmente, y al mismo estilo que &lt;em&gt;PostGIS&lt;/em&gt;, se usan verbos como nombres de función.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;proj_rob &amp;lt;- &amp;quot;+proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m no_defs&amp;quot;

river_line &amp;lt;- st_read(&amp;quot;RiverHRCenterlinesCombo.shp&amp;quot;) %&amp;gt;% 
                 st_zm() %&amp;gt;% 
                    st_transform(proj_rob)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Reading layer `RiverHRCenterlinesCombo&amp;#39; from data source `C:\Users\xeo19\Documents\GitHub\blogR_update\content\post\es\2020-07-24-direcciones-del-flujo-fluvial\RiverHRCenterlinesCombo.shp&amp;#39; using driver `ESRI Shapefile&amp;#39;
## Simple feature collection with 78 features and 6 fields
## geometry type:  MULTILINESTRING
## dimension:      XYZ
## bbox:           xmin: -164.7059 ymin: -36.97094 xmax: 151.5931 ymax: 72.64474
## z_range:        zmin: 0 zmax: 0
## geographic CRS: WGS 84&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;extraer-los-ángulos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Extraer los ángulos&lt;/h2&gt;
&lt;p&gt;En el siguiente paso debemos extraer los ángulos de los vértices. Desgraciadamente, hasta donde sepa, no es posible extraer los atributos con alguna función del paquete &lt;code&gt;sf&lt;/code&gt;. Aunque la función &lt;code&gt;st_coordinates()&lt;/code&gt; nos devuelve las coordenadas, no incluye otros atributos. Por eso, debemos usar otra forma, y es que el open software Quantum GIS extrae todos los atributos de los vértices. Podríamos importar los datos vectoriales en QGIS Desktop y exportar los vértices desde allí, pero también es posible acceder a las funciones de QGIS desde R directamente.&lt;/p&gt;
&lt;p&gt;Para ello, tenemos que tener instalado QGIS en OSGeo4W. El paquete &lt;code&gt;RQGIS3&lt;/code&gt; nos permite de forma muy fácil usar las funciones del programa en R. Primero empleamos la función &lt;code&gt;set_env()&lt;/code&gt; para definir todas las rutas necesarias de QGIS e inciamos la API con &lt;code&gt;open_app()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# rutas a QGIS
set_env()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Trying to find QGIS in C:/OSGEO4~1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $root
## [1] &amp;quot;C:/OSGeo4W64&amp;quot;
## 
## $qgis_prefix_path
## [1] &amp;quot;C:/OSGeo4W64/apps/qgis&amp;quot;
## 
## $python_plugins
## [1] &amp;quot;C:/OSGeo4W64/apps/qgis/python/plugins&amp;quot;
## 
## $platform
## [1] &amp;quot;Windows&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# inicio de QGIS Python
open_app()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La función &lt;code&gt;find_algorithms()&lt;/code&gt; nos ayuda a buscar diferentes herramientas de QGIS. Además la función &lt;code&gt;get_usage()&lt;/code&gt; especifica la forma de uso con todos los argumentos requeridos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# buscar herramientas
find_algorithms(search_term = &amp;quot;vertices&amp;quot;, name_only = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;native:extractspecificvertices&amp;quot;         
## [2] &amp;quot;native:extractvertices&amp;quot;                 
## [3] &amp;quot;native:filterverticesbym&amp;quot;               
## [4] &amp;quot;native:filterverticesbyz&amp;quot;               
## [5] &amp;quot;native:removeduplicatevertices&amp;quot;         
## [6] &amp;quot;saga:convertpolygonlineverticestopoints&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# uso de la herramienta
get_usage(alg = &amp;quot;native:extractvertices&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Extract vertices (native:extractvertices)
## 
## This algorithm takes a line or polygon layer and generates a point layer with points representing the vertices in the input lines or polygons. The attributes associated to each point are the same ones associated to the line or polygon that the point belongs to.
## 
## Additional fields are added to the point indicating the vertex index (beginning at 0)
## the vertex’s part and its index within the part (as well as its ring for polygons)
## distance along original geometry and bisector angle of vertex for original geometry.
## 
## 
## ----------------
## Input parameters
## ----------------
## 
## INPUT: Input layer
## 
##  Parameter type: QgsProcessingParameterFeatureSource
## 
##  Accepted data types:
##      - str: layer ID
##      - str: layer name
##      - str: layer source
##      - QgsProcessingFeatureSourceDefinition
##      - QgsProperty
##      - QgsVectorLayer
## 
## OUTPUT: Vertices
## 
##  Parameter type: QgsProcessingParameterFeatureSink
## 
##  Accepted data types:
##      - str: destination vector file
## e.g. d:/test.shp
##      - str: memory: to store result in temporary memory layer
##      - str: using vector provider ID prefix and destination URI
## e.g. postgres:… to store result in PostGIS table
##      - QgsProcessingOutputLayerDefinition
##      - QgsProperty
## 
## ----------------
## Outputs
## ----------------
## 
## OUTPUT:  &amp;lt;QgsProcessingOutputVectorLayer&amp;gt;
##  Vertices&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En nuestro caso la herramienta para extraer los vértices es simple y sólo lleva una entrada y una salida. La función &lt;code&gt;run_qgis()&lt;/code&gt; ejecuta una herramienta de QGIS indicando el algoritmo y sus argumentos. La ventaja de usar el algoritmo directamente desde R es que podemos pasar objetos de clase &lt;code&gt;sf&lt;/code&gt; (o &lt;code&gt;sp&lt;/code&gt;) y &lt;code&gt;raster&lt;/code&gt; que tenemos importados o creados en R. Como salida creamos un &lt;code&gt;geojson&lt;/code&gt;, también podría ser de otro formato vectorial, y lo guardamos en una carpeta temporal. Al mismo tiempo le indicamos que importe el resultado directamente a R (&lt;code&gt;load_output = TRUE&lt;/code&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;river_vertices &amp;lt;- run_qgis(alg = &amp;quot;native:extractvertices&amp;quot;,
               INPUT = river_line,
               OUTPUT = file.path(tempdir(), &amp;quot;rivers_world_vertices.geojson&amp;quot;),
               load_output = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $OUTPUT
## [1] &amp;quot;C:/Users/xeo19/AppData/Local/Temp/RtmpGurVm9/rivers_world_vertices.geojson&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;Actualmente en Windows parece haber problemas con la librería de &lt;em&gt;proj&lt;/em&gt;. En principio si termina creando el objeto &lt;code&gt;river_vertices&lt;/code&gt; no debes preocuparte. En caso contrario, recomiendo mirar la discusión en el &lt;em&gt;issue&lt;/em&gt; abierto en &lt;a href=&#34;https://github.com/r-spatial/RQGIS3/issues/20&#34;&gt;gitbub&lt;/a&gt;.&lt;/p&gt;

&lt;/div&gt;

&lt;/div&gt;
&lt;div id=&#34;selección&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Selección&lt;/h2&gt;
&lt;p&gt;Antes de seguir con la estimación de la distribución de los ángulos, filtramos algunos ríos de interés. Las funciones de la colección &lt;code&gt;tidyverse&lt;/code&gt; son compatibles con el paquete &lt;code&gt;sf&lt;/code&gt;. En el último post hice una introducción a &lt;code&gt;tidyverse&lt;/code&gt; &lt;a href=&#34;https://dominicroye.github.io/es/2020/una-muy-breve-introducci%C3%B3n-a-tidyverse/&#34;&gt;aquí&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;river_vertices &amp;lt;-  filter(river_vertices, 
                          NAME %in% c(&amp;quot;Mississippi&amp;quot;, &amp;quot;Colorado&amp;quot;, 
                                      &amp;quot;Amazon&amp;quot;, &amp;quot;Nile&amp;quot;, &amp;quot;Orange&amp;quot;, 
                                      &amp;quot;Ganges&amp;quot;, &amp;quot;Yangtze&amp;quot;, &amp;quot;Danube&amp;quot;,
                                      &amp;quot;Mackenzie&amp;quot;, &amp;quot;Lena&amp;quot;, &amp;quot;Murray&amp;quot;, 
                                      &amp;quot;Niger&amp;quot;)
                          ) 

river_vertices &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 94702 features and 11 fields
## geometry type:  POINT
## dimension:      XY
## bbox:           xmin: -10377520 ymin: -3953778 xmax: 13124340 ymax: 7507359
## geographic CRS: WGS 84&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in st_is_longlat(x): bounding box has potentially an invalid value range
## for longlat data

## Warning in st_is_longlat(x): bounding box has potentially an invalid value range
## for longlat data&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 94,702 x 12
##    NAME  SYSTEM name_alt scalerank rivernum Length_km vertex_index vertex_part
##  * &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;        &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;        &amp;lt;int&amp;gt;       &amp;lt;int&amp;gt;
##  1 Nile  &amp;lt;NA&amp;gt;   &amp;lt;NA&amp;gt;             1        4     3344.            0           0
##  2 Nile  &amp;lt;NA&amp;gt;   &amp;lt;NA&amp;gt;             1        4     3344.            1           0
##  3 Nile  &amp;lt;NA&amp;gt;   &amp;lt;NA&amp;gt;             1        4     3344.            2           0
##  4 Nile  &amp;lt;NA&amp;gt;   &amp;lt;NA&amp;gt;             1        4     3344.            3           0
##  5 Nile  &amp;lt;NA&amp;gt;   &amp;lt;NA&amp;gt;             1        4     3344.            4           0
##  6 Nile  &amp;lt;NA&amp;gt;   &amp;lt;NA&amp;gt;             1        4     3344.            5           0
##  7 Nile  &amp;lt;NA&amp;gt;   &amp;lt;NA&amp;gt;             1        4     3344.            6           0
##  8 Nile  &amp;lt;NA&amp;gt;   &amp;lt;NA&amp;gt;             1        4     3344.            7           0
##  9 Nile  &amp;lt;NA&amp;gt;   &amp;lt;NA&amp;gt;             1        4     3344.            8           0
## 10 Nile  &amp;lt;NA&amp;gt;   &amp;lt;NA&amp;gt;             1        4     3344.            9           0
## # ... with 94,692 more rows, and 4 more variables: vertex_part_index &amp;lt;int&amp;gt;,
## #   distance &amp;lt;dbl&amp;gt;, angle &amp;lt;dbl&amp;gt;, geometry &amp;lt;POINT [°]&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;estimar-la-distribución&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Estimar la distribución&lt;/h1&gt;
&lt;p&gt;Para visualizar la distribución podemos usar, o bien un histograma o un gráfico de densidad. Pero en el caso de estimar la función de densidad de probabilidad nos encontramos con un problema matemático a la hora de aplicarlo a datos circulares. No debemos usar la función estandar de R &lt;code&gt;density()&lt;/code&gt; dado que en nuestros datos una dirección de 360º es la misma a 0º, lo que provocaría errores en este rango de valores. Es un problema general para diferentes métricas estadísticas. Más detalles estadísticos se explican en el paquete &lt;code&gt;circular&lt;/code&gt;. Este paquete permite definir las características de los datos circulares (unidad, tipo de datos, rotación, etc.) como una clase de objeto en R.&lt;/p&gt;
&lt;p&gt;Por tanto, lo que hacemos es construir una función que estime la densidad y devuelva una tabla con los ángulos (x) y las estimaciones de densidad (y). Dado que los ríos tienen diferentes longitudes, y queremos ver diferencias independientemente de ello, normalizamos las estimaciones usando el valor máximo. A diferencia de la función &lt;code&gt;density()&lt;/code&gt;, en la que el ancho de banda de suavizado &lt;code&gt;bw&lt;/code&gt; es optimizado, aquí es requerido indicarlo. Es similar a definir el ancho de barra en un histograma. Existe una función de optimización para la banda, &lt;code&gt;bw.nrd.circular()&lt;/code&gt; que se podría emplear aquí.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dens_circ &amp;lt;- function(x){
  
  dens &amp;lt;- density.circular(circular(x$angle, units = &amp;quot;degrees&amp;quot;),
                                     bw = 70, kernel = &amp;quot;vonmises&amp;quot;,
                                     control.circular = list(units = &amp;quot;degrees&amp;quot;))
  
  df &amp;lt;- data.frame(x = dens$x, y = dens$y/max(dens$y))
  
  return(df)
  
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para finalizar, estimamos la densidad de cada río de nuestra selección. Empleamos la función &lt;code&gt;split()&lt;/code&gt; de &lt;em&gt;R Base&lt;/em&gt; para obtener una tabla de cada río en una lista. Después aplicamos con la función &lt;code&gt;map_df()&lt;/code&gt; del paquete &lt;code&gt;purrr&lt;/code&gt; nuestra función de estimación de densidad a la lista. El sufijo &lt;code&gt;_df&lt;/code&gt; permite que obtengamos una tabla unida, en lugar de una lista con los resultados de cada río. No obstante, es necesario indicar el nombre de la columna con el argumento &lt;code&gt;.id&lt;/code&gt;, la que contendrá el nombre de cada río. En caso contrario no sabríamos diferenciar los resultados. También aquí recomiendo leer más detalles en el último post sobre &lt;code&gt;tidyverse&lt;/code&gt; &lt;a href=&#34;https://dominicroye.github.io/es/2020/una-muy-breve-introducci%C3%B3n-a-tidyverse/&#34;&gt;aquí&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dens_river &amp;lt;- split(river_vertices, river_vertices$NAME) %&amp;gt;% 
                  map_df(dens_circ, .id = &amp;quot;river&amp;quot;)

# resultado
head(dens_river)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    river        x         y
## 1 Amazon 0.000000 0.2399907
## 2 Amazon 0.704501 0.2492548
## 3 Amazon 1.409002 0.2585758
## 4 Amazon 2.113503 0.2679779
## 5 Amazon 2.818004 0.2774859
## 6 Amazon 3.522505 0.2871232&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;visualización&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Visualización&lt;/h1&gt;
&lt;p&gt;Ahora ya sólo nos queda la visualización mediante el famoso paquete &lt;code&gt;ggplot&lt;/code&gt;. Primero añadimos una nueva fuente &lt;em&gt;Montserrat&lt;/em&gt; para usarla en este gráfico.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# descarga de fuente
font_add_google(&amp;quot;Montserrat&amp;quot;, &amp;quot;Montserrat&amp;quot;)

# usar showtext para fuentes
showtext_opts(dpi = 200)
showtext_auto() &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En el siguiente paso creamos dos objetos con el título y con una nota de pie. En el título estamos usando un código html para dar color a una parte de texto en sustitución de una leyenda. Se puede usar html de forma muy fácil con el paquete &lt;code&gt;ggtext&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# título con html 
title &amp;lt;- &amp;quot;Relative distribution of river &amp;lt;span style=&amp;#39;color:#011FFD;&amp;#39;&amp;gt;&amp;lt;strong&amp;gt;flow direction&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt; in the world&amp;quot;


caption &amp;lt;- &amp;quot;Based on data from Zeenatul Basher, 20180215&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La cuadrícula de fondo que crea &lt;code&gt;ggplot&lt;/code&gt; por defecto para coordenadas polares no me convenció, por eso creamos una tabla con las líneas de fondo del eje x.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;grid_x &amp;lt;- tibble(x = seq(0, 360 - 22.5, by = 22.5), 
                 y = rep(0, 16), 
                 xend = seq(0, 360 - 22.5, by = 22.5), 
                 yend = rep(Inf, 16))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A continuación definimos todos los estilos del gráfico. Lo más importante en este paso es la función &lt;code&gt;element_textbox()&lt;/code&gt; del paquete &lt;code&gt;ggtext&lt;/code&gt; para poder interpretar nuestro código html incorporado al título.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;theme_polar &amp;lt;- theme_minimal() +
               theme(axis.title.y = element_blank(),
                     axis.text.y = element_blank(),
                     legend.title = element_blank(),
                     plot.title = element_textbox(family = &amp;quot;Montserrat&amp;quot;, 
                                                   hjust = 0.5, 
                                                   colour = &amp;quot;white&amp;quot;, 
                                                   size = 15),
                     plot.caption = element_text(family = &amp;quot;Montserrat&amp;quot;, 
                                                 colour = &amp;quot;white&amp;quot;),
                     axis.text.x = element_text(family = &amp;quot;Montserrat&amp;quot;, 
                                                 colour = &amp;quot;white&amp;quot;),
                     strip.text = element_text(family = &amp;quot;Montserrat&amp;quot;, 
                                               colour = &amp;quot;white&amp;quot;, 
                                               face = &amp;quot;bold&amp;quot;),
                     panel.background = element_rect(fill = &amp;quot;black&amp;quot;),
                     plot.background = element_rect(fill = &amp;quot;black&amp;quot;),
                     panel.grid = element_blank()
                    )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para terminar construimos el gráfico: 1) Usamos la función &lt;code&gt;geom_hline()&lt;/code&gt; con diferentes puntos de intersección en &lt;em&gt;y&lt;/em&gt; para crear la cuadrícula de fondo. La función &lt;code&gt;geom_segment()&lt;/code&gt; crea la cuadrícula en &lt;em&gt;x&lt;/em&gt;. 2) El área de densidad la creamos usando la función &lt;code&gt;geom_area()&lt;/code&gt;. 3) En &lt;code&gt;scale_x_continous()&lt;/code&gt; definimos un límite inferior
negativo para que no colapse en un punto pequeño. Las etiquetas de las ocho direcciones principales las indicamos en la función &lt;code&gt;scale_y_continous()&lt;/code&gt;, y 4) Por último, cambiamos a un sistema de coordenadas polar y fijamos la variable para crear facetas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  geom_hline(yintercept = c(0, .2, .6, .8, 1), colour = &amp;quot;white&amp;quot;) +
  geom_segment(data = grid_x , 
               aes(x = x, y = y, xend = xend, yend = yend), 
               linetype = &amp;quot;dashed&amp;quot;, col = &amp;quot;white&amp;quot;) +
  geom_area(data = dens_river, 
            aes(x = x, y = y, ymin = 0, ymax = y), 
            alpha = .7, 
            colour = NA, 
            show.legend = FALSE,
            fill = &amp;quot;#011FFD&amp;quot;) + 
  scale_y_continuous(limits = c(-.2, 1), expand = c(0, 0)) +
  scale_x_continuous(limits = c(0, 360), 
                     breaks = seq(0, 360 - 22.5, by = 22.5),
                     minor_breaks = NULL,
                     labels = c(&amp;quot;N&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;NE&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;E&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;SE&amp;quot;, &amp;quot;&amp;quot;,
                                &amp;quot;S&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;SW&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;W&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;NW&amp;quot;, &amp;quot;&amp;quot;)) +
  coord_polar() + 
  facet_wrap(river ~ ., ncol = 4) +
  labs(title = title, caption = caption, x = &amp;quot;&amp;quot;) +
  theme_polar&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Ignoring unknown aesthetics: ymin, ymax&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/es/2020-07-24-direcciones-del-flujo-fluvial/index.es_files/figure-html/unnamed-chunk-19-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
      
            <category>direcciones</category>
      
            <category>rios</category>
      
            <category>fluvial</category>
      
            <category>orientación</category>
      
            <category>distribución</category>
      
      
            <category>sig</category>
      
            <category>R</category>
      
            <category>R:avanzado</category>
      
    </item>
    
    <item>
      <title>Una muy breve introducción a Tidyverse</title>
      <link>/es/2020/una-muy-breve-introducci%C3%B3n-a-tidyverse/</link>
      <pubDate>Sat, 06 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/2020/una-muy-breve-introducci%C3%B3n-a-tidyverse/</guid>
      <description>

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#tidyverse&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1&lt;/span&gt; Tidyverse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#guía-de-estilo&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2&lt;/span&gt; Guía de estilo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pipe&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3&lt;/span&gt; Pipe %&amp;gt;%&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#paquetes-de-tidyverse&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4&lt;/span&gt; Paquetes de Tidyverse&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#lectura-y-escritura&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.1&lt;/span&gt; Lectura y escritura&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#manipulación-de-caracteres&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.2&lt;/span&gt; Manipulación de caracteres&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#manejo-de-fechas-y-horas&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.3&lt;/span&gt; Manejo de fechas y horas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#manipulación-de-tablas-y-vectores&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.4&lt;/span&gt; Manipulación de tablas y vectores&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#selecionar-y-renombrar&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.4.1&lt;/span&gt; Selecionar y renombrar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#filtrar-y-ordenar&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.4.2&lt;/span&gt; Filtrar y ordenar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#agrupar-y-resumir&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.4.3&lt;/span&gt; Agrupar y resumir&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#unir-tablas&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.4.4&lt;/span&gt; Unir tablas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tablas-largas-y-anchas&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.4.5&lt;/span&gt; Tablas largas y anchas&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#visualizar-datos&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.5&lt;/span&gt; Visualizar datos&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#gráfico-de-linea-y-puntos&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.5.1&lt;/span&gt; Gráfico de linea y puntos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#boxplot&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.5.2&lt;/span&gt; Boxplot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#heatmap&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.5.3&lt;/span&gt; Heatmap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#aplicar-funciones-sobre-vectores-o-listas&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.6&lt;/span&gt; Aplicar funciones sobre vectores o listas&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;tidyverse&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;1&lt;/span&gt; Tidyverse&lt;/h1&gt;
&lt;p&gt;El universo de los paquetes de &lt;code&gt;tidyverse&lt;/code&gt;, una colección de paquetes de funciones para un uso especialmente enfocado en la ciencia de datos, abrió un antes y después en la programación de R. En este post voy a resumir muy brevemente lo más esencial para inicarse en este mundo. La gramática sigue en todas las funciones una estructura común. Lo más esencial es que el primer argumento es el objeto y a continuación viene el resto de argumentos. Además, se proporciona un conjunto de verbos que facilitan el uso de las funciones. En la actualidad, la filosofía de las funciones también se refleja en otros paquetes que hacen compatible su uso con la colección de &lt;code&gt;tidyverse&lt;/code&gt;. Por ejemplo, el paquete &lt;code&gt;sf&lt;/code&gt; (&lt;a href=&#34;https://r-spatial.github.io/sf/articles/sf1.html&#34;&gt;simple feature&lt;/a&gt;) para el tratamiento de datos vectoriales, permite el uso de múltiples funciones que encontramos en el paquete &lt;code&gt;dplyr&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;El núcleo de la colección lo constituyen los siguientes paquetes:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Paquete&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ggplot2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Gramática para la creación de gráficos&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;purrr&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Programación funcional de R&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tibble&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Sistema moderno y efectivo de tablas&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;dplyr&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Gramatica para la manipulación de datos&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tidyr&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Conjunto de funciones para ordenar datos&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;stringr&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Conjunto de funciones para trabajar con caracteres&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;readr&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Una forma fácil y rápida para importar datos&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;forcats&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Herramientas y funciones para trabajar fácilmente con factores&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Además de los paquetes menciondos, también se usa muy frecuentemente &lt;code&gt;lubridate&lt;/code&gt; para trabajar con fechas y horas, y también &lt;code&gt;readxl&lt;/code&gt; que nos permite importar archivos en formato Excel. Para conocer todos los paquetes disponibles podemos emplear la función &lt;code&gt;tidyverse_packages()&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;broom&amp;quot;      &amp;quot;cli&amp;quot;        &amp;quot;crayon&amp;quot;     &amp;quot;dbplyr&amp;quot;     &amp;quot;dplyr&amp;quot;     
##  [6] &amp;quot;forcats&amp;quot;    &amp;quot;ggplot2&amp;quot;    &amp;quot;haven&amp;quot;      &amp;quot;hms&amp;quot;        &amp;quot;httr&amp;quot;      
## [11] &amp;quot;jsonlite&amp;quot;   &amp;quot;lubridate&amp;quot;  &amp;quot;magrittr&amp;quot;   &amp;quot;modelr&amp;quot;     &amp;quot;pillar&amp;quot;    
## [16] &amp;quot;purrr&amp;quot;      &amp;quot;readr&amp;quot;      &amp;quot;readxl&amp;quot;     &amp;quot;reprex&amp;quot;     &amp;quot;rlang&amp;quot;     
## [21] &amp;quot;rstudioapi&amp;quot; &amp;quot;rvest&amp;quot;      &amp;quot;stringr&amp;quot;    &amp;quot;tibble&amp;quot;     &amp;quot;tidyr&amp;quot;     
## [26] &amp;quot;xml2&amp;quot;       &amp;quot;tidyverse&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Es muy fácil encontrarnos con conflicos de funciones, o sea, que el mismo nombre de función exista en varios paquetes. Para evitarlo, podemos escribir el nombre del paquete delante de la función que queremos usar, separados por el símbolo de dos puntos escrito dos veces (&lt;code&gt;package_name::function_name&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Antes de empezar con los paquetes, espero que sea verdaderamente una breve introducción, algunos comentarios sobre el estilo al programar en R.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;guía-de-estilo&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;2&lt;/span&gt; Guía de estilo&lt;/h1&gt;
&lt;p&gt;En R no existe una guía de estilo universal, o sea, en la sintaxis de R no es necesario seguir normas concretas para nuestros scripts. Es recomendable trabajar de forma homogénea y clara a la hora de escribir con un estilo uniforme y legible. La colección de &lt;code&gt;tidyverse&lt;/code&gt; tiene una guia propia (&lt;a href=&#34;https://style.tidyverse.org/&#34; class=&#34;uri&#34;&gt;https://style.tidyverse.org/&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Las recomendaciones más importes son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Evitar usar más de 80 caracteres por línea para permitir leer el código completo.&lt;/li&gt;
&lt;li&gt;Usar siempre un espacio después de una coma, nunca antes.&lt;/li&gt;
&lt;li&gt;Los operadores (==, +, -, &amp;lt;-, %&amp;gt;%, etc.) deben tener un espacio antes y después.&lt;/li&gt;
&lt;li&gt;No hay espacio entre el nombre de una función y el primer paréntesis, ni entre el último arguemento y el paréntesis final de una función.&lt;/li&gt;
&lt;li&gt;Evitar reutilizar nombres de funciones y variables comunes (&lt;code&gt;c &amp;lt;- 5&lt;/code&gt; vs. &lt;code&gt;c()&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Ordenar el script separando las partes con la forma de comentario &lt;code&gt;# Importar datos -----&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Se deben evitar tildes o símbolos especiales en nombres, archivos, rutas, etc.&lt;/li&gt;
&lt;li&gt;Nombres de los objetos deben seguir una estructura constante: &lt;code&gt;day_one&lt;/code&gt;, &lt;code&gt;day_1&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Es aconsejable usar una correcta &lt;em&gt;indentación&lt;/em&gt; para multiples argumentos de una función o funciones encadenadas por el operador &lt;code&gt;pipe&lt;/code&gt; (&lt;code&gt;%&amp;gt;%&lt;/code&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;pipe&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;3&lt;/span&gt; Pipe %&amp;gt;%&lt;/h1&gt;
&lt;p&gt;Para facilitar el trabajo en la gestión, manipulación y visualización de datos, el paquete &lt;code&gt;magrittr&lt;/code&gt; introduce el operador llamado &lt;em&gt;pipe&lt;/em&gt; en la forma &lt;code&gt;%&amp;gt;%&lt;/code&gt; con el objetivo de combinar varias funciones sin la necesidad de asignar el resultado a un nuevo objeto. El operador &lt;em&gt;pipe&lt;/em&gt; pasa a la salida de una función aplicada al primer argumento de la siguiente función. Esta forma de combinar funciones permite encadenar varios pasos de forma simultánea. En el siguiente ejemplo, muy sencillo, pasamos el vector &lt;code&gt;1:5&lt;/code&gt; a la función &lt;code&gt;mean()&lt;/code&gt; para calcular el promedio.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1:5 %&amp;gt;% mean()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;paquetes-de-tidyverse&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;4&lt;/span&gt; Paquetes de Tidyverse&lt;/h1&gt;
&lt;div id=&#34;lectura-y-escritura&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.1&lt;/span&gt; Lectura y escritura&lt;/h2&gt;
&lt;p&gt;El paquete &lt;code&gt;readr&lt;/code&gt; facilita la lectura o escritura de múltiples formatos de archivo usando funciones que comienzan por &lt;code&gt;read_*&lt;/code&gt; o &lt;code&gt;write_*&lt;/code&gt;.
En comparación con &lt;em&gt;R Base&lt;/em&gt; las funciones son más rápidas, ayudan a limpiar los nombres de las columnas y las fechas son convertidas automáticamente. Las tablas importadas son de clase &lt;code&gt;tibble&lt;/code&gt; (&lt;strong&gt;tbl_df&lt;/strong&gt;), una versión moderna de &lt;code&gt;data.frame&lt;/code&gt; del paquete &lt;code&gt;tibble&lt;/code&gt;. En el mismo sentido se puede usar la función &lt;code&gt;read_excel()&lt;/code&gt; del paquete &lt;code&gt;readxl&lt;/code&gt; para importar datos de hojas de Excel (más detalles también en esta &lt;a href=&#34;https://dominicroye.github.io/es/2019/importar-varias-hojas-excel-en-r/&#34;&gt;entrada de mi blog&lt;/a&gt;). En el siguiente ejemplo importamos los datos de la movilidad registrada por Google (&lt;a href=&#34;https://www.google.com/covid19/mobility/&#34;&gt;enlace&lt;/a&gt;) durante los últimos meses a causa de la pandemia COVID-19 (&lt;a href=&#34;/files/Global_Mobility_Report.csv&#34;&gt;descarga&lt;/a&gt;).&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Función lectura&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;read_csv() o read_csv2()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;coma o punto-coma (CSV)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;read_delim()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;separador general&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;read_table()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;espacio blanco&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# cargar el paquete
library(tidyverse)

google_mobility &amp;lt;- read_csv(&amp;quot;Global_Mobility_Report.csv&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Parsed with column specification:
## cols(
##   country_region_code = col_character(),
##   country_region = col_character(),
##   sub_region_1 = col_character(),
##   sub_region_2 = col_logical(),
##   iso_3166_2_code = col_character(),
##   census_fips_code = col_logical(),
##   date = col_date(format = &amp;quot;&amp;quot;),
##   retail_and_recreation_percent_change_from_baseline = col_double(),
##   grocery_and_pharmacy_percent_change_from_baseline = col_double(),
##   parks_percent_change_from_baseline = col_double(),
##   transit_stations_percent_change_from_baseline = col_double(),
##   workplaces_percent_change_from_baseline = col_double(),
##   residential_percent_change_from_baseline = col_double()
## )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: 597554 parsing failures.
##    row              col           expected         actual                         file
## 200119 sub_region_2     1/0/T/F/TRUE/FALSE Autauga County &amp;#39;Global_Mobility_Report.csv&amp;#39;
## 200119 census_fips_code 1/0/T/F/TRUE/FALSE 01001          &amp;#39;Global_Mobility_Report.csv&amp;#39;
## 200120 sub_region_2     1/0/T/F/TRUE/FALSE Autauga County &amp;#39;Global_Mobility_Report.csv&amp;#39;
## 200120 census_fips_code 1/0/T/F/TRUE/FALSE 01001          &amp;#39;Global_Mobility_Report.csv&amp;#39;
## 200121 sub_region_2     1/0/T/F/TRUE/FALSE Autauga County &amp;#39;Global_Mobility_Report.csv&amp;#39;
## ...... ................ .................. .............. ............................
## See problems(...) for more details.&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;google_mobility&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 516,697 x 13
##    country_region_~ country_region sub_region_1 sub_region_2 iso_3166_2_code
##    &amp;lt;chr&amp;gt;            &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt;        &amp;lt;lgl&amp;gt;        &amp;lt;chr&amp;gt;          
##  1 AE               United Arab E~ &amp;lt;NA&amp;gt;         NA           &amp;lt;NA&amp;gt;           
##  2 AE               United Arab E~ &amp;lt;NA&amp;gt;         NA           &amp;lt;NA&amp;gt;           
##  3 AE               United Arab E~ &amp;lt;NA&amp;gt;         NA           &amp;lt;NA&amp;gt;           
##  4 AE               United Arab E~ &amp;lt;NA&amp;gt;         NA           &amp;lt;NA&amp;gt;           
##  5 AE               United Arab E~ &amp;lt;NA&amp;gt;         NA           &amp;lt;NA&amp;gt;           
##  6 AE               United Arab E~ &amp;lt;NA&amp;gt;         NA           &amp;lt;NA&amp;gt;           
##  7 AE               United Arab E~ &amp;lt;NA&amp;gt;         NA           &amp;lt;NA&amp;gt;           
##  8 AE               United Arab E~ &amp;lt;NA&amp;gt;         NA           &amp;lt;NA&amp;gt;           
##  9 AE               United Arab E~ &amp;lt;NA&amp;gt;         NA           &amp;lt;NA&amp;gt;           
## 10 AE               United Arab E~ &amp;lt;NA&amp;gt;         NA           &amp;lt;NA&amp;gt;           
## # ... with 516,687 more rows, and 8 more variables: census_fips_code &amp;lt;lgl&amp;gt;,
## #   date &amp;lt;date&amp;gt;, retail_and_recreation_percent_change_from_baseline &amp;lt;dbl&amp;gt;,
## #   grocery_and_pharmacy_percent_change_from_baseline &amp;lt;dbl&amp;gt;,
## #   parks_percent_change_from_baseline &amp;lt;dbl&amp;gt;,
## #   transit_stations_percent_change_from_baseline &amp;lt;dbl&amp;gt;,
## #   workplaces_percent_change_from_baseline &amp;lt;dbl&amp;gt;,
## #   residential_percent_change_from_baseline &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Debemos prestar atención a los nombres de los argumentos, ya que cambian en las funciones de &lt;code&gt;readr&lt;/code&gt;. Por ejemplo, el argumento conocido &lt;code&gt;header = TRUE&lt;/code&gt; de &lt;code&gt;read.csv()&lt;/code&gt; es en este caso &lt;code&gt;col_names = TRUE&lt;/code&gt;. Podemos encontrar más detalles en el &lt;a href=&#34;https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf&#34;&gt;Cheat-Sheet&lt;/a&gt; de &lt;code&gt;readr&lt;/code&gt; .&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;manipulación-de-caracteres&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.2&lt;/span&gt; Manipulación de caracteres&lt;/h2&gt;
&lt;p&gt;Cuando se requiere manipular cadenas de texto usamos el paquete &lt;code&gt;stringr&lt;/code&gt;, cuyas funciones siempre empiezan por &lt;code&gt;str_*&lt;/code&gt; seguidas por un verbo y el primer argumento.&lt;/p&gt;
&lt;p&gt;Algunas de estas funciones son las siguientes:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Función&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;str_replace()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;reemplazar patrones&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;str_c()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;combinar characteres&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;str_detect()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;detectar patrones&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;str_extract()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;extraer patrones&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;str_sub()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;extraer por posición&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;str_length()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;longitud de la cadena de caracteres&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Se suelen usar expresiones regulares para patrones de caracteres. Por ejemplo, la expresión regular &lt;code&gt;[aeiou]&lt;/code&gt; coincide con cualquier caracter único que sea una vocal. El uso de corchetes &lt;code&gt;[]&lt;/code&gt; corresponde a clases de caracteres. Por ejemplo, &lt;code&gt;[abc]&lt;/code&gt; corresponde a cada letra independientemente de la posición. &lt;code&gt;[a-z]&lt;/code&gt; o &lt;code&gt;[A-Z]&lt;/code&gt; o &lt;code&gt;[0-9]&lt;/code&gt; cada uno entre a y z ó 0 y 9. Y por último, &lt;code&gt;[:punct:]&lt;/code&gt; puntuación, etc. Con llaves “{}” podemos indicar el número del elemento anterior &lt;code&gt;{2}&lt;/code&gt; sería dos veces, {1,2} entre una y dos, etc. Además con &lt;code&gt;$&lt;/code&gt;o &lt;code&gt;^&lt;/code&gt; podemos indicar si el patrón empieza al principio o termina al final. Podemos encontrar más detalles y patrones en el &lt;a href=&#34;https://github.com/rstudio/cheatsheets/raw/master/strings.pdf&#34;&gt;Cheat-Sheet&lt;/a&gt; de &lt;code&gt;stringr&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# reemplazamos &amp;#39;er&amp;#39; al final por vacío

str_replace(month.name, &amp;quot;er$&amp;quot;, &amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;January&amp;quot;  &amp;quot;February&amp;quot; &amp;quot;March&amp;quot;    &amp;quot;April&amp;quot;    &amp;quot;May&amp;quot;      &amp;quot;June&amp;quot;    
##  [7] &amp;quot;July&amp;quot;     &amp;quot;August&amp;quot;   &amp;quot;Septemb&amp;quot;  &amp;quot;Octob&amp;quot;    &amp;quot;Novemb&amp;quot;   &amp;quot;Decemb&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_replace(month.name, &amp;quot;^Ma&amp;quot;, &amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;January&amp;quot;   &amp;quot;February&amp;quot;  &amp;quot;rch&amp;quot;       &amp;quot;April&amp;quot;     &amp;quot;y&amp;quot;         &amp;quot;June&amp;quot;     
##  [7] &amp;quot;July&amp;quot;      &amp;quot;August&amp;quot;    &amp;quot;September&amp;quot; &amp;quot;October&amp;quot;   &amp;quot;November&amp;quot;  &amp;quot;December&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# combinar caracteres

a &amp;lt;- str_c(month.name, 1:12, sep = &amp;quot;_&amp;quot;)
a&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;January_1&amp;quot;   &amp;quot;February_2&amp;quot;  &amp;quot;March_3&amp;quot;     &amp;quot;April_4&amp;quot;     &amp;quot;May_5&amp;quot;      
##  [6] &amp;quot;June_6&amp;quot;      &amp;quot;July_7&amp;quot;      &amp;quot;August_8&amp;quot;    &amp;quot;September_9&amp;quot; &amp;quot;October_10&amp;quot; 
## [11] &amp;quot;November_11&amp;quot; &amp;quot;December_12&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# colapsar combinación

str_c(month.name, collapse = &amp;quot;, &amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;January, February, March, April, May, June, July, August, September, October, November, December&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# dedectamos patrones

str_detect(a, &amp;quot;_[1-5]{1}&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# extraemos patrones

str_extract(a, &amp;quot;_[1-9]{1,2}&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;_1&amp;quot;  &amp;quot;_2&amp;quot;  &amp;quot;_3&amp;quot;  &amp;quot;_4&amp;quot;  &amp;quot;_5&amp;quot;  &amp;quot;_6&amp;quot;  &amp;quot;_7&amp;quot;  &amp;quot;_8&amp;quot;  &amp;quot;_9&amp;quot;  &amp;quot;_1&amp;quot;  &amp;quot;_11&amp;quot; &amp;quot;_12&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# extraermos los caracteres en las posiciones entre 1 y 2

str_sub(month.name, 1, 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;Ja&amp;quot; &amp;quot;Fe&amp;quot; &amp;quot;Ma&amp;quot; &amp;quot;Ap&amp;quot; &amp;quot;Ma&amp;quot; &amp;quot;Ju&amp;quot; &amp;quot;Ju&amp;quot; &amp;quot;Au&amp;quot; &amp;quot;Se&amp;quot; &amp;quot;Oc&amp;quot; &amp;quot;No&amp;quot; &amp;quot;De&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# longitud de cada mes

str_length(month.name)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 7 8 5 5 3 4 4 6 9 7 8 8&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# con pipe, el &amp;#39;.&amp;#39; representa al objeto que pasa el operador %&amp;gt;%
str_length(month.name) %&amp;gt;% 
   str_c(month.name, ., sep = &amp;quot;.&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;January.7&amp;quot;   &amp;quot;February.8&amp;quot;  &amp;quot;March.5&amp;quot;     &amp;quot;April.5&amp;quot;     &amp;quot;May.3&amp;quot;      
##  [6] &amp;quot;June.4&amp;quot;      &amp;quot;July.4&amp;quot;      &amp;quot;August.6&amp;quot;    &amp;quot;September.9&amp;quot; &amp;quot;October.7&amp;quot;  
## [11] &amp;quot;November.8&amp;quot;  &amp;quot;December.8&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Una función muy útil es &lt;code&gt;str_glue()&lt;/code&gt; para interpolar caracteres.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;name &amp;lt;- c(&amp;quot;Juan&amp;quot;, &amp;quot;Michael&amp;quot;)
age &amp;lt;- c(50, 80) 
date_today &amp;lt;- Sys.Date()

str_glue(
  &amp;quot;My name is {name}, &amp;quot;,
  &amp;quot;I&amp;#39;am {age}, &amp;quot;,
  &amp;quot;and my birth year is {format(date_today-age*365, &amp;#39;%Y&amp;#39;)}.&amp;quot;
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## My name is Juan, I&amp;#39;am 50, and my birth year is 1970.
## My name is Michael, I&amp;#39;am 80, and my birth year is 1940.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;manejo-de-fechas-y-horas&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.3&lt;/span&gt; Manejo de fechas y horas&lt;/h2&gt;
&lt;p&gt;El paquete &lt;code&gt;lubridate&lt;/code&gt; ayuda en el manejo de fechas y horas. Nos permite crear los objetos reconocidos por R con funciones (como &lt;code&gt;ymd()&lt;/code&gt; ó &lt;code&gt;ymd_hms()&lt;/code&gt;) y hacer cálculos.&lt;/p&gt;
&lt;p&gt;Debemos conocer las siguientes abreviaturas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ymd&lt;/code&gt;: representa &lt;code&gt;y:year&lt;/code&gt;, &lt;code&gt;m:month&lt;/code&gt;, &lt;code&gt;d:day&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hms&lt;/code&gt;: representa &lt;code&gt;h:hour&lt;/code&gt;, &lt;code&gt;m:minutes&lt;/code&gt;, &lt;code&gt;s:seconds&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# paquete
library(lubridate)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &amp;#39;lubridate&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked from &amp;#39;package:base&amp;#39;:
## 
##     date, intersect, setdiff, union&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vector de fechas
dat &amp;lt;- c(&amp;quot;1999/12/31&amp;quot;, &amp;quot;2000/01/07&amp;quot;, &amp;quot;2005/05/20&amp;quot;,&amp;quot;2010/03/25&amp;quot;)

# vector de fechas y horas
dat_time &amp;lt;- c(&amp;quot;1988-08-01 05:00&amp;quot;, &amp;quot;2000-02-01 22:00&amp;quot;)

# convertir a clase date
dat &amp;lt;- ymd(dat) 
dat&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;1999-12-31&amp;quot; &amp;quot;2000-01-07&amp;quot; &amp;quot;2005-05-20&amp;quot; &amp;quot;2010-03-25&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# otras formatos
dmy(&amp;quot;05-02-2000&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2000-02-05&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ymd(&amp;quot;20000506&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2000-05-06&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# convertir a POSIXct
dat_time &amp;lt;- ymd_hm(dat_time)
dat_time&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;1988-08-01 05:00:00 UTC&amp;quot; &amp;quot;2000-02-01 22:00:00 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# diferentes formatos en un vector 
dat_mix &amp;lt;- c(&amp;quot;1999/12/05&amp;quot;, &amp;quot;05-09-2008&amp;quot;, &amp;quot;2000/08/09&amp;quot;, &amp;quot;25-10-2019&amp;quot;)

# indicar formato con la convención conocida en ?strptime
parse_date_time(dat_mix, order = c(&amp;quot;%Y/%m/%d&amp;quot;, &amp;quot;%d-%m-%Y&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;1999-12-05 UTC&amp;quot; &amp;quot;2008-09-05 UTC&amp;quot; &amp;quot;2000-08-09 UTC&amp;quot; &amp;quot;2019-10-25 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Más funciones útiles:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# extraer el año
year(dat)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1999 2000 2005 2010&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# el mes
month(dat)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 12  1  5  3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;month(dat, label = TRUE) # como etiqueta&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] dic ene may mar
## 12 Levels: ene &amp;lt; feb &amp;lt; mar &amp;lt; abr &amp;lt; may &amp;lt; jun &amp;lt; jul &amp;lt; ago &amp;lt; sep &amp;lt; ... &amp;lt; dic&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# el día de la semana
wday(dat)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 6 6 6 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;wday(dat, label = TRUE) # como etiqueta&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] vi\\. vi\\. vi\\. ju\\.
## Levels: do\\. &amp;lt; lu\\. &amp;lt; ma\\. &amp;lt; mi\\. &amp;lt; ju\\. &amp;lt; vi\\. &amp;lt; sá\\.&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# la hora
hour(dat_time)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  5 22&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# sumar 10 días
dat + days(10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2000-01-10&amp;quot; &amp;quot;2000-01-17&amp;quot; &amp;quot;2005-05-30&amp;quot; &amp;quot;2010-04-04&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# sumar 1 mes
dat + months(1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2000-01-31&amp;quot; &amp;quot;2000-02-07&amp;quot; &amp;quot;2005-06-20&amp;quot; &amp;quot;2010-04-25&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Por último, la función &lt;code&gt;make_date()&lt;/code&gt; es muy útil en crear fechas a partir de diferentes partes de las mismas como puede ser el año, mes, etc.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# crear fecha a partir de sus elementos, aquí con año y mes
make_date(2000, 5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2000-05-01&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# crear fecha con hora 
make_datetime(2005, 5, 23, 5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2005-05-23 05:00:00 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Podemos encontrar más detalles en el &lt;a href=&#34;https://github.com/rstudio/cheatsheets/raw/master/lubridate.pdf&#34;&gt;Cheat-Sheet&lt;/a&gt; de &lt;code&gt;lubridate&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;manipulación-de-tablas-y-vectores&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.4&lt;/span&gt; Manipulación de tablas y vectores&lt;/h2&gt;
&lt;p&gt;Los paquetes &lt;code&gt;dplyr&lt;/code&gt; y &lt;code&gt;tidyr&lt;/code&gt; nos proporciona una gramática de manipulación de datos con un conjunto de verbos útiles para resolver los problemas más comunes. Las funciones más importantes son:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Función&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;mutate()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;añadir nuevas variables o modificar existentes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;select()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;seleccionar variables&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;filter()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;filtrar&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;summarise()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;resumir/reducir&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;arrange()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ordenar&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;group_by()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;agrupar&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;rename()&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;renombrar columnas&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;En caso de que no lo hayas hecho antes, importamos los datos de movilidad.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;google_mobility &amp;lt;- read_csv(&amp;quot;Global_Mobility_Report.csv&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Parsed with column specification:
## cols(
##   country_region_code = col_character(),
##   country_region = col_character(),
##   sub_region_1 = col_character(),
##   sub_region_2 = col_logical(),
##   iso_3166_2_code = col_character(),
##   census_fips_code = col_logical(),
##   date = col_date(format = &amp;quot;&amp;quot;),
##   retail_and_recreation_percent_change_from_baseline = col_double(),
##   grocery_and_pharmacy_percent_change_from_baseline = col_double(),
##   parks_percent_change_from_baseline = col_double(),
##   transit_stations_percent_change_from_baseline = col_double(),
##   workplaces_percent_change_from_baseline = col_double(),
##   residential_percent_change_from_baseline = col_double()
## )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: 597554 parsing failures.
##    row              col           expected         actual                         file
## 200119 sub_region_2     1/0/T/F/TRUE/FALSE Autauga County &amp;#39;Global_Mobility_Report.csv&amp;#39;
## 200119 census_fips_code 1/0/T/F/TRUE/FALSE 01001          &amp;#39;Global_Mobility_Report.csv&amp;#39;
## 200120 sub_region_2     1/0/T/F/TRUE/FALSE Autauga County &amp;#39;Global_Mobility_Report.csv&amp;#39;
## 200120 census_fips_code 1/0/T/F/TRUE/FALSE 01001          &amp;#39;Global_Mobility_Report.csv&amp;#39;
## 200121 sub_region_2     1/0/T/F/TRUE/FALSE Autauga County &amp;#39;Global_Mobility_Report.csv&amp;#39;
## ...... ................ .................. .............. ............................
## See problems(...) for more details.&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;selecionar-y-renombrar&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.4.1&lt;/span&gt; Selecionar y renombrar&lt;/h3&gt;
&lt;p&gt;Podemos selecionar o eliminar columnas con la función &lt;code&gt;select()&lt;/code&gt;, usando el nombre o índice de la(s) columna(s). Para suprimir columnas hacemos uso del signo negativo. La función &lt;code&gt;rename&lt;/code&gt; ayuda en renombrar columnas o bien con el mismo nombre o con su índice.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;residential_mobility &amp;lt;- select(google_mobility, 
                               country_region_code:sub_region_1, 
                               date, 
                               residential_percent_change_from_baseline) %&amp;gt;% 
                        rename(resi = 5)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;filtrar-y-ordenar&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.4.2&lt;/span&gt; Filtrar y ordenar&lt;/h3&gt;
&lt;p&gt;Para filtrar datos, empleamos &lt;code&gt;filter()&lt;/code&gt; con operadores lógicos (&lt;code&gt;|&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, etc) o funciones que devuelven un valor lógico (&lt;code&gt;str_detect()&lt;/code&gt;, &lt;code&gt;is.na()&lt;/code&gt;, etc.). La función &lt;code&gt;arrange()&lt;/code&gt; ordena de menor a mayor por una o múltiples variables (con el signo negativo &lt;code&gt;-&lt;/code&gt; se invierte el orden de mayor a menor).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;filter(residential_mobility, 
       country_region_code == &amp;quot;US&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 304,648 x 5
##    country_region_code country_region sub_region_1 date        resi
##    &amp;lt;chr&amp;gt;               &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt;        &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt;
##  1 US                  United States  &amp;lt;NA&amp;gt;         2020-02-15    -1
##  2 US                  United States  &amp;lt;NA&amp;gt;         2020-02-16    -1
##  3 US                  United States  &amp;lt;NA&amp;gt;         2020-02-17     5
##  4 US                  United States  &amp;lt;NA&amp;gt;         2020-02-18     1
##  5 US                  United States  &amp;lt;NA&amp;gt;         2020-02-19     0
##  6 US                  United States  &amp;lt;NA&amp;gt;         2020-02-20     1
##  7 US                  United States  &amp;lt;NA&amp;gt;         2020-02-21     0
##  8 US                  United States  &amp;lt;NA&amp;gt;         2020-02-22    -1
##  9 US                  United States  &amp;lt;NA&amp;gt;         2020-02-23    -1
## 10 US                  United States  &amp;lt;NA&amp;gt;         2020-02-24     0
## # ... with 304,638 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;filter(residential_mobility, 
       country_region_code == &amp;quot;US&amp;quot;, 
       sub_region_1 == &amp;quot;New York&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 7,068 x 5
##    country_region_code country_region sub_region_1 date        resi
##    &amp;lt;chr&amp;gt;               &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt;        &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt;
##  1 US                  United States  New York     2020-02-15     0
##  2 US                  United States  New York     2020-02-16    -1
##  3 US                  United States  New York     2020-02-17     9
##  4 US                  United States  New York     2020-02-18     3
##  5 US                  United States  New York     2020-02-19     2
##  6 US                  United States  New York     2020-02-20     2
##  7 US                  United States  New York     2020-02-21     3
##  8 US                  United States  New York     2020-02-22    -1
##  9 US                  United States  New York     2020-02-23    -1
## 10 US                  United States  New York     2020-02-24     0
## # ... with 7,058 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;filter(residential_mobility, 
       resi &amp;gt; 50) %&amp;gt;% 
          arrange(-resi)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 32 x 5
##    country_region_co~ country_region sub_region_1               date        resi
##    &amp;lt;chr&amp;gt;              &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt;                      &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt;
##  1 KW                 Kuwait         Al Farwaniyah Governorate  2020-05-14    56
##  2 KW                 Kuwait         Al Farwaniyah Governorate  2020-05-21    55
##  3 SG                 Singapore      &amp;lt;NA&amp;gt;                       2020-05-01    55
##  4 KW                 Kuwait         Al Farwaniyah Governorate  2020-05-28    54
##  5 PE                 Peru           Metropolitan Municipality~ 2020-04-10    54
##  6 EC                 Ecuador        Pichincha                  2020-03-27    53
##  7 KW                 Kuwait         Al Farwaniyah Governorate  2020-05-11    53
##  8 KW                 Kuwait         Al Farwaniyah Governorate  2020-05-13    53
##  9 KW                 Kuwait         Al Farwaniyah Governorate  2020-05-20    53
## 10 SG                 Singapore      &amp;lt;NA&amp;gt;                       2020-04-10    53
## # ... with 22 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;agrupar-y-resumir&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.4.3&lt;/span&gt; Agrupar y resumir&lt;/h3&gt;
&lt;p&gt;¿Dónde encontramos mayor variabilidad entre regiones en cada país el día 1 de abril de 2020?&lt;/p&gt;
&lt;p&gt;Para responder a esta pregunta, primero filtramos los datos y después agrupamos por la columna de país. Cuando empleamos la función &lt;code&gt;summarise()&lt;/code&gt; posterior a la agrupación, nos permite resumir por estos grupos. Incluso, la combinación del &lt;code&gt;group_by()&lt;/code&gt; con la función &lt;code&gt;mutate()&lt;/code&gt; permite modificar columnas por grupos. En &lt;code&gt;summarise()&lt;/code&gt; calculamos el valor máximo, mínimo y la diferencia entre ambos extremos creando nuevas columnas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;resi_variability &amp;lt;- residential_mobility %&amp;gt;% 
                        filter(date == ymd(&amp;quot;2020-04-01&amp;quot;),
                               !is.na(sub_region_1)) %&amp;gt;% 
                          group_by(country_region) %&amp;gt;% 
                       summarise(mx = max(resi, na.rm = TRUE), 
                                 min = min(resi, na.rm = TRUE),
                                 range = abs(mx)-abs(min))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in max(resi, na.rm = TRUE): ningun argumento finito para max; retornando
## -Inf

## Warning in max(resi, na.rm = TRUE): ningun argumento finito para max; retornando
## -Inf

## Warning in max(resi, na.rm = TRUE): ningun argumento finito para max; retornando
## -Inf

## Warning in max(resi, na.rm = TRUE): ningun argumento finito para max; retornando
## -Inf

## Warning in max(resi, na.rm = TRUE): ningun argumento finito para max; retornando
## -Inf

## Warning in max(resi, na.rm = TRUE): ningun argumento finito para max; retornando
## -Inf&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in min(resi, na.rm = TRUE): ningún argumento finito para min; retornando
## Inf

## Warning in min(resi, na.rm = TRUE): ningún argumento finito para min; retornando
## Inf

## Warning in min(resi, na.rm = TRUE): ningún argumento finito para min; retornando
## Inf

## Warning in min(resi, na.rm = TRUE): ningún argumento finito para min; retornando
## Inf

## Warning in min(resi, na.rm = TRUE): ningún argumento finito para min; retornando
## Inf

## Warning in min(resi, na.rm = TRUE): ningún argumento finito para min; retornando
## Inf&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## `summarise()` ungrouping output (override with `.groups` argument)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;arrange(resi_variability, -range)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 94 x 4
##    country_region    mx   min range
##    &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 Nigeria           43     6    37
##  2 United States     35     6    29
##  3 India             36    15    21
##  4 Malaysia          45    26    19
##  5 Philippines       40    21    19
##  6 Vietnam           28     9    19
##  7 Colombia          41    24    17
##  8 Ecuador           44    27    17
##  9 Argentina         35    19    16
## 10 Chile             30    14    16
## # ... with 84 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;unir-tablas&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.4.4&lt;/span&gt; Unir tablas&lt;/h3&gt;
&lt;p&gt;¿Cómo podemos filtrar los datos para obtener un subconjunto de Europa?&lt;/p&gt;
&lt;p&gt;Para ello, importamos datos espaciales con el código de país y una columna de las regiones. Explicaciones detalladas sobre el paquete &lt;code&gt;sf&lt;/code&gt; (&lt;em&gt;simple feature&lt;/em&gt;) para trabajar con datos vectoriales, lo dejaremos para otro post.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(rnaturalearth) # paquete de datos vectoriales

# datos de países
wld &amp;lt;- ne_countries(returnclass = &amp;quot;sf&amp;quot;)

# filtramos los países con código y seleccionamos las dos columnas de interés
wld &amp;lt;- filter(wld, !is.na(iso_a2)) %&amp;gt;% select(iso_a2, subregion)

# plot
plot(wld)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/es/2020-06-06-una-muy-breve-introduccion-a-tidyverse/index.es_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Otras funciones de &lt;code&gt;dplyr&lt;/code&gt; nos permiten unir tablas: &lt;code&gt;*_join()&lt;/code&gt;. Según hacia qué tabla (izquierda o derecha) se quiere unir, cambia la función : &lt;code&gt;left_join()&lt;/code&gt;, &lt;code&gt;right_join()&lt;/code&gt; o incluso &lt;code&gt;full_join()&lt;/code&gt;. El argumento &lt;code&gt;by&lt;/code&gt; no es necesario siempre y cuando ambas tablas tienen una columna en común. No obstante, en este caso la columna de fusión es diferente, por eso, usamos el modo &lt;code&gt;c(&#34;country_region_code&#34;=&#34;iso_a2&#34;)&lt;/code&gt;. El paquete &lt;code&gt;forcats&lt;/code&gt; de &lt;code&gt;tidyverse&lt;/code&gt; tiene muchas funciones útiles para manejar variables categóricas (&lt;code&gt;factors&lt;/code&gt;), variables que tienen un conjunto fijo y conocido de valores posibles. Todas las funciones de &lt;code&gt;forcats&lt;/code&gt; tienen el prefijo &lt;code&gt;fct_*&lt;/code&gt;. Por ejemplo, en este caso usamos &lt;code&gt;fct_reorder()&lt;/code&gt; para reordenar las etiquetas de los países en orden de la máxima basada en los registros de movibilidad residencial. Finalmente, creamos una nueva columna ‘resi_real’ para cambiar el valor de referencia, el promedio (&lt;em&gt;baseline&lt;/em&gt;), fijado en 0 a 100.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;subset_europe &amp;lt;- filter(residential_mobility, 
                        is.na(sub_region_1),
                        !is.na(resi)) %&amp;gt;%
                 left_join(wld, by = c(&amp;quot;country_region_code&amp;quot;=&amp;quot;iso_a2&amp;quot;)) %&amp;gt;% 
                 filter(subregion %in% c(&amp;quot;Northern Europe&amp;quot;,
                                         &amp;quot;Southern Europe&amp;quot;,
                                          &amp;quot;Western Europe&amp;quot;,
                                          &amp;quot;Eastern Europe&amp;quot;)) %&amp;gt;%
                 mutate(resi_real = resi + 100,
                        region = fct_reorder(country_region, 
                                             resi, 
                                            .fun = &amp;quot;max&amp;quot;, 
                                            .desc = FALSE)) %&amp;gt;% 
                select(-geometry, -sub_region_1)

str(subset_europe)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## tibble [3,988 x 7] (S3: tbl_df/tbl/data.frame)
##  $ country_region_code: chr [1:3988] &amp;quot;AT&amp;quot; &amp;quot;AT&amp;quot; &amp;quot;AT&amp;quot; &amp;quot;AT&amp;quot; ...
##  $ country_region     : chr [1:3988] &amp;quot;Austria&amp;quot; &amp;quot;Austria&amp;quot; &amp;quot;Austria&amp;quot; &amp;quot;Austria&amp;quot; ...
##  $ date               : Date[1:3988], format: &amp;quot;2020-02-15&amp;quot; &amp;quot;2020-02-16&amp;quot; ...
##  $ resi               : num [1:3988] -2 -2 0 0 1 0 1 -2 0 -1 ...
##  $ subregion          : chr [1:3988] &amp;quot;Western Europe&amp;quot; &amp;quot;Western Europe&amp;quot; &amp;quot;Western Europe&amp;quot; &amp;quot;Western Europe&amp;quot; ...
##  $ resi_real          : num [1:3988] 98 98 100 100 101 100 101 98 100 99 ...
##  $ region             : Factor w/ 35 levels &amp;quot;Belarus&amp;quot;,&amp;quot;Ukraine&amp;quot;,..: 18 18 18 18 18 18 18 18 18 18 ...
##  - attr(*, &amp;quot;problems&amp;quot;)= tibble [597,554 x 5] (S3: tbl_df/tbl/data.frame)
##   ..$ row     : int [1:597554] 200119 200119 200120 200120 200121 200121 200122 200122 200123 200123 ...
##   ..$ col     : chr [1:597554] &amp;quot;sub_region_2&amp;quot; &amp;quot;census_fips_code&amp;quot; &amp;quot;sub_region_2&amp;quot; &amp;quot;census_fips_code&amp;quot; ...
##   ..$ expected: chr [1:597554] &amp;quot;1/0/T/F/TRUE/FALSE&amp;quot; &amp;quot;1/0/T/F/TRUE/FALSE&amp;quot; &amp;quot;1/0/T/F/TRUE/FALSE&amp;quot; &amp;quot;1/0/T/F/TRUE/FALSE&amp;quot; ...
##   ..$ actual  : chr [1:597554] &amp;quot;Autauga County&amp;quot; &amp;quot;01001&amp;quot; &amp;quot;Autauga County&amp;quot; &amp;quot;01001&amp;quot; ...
##   ..$ file    : chr [1:597554] &amp;quot;&amp;#39;Global_Mobility_Report.csv&amp;#39;&amp;quot; &amp;quot;&amp;#39;Global_Mobility_Report.csv&amp;#39;&amp;quot; &amp;quot;&amp;#39;Global_Mobility_Report.csv&amp;#39;&amp;quot; &amp;quot;&amp;#39;Global_Mobility_Report.csv&amp;#39;&amp;quot; ...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;tablas-largas-y-anchas&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.4.5&lt;/span&gt; Tablas largas y anchas&lt;/h3&gt;
&lt;p&gt;Antes de pasar a la visualización con &lt;code&gt;ggplot2&lt;/code&gt;. Es muy habitual modificar la tabla entre dos formatos principales. Una tabla es &lt;em&gt;tidy&lt;/em&gt; cuando 1) cada variable es una columna 2) cada observación/caso es una fila y 3) cada tipo de unidad observacional forma una tabla.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# subconjunto 
mobility_selection &amp;lt;- select(subset_europe, country_region_code, date:resi)
mobility_selection&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3,988 x 3
##    country_region_code date        resi
##    &amp;lt;chr&amp;gt;               &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt;
##  1 AT                  2020-02-15    -2
##  2 AT                  2020-02-16    -2
##  3 AT                  2020-02-17     0
##  4 AT                  2020-02-18     0
##  5 AT                  2020-02-19     1
##  6 AT                  2020-02-20     0
##  7 AT                  2020-02-21     1
##  8 AT                  2020-02-22    -2
##  9 AT                  2020-02-23     0
## 10 AT                  2020-02-24    -1
## # ... with 3,978 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# tabla ancha
mobi_wide &amp;lt;- pivot_wider(mobility_selection, 
                         names_from = country_region_code,
                         values_from = resi)
mobi_wide&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 114 x 36
##    date          AT    BA    BE    BG    BY    CH    CZ    DE    DK    EE    ES
##    &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 2020-02-15    -2    -1    -1     0    -1    -1    -2    -1     0     0    -2
##  2 2020-02-16    -2    -1     1    -3     0    -1    -1     0     1     0    -2
##  3 2020-02-17     0    -1     0    -2     0     1     0     0     1     1    -1
##  4 2020-02-18     0    -1     0    -2     0     1     0     1     1     1     0
##  5 2020-02-19     1    -1     0    -1    -1     1     0     1     1     0    -1
##  6 2020-02-20     0    -1     0     0    -1     0     0     1     1     0    -1
##  7 2020-02-21     1    -2     0    -1    -1     1     0     2     1     1    -2
##  8 2020-02-22    -2    -1     0     0    -2    -2    -3     0     1     0    -2
##  9 2020-02-23     0    -1     0    -3    -1    -1     0     0     0    -2    -3
## 10 2020-02-24    -1    -1     4    -1     0     0     0     4     0    16     0
## # ... with 104 more rows, and 24 more variables: FI &amp;lt;dbl&amp;gt;, FR &amp;lt;dbl&amp;gt;, GB &amp;lt;dbl&amp;gt;,
## #   GR &amp;lt;dbl&amp;gt;, HR &amp;lt;dbl&amp;gt;, HU &amp;lt;dbl&amp;gt;, IE &amp;lt;dbl&amp;gt;, IT &amp;lt;dbl&amp;gt;, LT &amp;lt;dbl&amp;gt;, LU &amp;lt;dbl&amp;gt;,
## #   LV &amp;lt;dbl&amp;gt;, MD &amp;lt;dbl&amp;gt;, MK &amp;lt;dbl&amp;gt;, NL &amp;lt;dbl&amp;gt;, NO &amp;lt;dbl&amp;gt;, PL &amp;lt;dbl&amp;gt;, PT &amp;lt;dbl&amp;gt;,
## #   RO &amp;lt;dbl&amp;gt;, RS &amp;lt;dbl&amp;gt;, RU &amp;lt;dbl&amp;gt;, SE &amp;lt;dbl&amp;gt;, SI &amp;lt;dbl&amp;gt;, SK &amp;lt;dbl&amp;gt;, UA &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# tabla larga
pivot_longer(mobi_wide,
             2:36,
             names_to = &amp;quot;country_code&amp;quot;,
             values_to = &amp;quot;resi&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3,990 x 3
##    date       country_code  resi
##    &amp;lt;date&amp;gt;     &amp;lt;chr&amp;gt;        &amp;lt;dbl&amp;gt;
##  1 2020-02-15 AT              -2
##  2 2020-02-15 BA              -1
##  3 2020-02-15 BE              -1
##  4 2020-02-15 BG               0
##  5 2020-02-15 BY              -1
##  6 2020-02-15 CH              -1
##  7 2020-02-15 CZ              -2
##  8 2020-02-15 DE              -1
##  9 2020-02-15 DK               0
## 10 2020-02-15 EE               0
## # ... with 3,980 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Otro grupo de funciones a las que deberías echar un vistazo son: &lt;code&gt;separate()&lt;/code&gt;, &lt;code&gt;case_when()&lt;/code&gt;, &lt;code&gt;complete()&lt;/code&gt;. Podemos encontrar más detalles en el &lt;a href=&#34;https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf&#34;&gt;Cheat-Sheet&lt;/a&gt; de &lt;code&gt;dplyr&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;visualizar-datos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.5&lt;/span&gt; Visualizar datos&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ggplot2&lt;/code&gt; es un sistema moderno, y con una enorme variedad de opciones, para visualización de datos. A diferencia del sistema gráfico de &lt;em&gt;R Base&lt;/em&gt; se utiliza una gramática diferente.
La gramática de los gráficos (&lt;em&gt;grammar of graphics&lt;/em&gt;, de allí “gg”) consiste en la suma de varias capas u objetos independientes que se combinan usando &lt;code&gt;+&lt;/code&gt; para construir el gráfico final. &lt;code&gt;ggplot&lt;/code&gt; diferencia entre los datos, lo que se visualiza y la forma en que se visualiza.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;data&lt;/em&gt;: nuestro conjunto de datos (&lt;code&gt;data.frame&lt;/code&gt; o &lt;code&gt;tibble&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;aesthetics&lt;/em&gt;: con la función &lt;code&gt;aes()&lt;/code&gt; indicamos las variables que corresponden a los ejes x, y, z,… o, cuando se pretende aplicar parámetros gráficos (&lt;em&gt;color&lt;/em&gt;, &lt;em&gt;size&lt;/em&gt;, &lt;em&gt;shape&lt;/em&gt;) según una variable. Es posible incluir &lt;code&gt;aes()&lt;/code&gt; en &lt;code&gt;ggplot()&lt;/code&gt; o en la función correspondiente a una geometría &lt;code&gt;geom_*&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;geometries&lt;/em&gt;: son objetos &lt;code&gt;geom_*&lt;/code&gt; que indican la geometría a usar, (p. ej.: &lt;code&gt;geom_point()&lt;/code&gt;, &lt;code&gt;geom_line()&lt;/code&gt;, &lt;code&gt;geom_boxplot()&lt;/code&gt;, etc.).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;scales&lt;/em&gt;: son objetos de tipo &lt;code&gt;scales_*&lt;/code&gt; (p. ej.: &lt;code&gt;scale_x_continous()&lt;/code&gt;, &lt;code&gt;scale_colour_manual()&lt;/code&gt;) para manipular las ejes, definir colores, etc.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;statistics&lt;/em&gt;: son objetos &lt;code&gt;stat_*&lt;/code&gt; (p.ej.: &lt;code&gt;stat_density()&lt;/code&gt;) que permiten aplicar transformaciones estadísticas.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Podemos encontrar más detalles en el &lt;a href=&#34;https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf&#34;&gt;Cheat-Sheet&lt;/a&gt; de &lt;code&gt;ggplot2&lt;/code&gt;. &lt;code&gt;ggplot&lt;/code&gt; es complementado constantemente con extensiones para geometrías u otras opciones gráficas (&lt;a href=&#34;https://exts.ggplot2.tidyverse.org/ggiraph.html&#34; class=&#34;uri&#34;&gt;https://exts.ggplot2.tidyverse.org/ggiraph.html&lt;/a&gt;), para obtener ideas gráficas, debes echarle un vistazo a la Galería de Gráficos R (&lt;a href=&#34;https://www.r-graph-gallery.com/&#34; class=&#34;uri&#34;&gt;https://www.r-graph-gallery.com/&lt;/a&gt;).&lt;/p&gt;
&lt;div id=&#34;gráfico-de-linea-y-puntos&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.5.1&lt;/span&gt; Gráfico de linea y puntos&lt;/h3&gt;
&lt;p&gt;Creamos un subconjunto de nuestros datos de movilidad para residencias y parques, filtrando los registros de regiones italianas. Además, dividimos los valores de movilidad en porcentaje por 100 para obtener la fracción, ya que &lt;code&gt;ggplot2&lt;/code&gt; nos permite indicar la unidad de porcentaje en el argumento de las etiquetas (último gráfico de esta sección).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# creamos el subconjunto
it &amp;lt;- filter(google_mobility, 
             country_region == &amp;quot;Italy&amp;quot;, 
             is.na(sub_region_1)) %&amp;gt;% 
      mutate(resi = residential_percent_change_from_baseline/100,   
             parks = parks_percent_change_from_baseline/100)


# gráfico de línea 
ggplot(it, 
       aes(date, resi)) + 
  geom_line()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/es/2020-06-06-una-muy-breve-introduccion-a-tidyverse/index.es_files/figure-html/unnamed-chunk-20-1.png&#34; width=&#34;2100&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# gráfico de dispersión con línea de correlación
ggplot(it, 
       aes(parks, resi)) + 
  geom_point() +
  geom_smooth(method = &amp;quot;lm&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## `geom_smooth()` using formula &amp;#39;y ~ x&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/es/2020-06-06-una-muy-breve-introduccion-a-tidyverse/index.es_files/figure-html/unnamed-chunk-20-2.png&#34; width=&#34;2100&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Para modificar los ejes, empleamos las diferentes funciones de &lt;code&gt;scale_*&lt;/code&gt; que debemos adpatar a las escalas de medición (&lt;em&gt;date&lt;/em&gt;, &lt;em&gt;discrete&lt;/em&gt;, &lt;em&gt;continuous&lt;/em&gt;, etc.). La función &lt;code&gt;labs()&lt;/code&gt; nos ayuda en definir los títulos de ejes, del gráfico y de la leyenda. Por último, añadimos con &lt;code&gt;theme_light()&lt;/code&gt; el estilo del gráfico (otros son &lt;code&gt;theme_bw()&lt;/code&gt;, &lt;code&gt;theme_minimal()&lt;/code&gt;, etc.). También podríamos hacer cambios de todos los elementos gráficos a través de &lt;code&gt;theme()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# time serie plot
ggplot(it, 
       aes(date, resi)) + 
  geom_line(colour = &amp;quot;#560A86&amp;quot;, size = 0.8) +
  scale_x_date(date_breaks = &amp;quot;10 days&amp;quot;, 
               date_labels = &amp;quot;%d %b&amp;quot;) +
  scale_y_continuous(breaks = seq(-0.1, 1, 0.1), 
                     labels = scales::percent) +
  labs(x = &amp;quot;&amp;quot;, 
       y = &amp;quot;Residential mobility&amp;quot;,
       title = &amp;quot;Mobility during COVID-19&amp;quot;) +
  theme_light()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/es/2020-06-06-una-muy-breve-introduccion-a-tidyverse/index.es_files/figure-html/unnamed-chunk-21-1.png&#34; width=&#34;2100&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# scatter plot
ggplot(it, 
       aes(parks, resi)) + 
  geom_point(alpha = .4, size = 2) +
  geom_smooth(method = &amp;quot;lm&amp;quot;) +
  scale_x_continuous(breaks = seq(-1, 1.4, 0.2), 
                     labels = scales::percent) +
  scale_y_continuous(breaks = seq(-1, 1, 0.1), 
                     labels = scales::percent) +
  labs(x = &amp;quot;Park mobility&amp;quot;, 
       y = &amp;quot;Residential mobility&amp;quot;,
       title = &amp;quot;Mobility during COVID-19&amp;quot;) +
  theme_light()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## `geom_smooth()` using formula &amp;#39;y ~ x&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/es/2020-06-06-una-muy-breve-introduccion-a-tidyverse/index.es_files/figure-html/unnamed-chunk-21-2.png&#34; width=&#34;2100&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;boxplot&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.5.2&lt;/span&gt; Boxplot&lt;/h3&gt;
&lt;p&gt;Podemos visualizar diferentes aspectos de los datos de movilidad con otras geometrías. Aquí creamos &lt;em&gt;boxplots&lt;/em&gt; por cada país europeo representando la variabilidad de movilidad entre y en los países durante la pandemia del COVID-19.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# subconjunto
subset_europe_reg &amp;lt;- filter(residential_mobility, 
                           !is.na(sub_region_1),
                           !is.na(resi)) %&amp;gt;%
                     left_join(wld, by = c(&amp;quot;country_region_code&amp;quot;=&amp;quot;iso_a2&amp;quot;)) %&amp;gt;% 
                     filter(subregion %in% c(&amp;quot;Northern Europe&amp;quot;,
                                         &amp;quot;Southern Europe&amp;quot;,
                                          &amp;quot;Western Europe&amp;quot;,
                                          &amp;quot;Eastern Europe&amp;quot;)) %&amp;gt;% 
                     mutate(resi = resi/100, 
                            country_region = fct_reorder(country_region, resi))

# boxplot
ggplot(subset_europe_reg, 
       aes(country_region, resi, fill = subregion)) + 
  geom_boxplot() +
  scale_y_continuous(breaks = seq(-0.1, 1, 0.1), labels = scales::percent) +
  scale_fill_brewer(palette = &amp;quot;Set1&amp;quot;) +
  coord_flip() +
   labs(x = &amp;quot;&amp;quot;, 
       y = &amp;quot;Residential mobility&amp;quot;,
       title = &amp;quot;Mobility during COVID-19&amp;quot;, 
       fill = &amp;quot;&amp;quot;) +
  theme_minimal()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/es/2020-06-06-una-muy-breve-introduccion-a-tidyverse/index.es_files/figure-html/unnamed-chunk-22-1.png&#34; width=&#34;2100&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;heatmap&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.5.3&lt;/span&gt; Heatmap&lt;/h3&gt;
&lt;p&gt;Para visualizar la tendencia de todos los países europeos es recomendable usar un &lt;em&gt;heatmap&lt;/em&gt; en lugar de un bulto de líneas. Antes de constuir el gráfico, creamos un vector de fechas para las etiquetas con los domingos en el período de registros.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# secuencia de fechas
df &amp;lt;- data.frame(d = seq(ymd(&amp;quot;2020-02-15&amp;quot;), ymd(&amp;quot;2020-06-07&amp;quot;), &amp;quot;day&amp;quot;))

# filtramos los domingos creando el día de la semana
sundays &amp;lt;- df %&amp;gt;% 
            mutate(wd = wday(d, week_start = 1)) %&amp;gt;% 
             filter(wd == 7) %&amp;gt;% 
              pull(d)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Si queremos usar etiquetas en otras lenguas, es necesario cambiar la configuración regional del sistema.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Sys.setlocale(&amp;quot;LC_TIME&amp;quot;, &amp;quot;English&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;English_United States.1252&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El relleno de color para los boxplots lo dibujamos por cada región de los países europeos. Podemos fijar el tipo de color con &lt;code&gt;scale_fill_*&lt;/code&gt;, en este caso, de las gamas &lt;em&gt;viridis&lt;/em&gt;.&lt;br /&gt;
Además, la función &lt;code&gt;guides()&lt;/code&gt; nos permite modificar la barra de color de la leyenda. Por último, aquí vemos el uso de &lt;code&gt;theme()&lt;/code&gt; con cambios adicionales a &lt;code&gt;theme_minimal()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# headmap
ggplot(subset_europe, 
       aes(date, region, fill = resi_real)) +
  geom_tile() +
  scale_x_date(breaks = sundays,
               date_labels = &amp;quot;%d %b&amp;quot;) +
  scale_fill_viridis_c(option = &amp;quot;A&amp;quot;, 
                       breaks = c(91, 146),
                       labels = c(&amp;quot;Less&amp;quot;, &amp;quot;More&amp;quot;), 
                       direction = -1) +
  theme_minimal() +
  theme(legend.position = &amp;quot;top&amp;quot;, 
        title = element_text(size = 14),
        panel.grid.major.x = element_line(colour = &amp;quot;white&amp;quot;, linetype = &amp;quot;dashed&amp;quot;),
        panel.grid.minor.x = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.ontop = TRUE,
        plot.margin = margin(r = 1, unit = &amp;quot;cm&amp;quot;)) +
  labs(y = &amp;quot;&amp;quot;, 
       x = &amp;quot;&amp;quot;, 
       fill = &amp;quot;&amp;quot;, 
       title = &amp;quot;Mobility trends for places of residence&amp;quot;,
       caption = &amp;quot;Data: google.com/covid19/mobility/&amp;quot;) +
  guides(fill = guide_colorbar(barwidth = 10, 
                               barheight = .5,
                               label.position = &amp;quot;top&amp;quot;, 
                               ticks = FALSE)) +
  coord_cartesian(expand = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/es/2020-06-06-una-muy-breve-introduccion-a-tidyverse/index.es_files/figure-html/unnamed-chunk-25-1.png&#34; width=&#34;3675&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;aplicar-funciones-sobre-vectores-o-listas&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.6&lt;/span&gt; Aplicar funciones sobre vectores o listas&lt;/h2&gt;
&lt;p&gt;El paquete &lt;code&gt;purrr&lt;/code&gt; contiene un conjunto de funciones avanzadas de programación funcional para trabajar con funciones y vectores. La familia de funciones &lt;code&gt;lapply()&lt;/code&gt; conocido de &lt;code&gt;R Base&lt;/code&gt;corresponde a las funciones de &lt;code&gt;map()&lt;/code&gt; en este paquete. Una de las mayores ventajas es poder reducir el uso de bucles (&lt;code&gt;for&lt;/code&gt;, etc.).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# lista con dos vectores
vec_list &amp;lt;- list(x = 1:10, y = 50:70)

# calculamos el promedio para cada uno
map(vec_list, mean)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $x
## [1] 5.5
## 
## $y
## [1] 60&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# podemos cambiar tipo de salida map_* (dbl, chr, lgl, etc.)
map_dbl(vec_list, mean)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x    y 
##  5.5 60.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Un ejemplo más complejo. Calculamos el coeficiente de correlación entre la movilidad residencial y la de los parques en todos los países europeos. Para obtener un resumen &lt;em&gt;tidy&lt;/em&gt; de un modelo o un test usamos la función &lt;code&gt;tidy()&lt;/code&gt; del paquete &lt;code&gt;broom&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(broom) # tidy outputs

# función adaptada 
cor_test &amp;lt;- function(x, formula) { 
  
df &amp;lt;- cor.test(as.formula(formula), data = x) %&amp;gt;% tidy()

return(df)
  
}

# preparamos los datos
europe_reg &amp;lt;- filter(google_mobility, 
                           !is.na(sub_region_1),
                           !is.na(residential_percent_change_from_baseline)) %&amp;gt;%
                     left_join(wld, by = c(&amp;quot;country_region_code&amp;quot;=&amp;quot;iso_a2&amp;quot;)) %&amp;gt;% 
                     filter(subregion %in% c(&amp;quot;Northern Europe&amp;quot;,
                                         &amp;quot;Southern Europe&amp;quot;,
                                          &amp;quot;Western Europe&amp;quot;,
                                          &amp;quot;Eastern Europe&amp;quot;))
# aplicamos la función a cada país creando una lista
europe_reg %&amp;gt;%
  split(.$country_region_code) %&amp;gt;% 
  map(cor_test, formula = &amp;quot;~ residential_percent_change_from_baseline + parks_percent_change_from_baseline&amp;quot;)  &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $AT
## # A tibble: 1 x 8
##   estimate statistic  p.value parameter conf.low conf.high method    alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;      
## 1   -0.360     -12.3 2.68e-32      1009   -0.413    -0.305 Pearson&amp;#39;~ two.sided  
## 
## $BE
## # A tibble: 1 x 8
##   estimate statistic  p.value parameter conf.low conf.high method    alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;      
## 1   -0.312     -6.06  3.67e-9       340   -0.405    -0.213 Pearson&amp;#39;~ two.sided  
## 
## $BG
## # A tibble: 1 x 8
##   estimate statistic   p.value parameter conf.low conf.high method   alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;      
## 1   -0.677     -37.8 1.47e-227      1694   -0.702    -0.650 Pearson~ two.sided  
## 
## $CH
## # A tibble: 1 x 8
##   estimate statistic p.value parameter conf.low conf.high method     alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;      
## 1  -0.0786     -2.91 0.00370      1360   -0.131   -0.0256 Pearson&amp;#39;s~ two.sided  
## 
## $CZ
## # A tibble: 1 x 8
##   estimate statistic  p.value parameter conf.low conf.high method    alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;      
## 1  -0.0837     -3.35 0.000824      1593   -0.132   -0.0347 Pearson&amp;#39;~ two.sided  
## 
## $DE
## # A tibble: 1 x 8
##   estimate statistic p.value parameter conf.low conf.high method     alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;      
## 1  0.00239     0.102   0.919      1814  -0.0436    0.0484 Pearson&amp;#39;s~ two.sided  
## 
## $DK
## # A tibble: 1 x 8
##   estimate statistic  p.value parameter conf.low conf.high method    alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;      
## 1    0.237      5.81  1.04e-8       567    0.158     0.313 Pearson&amp;#39;~ two.sided  
## 
## $EE
## # A tibble: 1 x 8
##   estimate statistic p.value parameter conf.low conf.high method     alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;      
## 1   -0.235     -2.88 0.00462       142   -0.384   -0.0740 Pearson&amp;#39;s~ two.sided  
## 
## $ES
## # A tibble: 1 x 8
##   estimate statistic p.value parameter conf.low conf.high method     alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;      
## 1   -0.825     -65.4       0      2005   -0.839    -0.811 Pearson&amp;#39;s~ two.sided  
## 
## $FI
## # A tibble: 1 x 8
##   estimate statistic p.value parameter conf.low conf.high method     alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;      
## 1   0.0427      1.42   0.155      1106  -0.0162     0.101 Pearson&amp;#39;s~ two.sided  
## 
## $FR
## # A tibble: 1 x 8
##   estimate statistic   p.value parameter conf.low conf.high method   alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;      
## 1   -0.698     -37.4 3.29e-216      1474   -0.723    -0.671 Pearson~ two.sided  
## 
## $GB
## # A tibble: 1 x 8
##   estimate statistic  p.value parameter conf.low conf.high method    alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;      
## 1   -0.105     -11.0 9.19e-28     10712   -0.124   -0.0865 Pearson&amp;#39;~ two.sided  
## 
## $GR
## # A tibble: 1 x 8
##   estimate statistic   p.value parameter conf.low conf.high method   alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;      
## 1   -0.692     -27.0 1.03e-114       796   -0.726    -0.654 Pearson~ two.sided  
## 
## $HR
## # A tibble: 1 x 8
##   estimate statistic  p.value parameter conf.low conf.high method    alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;      
## 1   -0.579     -21.9 9.32e-87       954   -0.620    -0.536 Pearson&amp;#39;~ two.sided  
## 
## $HU
## # A tibble: 1 x 8
##   estimate statistic  p.value parameter conf.low conf.high method    alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;      
## 1   -0.342     -15.6 6.71e-52      1843   -0.382    -0.301 Pearson&amp;#39;~ two.sided  
## 
## $IE
## # A tibble: 1 x 8
##   estimate statistic  p.value parameter conf.low conf.high method    alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;      
## 1   -0.222     -8.45 7.49e-17      1378   -0.271    -0.171 Pearson&amp;#39;~ two.sided  
## 
## $IT
## # A tibble: 1 x 8
##   estimate statistic p.value parameter conf.low conf.high method     alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;      
## 1   -0.831     -71.0       0      2250   -0.844    -0.818 Pearson&amp;#39;s~ two.sided  
## 
## $LT
## # A tibble: 1 x 8
##   estimate statistic  p.value parameter conf.low conf.high method    alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;      
## 1   -0.204     -5.45  7.17e-8       686   -0.274    -0.131 Pearson&amp;#39;~ two.sided  
## 
## $LV
## # A tibble: 1 x 8
##   estimate statistic  p.value parameter conf.low conf.high method    alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;      
## 1   -0.544     -6.87 3.84e-10       112   -0.662    -0.401 Pearson&amp;#39;~ two.sided  
## 
## $NL
## # A tibble: 1 x 8
##   estimate statistic  p.value parameter conf.low conf.high method    alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;      
## 1    0.143      5.31  1.25e-7      1356   0.0903     0.195 Pearson&amp;#39;~ two.sided  
## 
## $NO
## # A tibble: 1 x 8
##   estimate statistic p.value parameter conf.low conf.high method     alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;      
## 1   0.0483      1.69  0.0911      1221 -0.00774     0.104 Pearson&amp;#39;s~ two.sided  
## 
## $PL
## # A tibble: 1 x 8
##   estimate statistic   p.value parameter conf.low conf.high method   alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;      
## 1   -0.531     -26.7 6.08e-133      1815   -0.564    -0.498 Pearson~ two.sided  
## 
## $PT
## # A tibble: 1 x 8
##   estimate statistic   p.value parameter conf.low conf.high method   alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;      
## 1   -0.729     -46.9 2.12e-321      1938   -0.749    -0.707 Pearson~ two.sided  
## 
## $RO
## # A tibble: 1 x 8
##   estimate statistic p.value parameter conf.low conf.high method     alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;      
## 1   -0.640     -56.0       0      4517   -0.657    -0.623 Pearson&amp;#39;s~ two.sided  
## 
## $SE
## # A tibble: 1 x 8
##   estimate statistic  p.value parameter conf.low conf.high method    alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;      
## 1    0.106      3.93  9.09e-5      1367   0.0529     0.158 Pearson&amp;#39;~ two.sided  
## 
## $SI
## # A tibble: 1 x 8
##   estimate statistic  p.value parameter conf.low conf.high method    alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;      
## 1   -0.627     -11.4 1.98e-23       200   -0.704    -0.535 Pearson&amp;#39;~ two.sided  
## 
## $SK
## # A tibble: 1 x 8
##   estimate statistic  p.value parameter conf.low conf.high method    alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;      
## 1   -0.196     -5.70  1.65e-8       810   -0.262    -0.129 Pearson&amp;#39;~ two.sided&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como ya hemos visto anteriormente, existen subfunciones de &lt;code&gt;map_*&lt;/code&gt; para obtener en lugar de una lista un objeto de otra clase, aquí de &lt;code&gt;data.frame&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor_mobility &amp;lt;- europe_reg %&amp;gt;%
                  split(.$country_region_code) %&amp;gt;% 
                     map_df(cor_test, 
                            formula = &amp;quot;~ residential_percent_change_from_baseline + parks_percent_change_from_baseline&amp;quot;, 
                            .id = &amp;quot;country_code&amp;quot;)

arrange(cor_mobility, estimate)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 27 x 9
##    country_code estimate statistic   p.value parameter conf.low conf.high method
##    &amp;lt;chr&amp;gt;           &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt; 
##  1 IT             -0.831    -71.0  0.             2250   -0.844    -0.818 Pears~
##  2 ES             -0.825    -65.4  0.             2005   -0.839    -0.811 Pears~
##  3 PT             -0.729    -46.9  2.12e-321      1938   -0.749    -0.707 Pears~
##  4 FR             -0.698    -37.4  3.29e-216      1474   -0.723    -0.671 Pears~
##  5 GR             -0.692    -27.0  1.03e-114       796   -0.726    -0.654 Pears~
##  6 BG             -0.677    -37.8  1.47e-227      1694   -0.702    -0.650 Pears~
##  7 RO             -0.640    -56.0  0.             4517   -0.657    -0.623 Pears~
##  8 SI             -0.627    -11.4  1.98e- 23       200   -0.704    -0.535 Pears~
##  9 HR             -0.579    -21.9  9.32e- 87       954   -0.620    -0.536 Pears~
## 10 LV             -0.544     -6.87 3.84e- 10       112   -0.662    -0.401 Pears~
## # ... with 17 more rows, and 1 more variable: alternative &amp;lt;chr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Otros ejemplos prácticos aquí en este &lt;a href=&#34;https://dominicroye.github.io/es/2019/importar-varias-hojas-excel-en-r/&#34;&gt;post&lt;/a&gt; or este &lt;a href=&#34;https://dominicroye.github.io/en/2019/tidy-correlation-tests-in-r/&#34;&gt;otro&lt;/a&gt;. Podemos encontrar más detalles en el &lt;a href=&#34;https://github.com/rstudio/cheatsheets/raw/master/purrr.pdf&#34;&gt;Cheat-Sheet&lt;/a&gt; de &lt;code&gt;purrr&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
      
            <category>introducción</category>
      
            <category>visualización</category>
      
            <category>gestión</category>
      
            <category>datos</category>
      
            <category>COVID-19</category>
      
      
            <category>tidyverse</category>
      
            <category>R</category>
      
            <category>R:principante</category>
      
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>raster | Dr. Dominic Royé</title>
    <link>https://dominicroye.github.io/es/tag/raster/</link>
      <atom:link href="https://dominicroye.github.io/es/tag/raster/index.xml" rel="self" type="application/rss+xml" />
    <description>raster</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>es-ES</language><copyright>© 2018-2022 Dominic Royé. All rights reserved</copyright><lastBuildDate>Mon, 20 Feb 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://dominicroye.github.io/media/logo_hu6637600e1c36fe7812a10a6623aaebda_116520_300x300_fit_lanczos_3.png</url>
      <title>raster</title>
      <link>https://dominicroye.github.io/es/tag/raster/</link>
    </image>
    
    <item>
      <title>El tiempo de mañana</title>
      <link>https://dominicroye.github.io/es/2023/el-tiempo-de-manana/</link>
      <pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate>
      <guid>https://dominicroye.github.io/es/2023/el-tiempo-de-manana/</guid>
      <description>
&lt;script src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/jquery/jquery.min.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/leaflet/leaflet.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/leaflet/leaflet.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/leafletfix/leafletfix.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/proj4/proj4.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/Proj4Leaflet/proj4leaflet.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/rstudio_leaflet/rstudio_leaflet.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/leaflet-binding/leaflet.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/leaflet-providers/leaflet-providers_1.9.0.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/leaflet-providers-plugin/leaflet-providers-plugin.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/clipboard/setClipboardText.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#paquetes&#34; id=&#34;toc-paquetes&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1&lt;/span&gt; Paquetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#parte-i.-geoprocesamiento-con-google-earth-engine-gee&#34; id=&#34;toc-parte-i.-geoprocesamiento-con-google-earth-engine-gee&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2&lt;/span&gt; Parte I. Geoprocesamiento con Google Earth Engine (GEE)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#antes-de-usar-gee-en-r&#34; id=&#34;toc-antes-de-usar-gee-en-r&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.1&lt;/span&gt; Antes de usar GEE en R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#acceder-a-la-predicción-del-gfs&#34; id=&#34;toc-acceder-a-la-predicción-del-gfs&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.2&lt;/span&gt; Acceder a la predicción del GFS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mapa-dinámico-vía-gee&#34; id=&#34;toc-mapa-dinámico-vía-gee&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.3&lt;/span&gt; Mapa dinámico vía GEE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exportar-múltiples-imagenes&#34; id=&#34;toc-exportar-múltiples-imagenes&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.4&lt;/span&gt; Exportar múltiples imagenes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#parte-ii.-visualización-en-forma-de-un-globo&#34; id=&#34;toc-parte-ii.-visualización-en-forma-de-un-globo&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3&lt;/span&gt; Parte II. Visualización en forma de un globo&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#datos&#34; id=&#34;toc-datos&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.1&lt;/span&gt; Datos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#límites-administrativos-y-retícula&#34; id=&#34;toc-límites-administrativos-y-retícula&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.2&lt;/span&gt; Límites administrativos y retícula&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#construcción-del-mapa&#34; id=&#34;toc-construcción-del-mapa&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.3&lt;/span&gt; Construcción del mapa&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#selecionar-mañana&#34; id=&#34;toc-selecionar-mañana&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.3.1&lt;/span&gt; Selecionar mañana&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#la-sombra-del-globo&#34; id=&#34;toc-la-sombra-del-globo&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.3.2&lt;/span&gt; La sombra del globo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#otras-capas-del-mapa&#34; id=&#34;toc-otras-capas-del-mapa&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.3.3&lt;/span&gt; Otras capas del mapa&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;My climate this week looks at the Arctic freeze that is sweeping across large parts of northern Asia, w/ &lt;a href=&#34;https://twitter.com/Emiliyadotcom?ref_src=twsrc%5Etfw&#34;&gt;@Emiliyadotcom&lt;/a&gt; &lt;a href=&#34;https://t.co/u49jvHKxvK&#34;&gt;https://t.co/u49jvHKxvK&lt;/a&gt;  &lt;a href=&#34;https://twitter.com/hashtag/dataviz?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#dataviz&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/gistribe?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#gistribe&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/cartography?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#cartography&lt;/a&gt; &lt;a href=&#34;https://t.co/6mX22bKZqF&#34;&gt;pic.twitter.com/6mX22bKZqF&lt;/a&gt;&lt;/p&gt;&amp;mdash; Chris Campbell (@digitalcampbell) &lt;a href=&#34;https://twitter.com/digitalcampbell/status/1619362463157456897?ref_src=twsrc%5Etfw&#34;&gt;January 28, 2023&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;Hace tiempo vi los mapas globales de Chris Campbell del Financial Times como en este Tweet y pensé que necesitaba lograrlo en R. Así que veremos cómo podemos acceder a los datos del GFS (Global Forecast System) y visualizarlo con &lt;code&gt;{ggplot2}&lt;/code&gt;, aunque existen varias formas, en este post usaremos la API de Google Earth Engine vía el paquete &lt;code&gt;{rgee}&lt;/code&gt;. Seleccionaremos la ejecución más reciente y calcularemos la temperatura máxima para los próximos días.&lt;/p&gt;
&lt;div id=&#34;paquetes&#34; class=&#34;section level1&#34; number=&#34;1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;1&lt;/span&gt; Paquetes&lt;/h1&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;9%&#34; /&gt;
&lt;col width=&#34;90%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Paquete&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tidyverse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Conjunto de paquetes (visualización y manipulación de datos): ggplot2, dplyr, purrr,etc.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;lubridate&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fácil manipulación de fechas y tiempos&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Simple Feature: importar, exportar y manipular datos vectoriales&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;terra&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Importar, exportar y manipular raster (paquete sucesor de raster)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;rgee&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Acceso a Google Earth Engine API&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;giscoR&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Límites administrativos del mundo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ggshadow&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Extensión para ggplot2 para geometrías con sombra&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;fs&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Proporciona una interfaz uniforme y multiplataforma para las operaciones del sistema de archivos&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ggforce&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Proporciona la funcionalidad que falta a ggplot2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# instalamos los paquetes si hace falta
if(!require(&amp;quot;tidyverse&amp;quot;)) install.packages(&amp;quot;tidyverse&amp;quot;)
if(!require(&amp;quot;sf&amp;quot;)) install.packages(&amp;quot;sf&amp;quot;)
if(!require(&amp;quot;terra&amp;quot;)) install.packages(&amp;quot;terra&amp;quot;)
if(!require(&amp;quot;fs&amp;quot;)) install.packages(&amp;quot;fs&amp;quot;)
if(!require(&amp;quot;rgee&amp;quot;)) install.packages(&amp;quot;rgee&amp;quot;)
if(!require(&amp;quot;giscoR&amp;quot;)) install.packages(&amp;quot;giscoR&amp;quot;)
if(!require(&amp;quot;ggshadow&amp;quot;)) install.packages(&amp;quot;ggshadow&amp;quot;)
if(!require(&amp;quot;ggforce&amp;quot;)) install.packages(&amp;quot;ggforce&amp;quot;)

# paquetes
library(rgee)
library(terra)
library(sf)
library(giscoR)

library(fs)
library(tidyverse)
library(lubridate)
library(ggshadow)
library(ggforce)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;parte-i.-geoprocesamiento-con-google-earth-engine-gee&#34; class=&#34;section level1&#34; number=&#34;2&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;2&lt;/span&gt; Parte I. Geoprocesamiento con Google Earth Engine (GEE)&lt;/h1&gt;
&lt;div id=&#34;antes-de-usar-gee-en-r&#34; class=&#34;section level2&#34; number=&#34;2.1&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.1&lt;/span&gt; Antes de usar GEE en R&lt;/h2&gt;
&lt;p&gt;El primer paso consiste en crear nuestro usuario en earthengine.google.com. Además, es necesario instalar &lt;em&gt;CLI&lt;/em&gt; de &lt;em&gt;gcloud&lt;/em&gt; (&lt;a href=&#34;https://cloud.google.com/sdk/docs/install?hl=es-419&#34; class=&#34;uri&#34;&gt;https://cloud.google.com/sdk/docs/install?hl=es-419&lt;/a&gt;), únicamente debes seguir las instrucciones en Google. Con respecto al lenguaje de GEE, muchas funciones que se aplican son similares a lo que se conoce de &lt;code&gt;{tidyverse}&lt;/code&gt;. Se puede obtener más ayuda en &lt;a href=&#34;https://r-spatial.github.io/rgee/reference/rgee-package.html&#34; class=&#34;uri&#34;&gt;https://r-spatial.github.io/rgee/reference/rgee-package.html&lt;/a&gt; y en la propia página de GEE.&lt;/p&gt;
&lt;p&gt;Lo más esencial del lenguaje nativo Javascript de GEE es que se caracteriza por la forma de combinación de funciones y variables usando el punto, el que se sustuye por el $ en R. Todas las funciones GEE empiezan por el prefijo ee_* (&lt;code&gt;ee_print()&lt;/code&gt;, &lt;code&gt;ee_image_to_drive()&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Una vez que tenemos instalado &lt;em&gt;gcloud&lt;/em&gt; y el paquete &lt;code&gt;{rgee}&lt;/code&gt; podemos proceder a crear el entorno virtual de Python. La función &lt;code&gt;ee_install()&lt;/code&gt; se encarga de instalar Anaconda3 y todos los paquetes necesarios. Para comprobar la correcta instalación de Python, y particularmente de los paquetes &lt;em&gt;numpy&lt;/em&gt; y &lt;em&gt;earthengine-api&lt;/em&gt;, podemos usar &lt;code&gt;ee_check()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ee_install() # crear entorno virtual de Python
ee_check() # comprobar si todo está correcto&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Antes de pasar a programar con la sintaxis propia de GEE se debe autenticar e inicializar GEE empleando la función &lt;code&gt;ee_Initialize()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ee_Initialize(drive = TRUE) # autenticar e inicializar GEE&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ── rgee 1.1.5 ─────────────────────────────────────── earthengine-api 0.1.339 ── 
##  ✔ user: not_defined
##  ✔ Google Drive credentials:
 ✔ Google Drive credentials:  FOUND
##  ✔ Initializing Google Earth Engine:
 ✔ Initializing Google Earth Engine:  DONE!
## 
 ✔ Earth Engine account: users/dominicroye 
## ────────────────────────────────────────────────────────────────────────────────&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;acceder-a-la-predicción-del-gfs&#34; class=&#34;section level2&#34; number=&#34;2.2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.2&lt;/span&gt; Acceder a la predicción del GFS&lt;/h2&gt;
&lt;p&gt;En GEE se denomina &lt;em&gt;ImageCollection&lt;/em&gt; una serie temporal de imágenes o datos multidimensionales. Cada dataset tiene asignado una ID y podemos acceder a ella haciendo la llamada &lt;code&gt;ee$ImageCollection(&#39;ID_IMAGECOLLECTION&#39;)&lt;/code&gt;. Hay funciones auxilares que permiten la conversión de clases puramente de R a Javascript, por ejemplo, la fecha &lt;code&gt;rdate_to_eedate()&lt;/code&gt;. Lo primero lo que hacemos es filtrar a la fecha más reciente con las últimas ejecuciones del modelo GFS.&lt;/p&gt;
&lt;p&gt;Debemos saber que, a diferencia de R, únicamente cuando se envían tareas GEE se ejecuta el cálculo en los servidores, enviando todos los objetos creados. En la mayoría de los pasos se crean objetos &lt;em&gt;EarthEngine&lt;/em&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## GFS forcast
dataset &amp;lt;- ee$ImageCollection(&amp;#39;NOAA/GFS0P25&amp;#39;)$filter(ee$Filter$date(rdate_to_eedate(today()-days(1)),
                                                                    rdate_to_eedate(today()+days(1))))
dataset&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## EarthEngine Object: ImageCollection&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Las ejecuciones del modelo se realizan cada 6 horas (0, 6, 12, 18), así que la función &lt;code&gt;ee_get_date_ic()&lt;/code&gt; nos extrae las fechas para poder elegir la más reciente. Aquí es la primera vez que se ejecutan cálculos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vector de fechas únicas de ejecuciones
last_run &amp;lt;- ee_get_date_ic(dataset)$time_start |&amp;gt; unique()
last_run&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2023-02-22 00:00:00 GMT&amp;quot; &amp;quot;2023-02-22 06:00:00 GMT&amp;quot;
## [3] &amp;quot;2023-02-22 12:00:00 GMT&amp;quot; &amp;quot;2023-02-22 18:00:00 GMT&amp;quot;
## [5] &amp;quot;2023-02-23 00:00:00 GMT&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# seleccionamos la última
last_run &amp;lt;- max(last_run)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A continuación filtramos la fecha de última ejecución y seleccionamos la banda de la temperatura de aire a 2m. Las fechas de la predicción futura son atributos de cada ejecución con una predicción de hasta 336 horas (14 días) desde el día de la misma. Cuando queramos hacer cambios a cada imagen de una ImageCollection debemos hacer uso de la función &lt;code&gt;map()&lt;/code&gt;, similar a la que conocemos del paquete &lt;code&gt;{purrr}&lt;/code&gt;. En este caso redefinimos la fecha de cada imagen (&lt;em&gt;system:time_start&lt;/em&gt;: fecha de ejecución) por la de la predicción (&lt;em&gt;forecast_time&lt;/em&gt;). Es importante que la función a aplicar de R se encuentre dentro de &lt;code&gt;ee_utils_pyfunc()&lt;/code&gt;, la que la traduce a Python. Después extraemos las fechas de la predicción.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# última ejecución y selección de variable 
temp &amp;lt;- dataset$filter(ee$Filter$date(rdate_to_eedate(last_run)))$select(&amp;#39;temperature_2m_above_ground&amp;#39;)

# definimos las fechas de predicción para cada hora
forcast_time &amp;lt;- temp$map(ee_utils_pyfunc(function(img)  {
  
 return(ee$Image(img)$set(&amp;#39;system:time_start&amp;#39;,ee$Image(img)$get(&amp;quot;forecast_time&amp;quot;)))

  })
)

# obtenemos las fechas de predicción
date_forcast &amp;lt;- ee_get_date_ic(forcast_time)
head(date_forcast)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                            id          time_start
## 1 NOAA/GFS0P25/2023022300F000 2023-02-23 00:00:00
## 2 NOAA/GFS0P25/2023022300F001 2023-02-23 01:00:00
## 3 NOAA/GFS0P25/2023022300F002 2023-02-23 02:00:00
## 4 NOAA/GFS0P25/2023022300F003 2023-02-23 03:00:00
## 5 NOAA/GFS0P25/2023022300F004 2023-02-23 04:00:00
## 6 NOAA/GFS0P25/2023022300F005 2023-02-23 05:00:00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Aquí podríamos exportar los datos horarios de temperatura, pero también sería posible estimar la temperatura máxima o mínima diaria de los próximos 14 días. Para lograrlo debemos definir el inicio y final del periodo, y calcular el número de días. Lo que hacemos en términos simples es mapear sobre el número días para filtrar a cada día y aplicar la función &lt;code&gt;max()&lt;/code&gt; o cualquier otra similar.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# definimos inicio final de las fechas
endDate &amp;lt;- rdate_to_eedate(round_date(max(date_forcast$time_start)-days(1), &amp;quot;day&amp;quot;))
startDate &amp;lt;- rdate_to_eedate(round_date(min(date_forcast$time_start), &amp;quot;day&amp;quot;))

# número de dias
numberOfDays &amp;lt;- endDate$difference(startDate, &amp;#39;days&amp;#39;)

# calculamos la máxima diaria 
daily &amp;lt;- ee$ImageCollection(
  ee$List$sequence(0, numberOfDays$subtract(1))$
  map(ee_utils_pyfunc(function (dayOffset) {
    start = startDate$advance(dayOffset, &amp;#39;days&amp;#39;)
    end = start$advance(1, &amp;#39;days&amp;#39;)
    return(forcast_time$
    filterDate(start, end)$
    max()$ # alternativa: min(), mean()
    set(&amp;#39;system:time_start&amp;#39;, start$millis()))
  }))
)

# fechas de la máxima diaria
head(ee_get_date_ic(daily))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      id time_start
## 1 no_id 2023-02-23
## 2 no_id 2023-02-24
## 3 no_id 2023-02-25
## 4 no_id 2023-02-26
## 5 no_id 2023-02-27
## 6 no_id 2023-02-28&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;mapa-dinámico-vía-gee&#34; class=&#34;section level2&#34; number=&#34;2.3&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.3&lt;/span&gt; Mapa dinámico vía GEE&lt;/h2&gt;
&lt;p&gt;Dado que existe la posibilidad de añadir imágenes a un mapa dinámico en el editor de código de GEE, también podemos hacerlo usando desde R la función GEE &lt;a href=&#34;https://developers.google.com/earth-engine/apidocs/map-addlayer&#34;&gt;&lt;code&gt;Map.addLayer()&lt;/code&gt;&lt;/a&gt;. Seleccionamos simplemente el primer día con &lt;code&gt;first()&lt;/code&gt;. En los otros argumento definimos el rango de los valores y la gama de colores.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Map$addLayer(
       eeObject = daily$first(),
       visParams = list(min = -45, max = 45,
                        palette = rev(RColorBrewer::brewer.pal(11, &amp;quot;RdBu&amp;quot;))),
       name = &amp;quot;GFS&amp;quot;) + 
Map$addLegend(
  list(min = -45, max = 45, 
       palette = rev(RColorBrewer::brewer.pal(11, &amp;quot;RdBu&amp;quot;))), 
       name = &amp;quot;Temperatura máxima&amp;quot;, 
       position = &amp;quot;bottomright&amp;quot;, 
       bins = 10)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;leaflet html-widget html-fill-item-overflow-hidden html-fill-item&#34; id=&#34;htmlwidget-1&#34; style=&#34;width:672px;height:480px;&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-1&#34;&gt;{&#34;x&#34;:{&#34;options&#34;:{&#34;minZoom&#34;:1,&#34;maxZoom&#34;:24,&#34;crs&#34;:{&#34;crsClass&#34;:&#34;L.CRS.EPSG3857&#34;,&#34;code&#34;:null,&#34;proj4def&#34;:null,&#34;projectedBounds&#34;:null,&#34;options&#34;:{}},&#34;preferCanvas&#34;:false,&#34;bounceAtZoomLimits&#34;:false,&#34;maxBounds&#34;:[[[-90,-370]],[[90,370]]]},&#34;calls&#34;:[{&#34;method&#34;:&#34;addProviderTiles&#34;,&#34;args&#34;:[&#34;CartoDB.Positron&#34;,&#34;CartoDB.Positron&#34;,&#34;CartoDB.Positron&#34;,{&#34;errorTileUrl&#34;:&#34;&#34;,&#34;noWrap&#34;:false,&#34;detectRetina&#34;:false,&#34;pane&#34;:&#34;tilePane&#34;,&#34;maxZoom&#34;:24}]},{&#34;method&#34;:&#34;addProviderTiles&#34;,&#34;args&#34;:[&#34;OpenStreetMap&#34;,&#34;OpenStreetMap&#34;,&#34;OpenStreetMap&#34;,{&#34;errorTileUrl&#34;:&#34;&#34;,&#34;noWrap&#34;:false,&#34;detectRetina&#34;:false,&#34;pane&#34;:&#34;tilePane&#34;,&#34;maxZoom&#34;:24}]},{&#34;method&#34;:&#34;addProviderTiles&#34;,&#34;args&#34;:[&#34;CartoDB.DarkMatter&#34;,&#34;CartoDB.DarkMatter&#34;,&#34;CartoDB.DarkMatter&#34;,{&#34;errorTileUrl&#34;:&#34;&#34;,&#34;noWrap&#34;:false,&#34;detectRetina&#34;:false,&#34;pane&#34;:&#34;tilePane&#34;,&#34;maxZoom&#34;:24}]},{&#34;method&#34;:&#34;addProviderTiles&#34;,&#34;args&#34;:[&#34;Esri.WorldImagery&#34;,&#34;Esri.WorldImagery&#34;,&#34;Esri.WorldImagery&#34;,{&#34;errorTileUrl&#34;:&#34;&#34;,&#34;noWrap&#34;:false,&#34;detectRetina&#34;:false,&#34;pane&#34;:&#34;tilePane&#34;,&#34;maxZoom&#34;:24}]},{&#34;method&#34;:&#34;addProviderTiles&#34;,&#34;args&#34;:[&#34;OpenTopoMap&#34;,&#34;OpenTopoMap&#34;,&#34;OpenTopoMap&#34;,{&#34;errorTileUrl&#34;:&#34;&#34;,&#34;noWrap&#34;:false,&#34;detectRetina&#34;:false,&#34;pane&#34;:&#34;tilePane&#34;,&#34;maxZoom&#34;:24}]},{&#34;method&#34;:&#34;addLayersControl&#34;,&#34;args&#34;:[[&#34;CartoDB.Positron&#34;,&#34;OpenStreetMap&#34;,&#34;CartoDB.DarkMatter&#34;,&#34;Esri.WorldImagery&#34;,&#34;OpenTopoMap&#34;],[],{&#34;collapsed&#34;:true,&#34;autoZIndex&#34;:true,&#34;position&#34;:&#34;topleft&#34;}]},{&#34;method&#34;:&#34;addScaleBar&#34;,&#34;args&#34;:[{&#34;maxWidth&#34;:100,&#34;metric&#34;:true,&#34;imperial&#34;:true,&#34;updateWhenIdle&#34;:true,&#34;position&#34;:&#34;bottomleft&#34;}]},{&#34;method&#34;:&#34;addTiles&#34;,&#34;args&#34;:[&#34;https://earthengine.googleapis.com/v1alpha/projects/earthengine-legacy/maps/a008b4a6531d66c1e0fee8a84fcedf1a-7e25cf32d0ae2ad12dc053f93fb31cc4/tiles/{z}/{x}/{y}&#34;,&#34;GFS&#34;,&#34;GFS&#34;,{&#34;minZoom&#34;:0,&#34;maxZoom&#34;:24,&#34;tileSize&#34;:256,&#34;subdomains&#34;:&#34;abc&#34;,&#34;errorTileUrl&#34;:&#34;&#34;,&#34;tms&#34;:false,&#34;noWrap&#34;:false,&#34;zoomOffset&#34;:0,&#34;zoomReverse&#34;:false,&#34;opacity&#34;:1,&#34;zIndex&#34;:1,&#34;detectRetina&#34;:false}]},{&#34;method&#34;:&#34;addLayersControl&#34;,&#34;args&#34;:[[&#34;CartoDB.Positron&#34;,&#34;OpenStreetMap&#34;,&#34;CartoDB.DarkMatter&#34;,&#34;Esri.WorldImagery&#34;,&#34;OpenTopoMap&#34;],&#34;GFS&#34;,{&#34;collapsed&#34;:true,&#34;autoZIndex&#34;:true,&#34;position&#34;:&#34;topleft&#34;}]},{&#34;method&#34;:&#34;hideGroup&#34;,&#34;args&#34;:[null]},{&#34;method&#34;:&#34;addLegend&#34;,&#34;args&#34;:[{&#34;colors&#34;:[&#34;#053061 , #154D8A 5.55555555555556%, #3984BB 16.6666666666667%, #82BAD8 27.7777777777778%, #CAE1EE 38.8888888888889%, #F7F7F7 50%, #FDD5BF 61.1111111111111%, #EE9676 72.2222222222222%, #CA4C41 83.3333333333333%, #900C26 94.4444444444444%, #67001F &#34;],&#34;labels&#34;:[&#34;-40&#34;,&#34;-30&#34;,&#34;-20&#34;,&#34;-10&#34;,&#34;0&#34;,&#34;10&#34;,&#34;20&#34;,&#34;30&#34;,&#34;40&#34;],&#34;na_color&#34;:null,&#34;na_label&#34;:&#34;NA&#34;,&#34;opacity&#34;:1,&#34;position&#34;:&#34;bottomright&#34;,&#34;type&#34;:&#34;numeric&#34;,&#34;title&#34;:&#34;Temperatura máxima&#34;,&#34;extra&#34;:{&#34;p_1&#34;:0.0555555555555556,&#34;p_n&#34;:0.944444444444444},&#34;layerId&#34;:null,&#34;className&#34;:&#34;info legend&#34;,&#34;group&#34;:null}]}],&#34;setView&#34;:[[0,0],1,[]]},&#34;evals&#34;:[],&#34;jsHooks&#34;:{&#34;render&#34;:[{&#34;code&#34;:&#34;function(el, x, data) {\n  return (\n      function(el, x, data) {\n      // get the leaflet map\n      var map = this; //HTMLWidgets.find(&#39;#&#39; + el.id);\n      // we need a new div element because we have to handle\n      // the mouseover output separately\n      // debugger;\n      function addElement () {\n      // generate new div Element\n      var newDiv = $(document.createElement(&#39;div&#39;));\n      // append at end of leaflet htmlwidget container\n      $(el).append(newDiv);\n      //provide ID and style\n      newDiv.addClass(&#39;lnlt&#39;);\n      newDiv.css({\n      &#39;position&#39;: &#39;relative&#39;,\n      &#39;bottomleft&#39;:  &#39;0px&#39;,\n      &#39;background-color&#39;: &#39;rgba(255, 255, 255, 0.7)&#39;,\n      &#39;box-shadow&#39;: &#39;0 0 2px #bbb&#39;,\n      &#39;background-clip&#39;: &#39;padding-box&#39;,\n      &#39;margin&#39;: &#39;0&#39;,\n      &#39;padding-left&#39;: &#39;5px&#39;,\n      &#39;color&#39;: &#39;#333&#39;,\n      &#39;font&#39;: &#39;9px/1.5 \&#34;Helvetica Neue\&#34;, Arial, Helvetica, sans-serif&#39;,\n      &#39;z-index&#39;: &#39;700&#39;,\n      });\n      return newDiv;\n      }\n\n\n      // check for already existing lnlt class to not duplicate\n      var lnlt = $(el).find(&#39;.lnlt&#39;);\n\n      if(!lnlt.length) {\n      lnlt = addElement();\n\n      // grab the special div we generated in the beginning\n      // and put the mousmove output there\n\n      map.on(&#39;mousemove&#39;, function (e) {\n      if (e.originalEvent.ctrlKey) {\n      if (document.querySelector(&#39;.lnlt&#39;) === null) lnlt = addElement();\n      lnlt.text(\n                           &#39; lon: &#39; + (e.latlng.lng).toFixed(5) +\n                           &#39; | lat: &#39; + (e.latlng.lat).toFixed(5) +\n                           &#39; | zoom: &#39; + map.getZoom() +\n                           &#39; | x: &#39; + L.CRS.EPSG3857.project(e.latlng).x.toFixed(0) +\n                           &#39; | y: &#39; + L.CRS.EPSG3857.project(e.latlng).y.toFixed(0) +\n                           &#39; | epsg: 3857 &#39; +\n                           &#39; | proj4: +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs &#39;);\n      } else {\n      if (document.querySelector(&#39;.lnlt&#39;) === null) lnlt = addElement();\n      lnlt.text(\n                      &#39; lon: &#39; + (e.latlng.lng).toFixed(5) +\n                      &#39; | lat: &#39; + (e.latlng.lat).toFixed(5) +\n                      &#39; | zoom: &#39; + map.getZoom() + &#39; &#39;);\n      }\n      });\n\n      // remove the lnlt div when mouse leaves map\n      map.on(&#39;mouseout&#39;, function (e) {\n      var strip = document.querySelector(&#39;.lnlt&#39;);\n      if( strip !==null) strip.remove();\n      });\n\n      };\n\n      //$(el).keypress(67, function(e) {\n      map.on(&#39;preclick&#39;, function(e) {\n      if (e.originalEvent.ctrlKey) {\n      if (document.querySelector(&#39;.lnlt&#39;) === null) lnlt = addElement();\n      lnlt.text(\n                      &#39; lon: &#39; + (e.latlng.lng).toFixed(5) +\n                      &#39; | lat: &#39; + (e.latlng.lat).toFixed(5) +\n                      &#39; | zoom: &#39; + map.getZoom() + &#39; &#39;);\n      var txt = document.querySelector(&#39;.lnlt&#39;).textContent;\n      console.log(txt);\n      //txt.innerText.focus();\n      //txt.select();\n      setClipboardText(&#39;\&#34;&#39; + txt + &#39;\&#34;&#39;);\n      }\n      });\n\n      }\n      ).call(this.getMap(), el, x, data);\n}&#34;,&#34;data&#34;:null},{&#34;code&#34;:&#34;function(el, x, data) {\n  return (function(el,x,data){\n           var map = this;\n\n           map.on(&#39;keypress&#39;, function(e) {\n               console.log(e.originalEvent.code);\n               var key = e.originalEvent.code;\n               if (key === &#39;KeyE&#39;) {\n                   var bb = this.getBounds();\n                   var txt = JSON.stringify(bb);\n                   console.log(txt);\n\n                   setClipboardText(&#39;\\&#39;&#39; + txt + &#39;\\&#39;&#39;);\n               }\n           })\n        }).call(this.getMap(), el, x, data);\n}&#34;,&#34;data&#34;:null}]}}&lt;/script&gt;
&lt;/div&gt;
&lt;div id=&#34;exportar-múltiples-imagenes&#34; class=&#34;section level2&#34; number=&#34;2.4&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.4&lt;/span&gt; Exportar múltiples imagenes&lt;/h2&gt;
&lt;p&gt;El paquete &lt;code&gt;{rgee}&lt;/code&gt; tiene una función muy útil para exportar una &lt;em&gt;ImageCollection&lt;/em&gt;: &lt;code&gt;ee_imagecollection_to_local()&lt;/code&gt;. Antes de usarla debemos fijar una región, la que se pretende exportar. En este caso, exportamos todo el globo con un rectángulo cubriendo la Tierra.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# extensión de la Tierra
geom &amp;lt;- ee$Geometry$Polygon(coords = list(
  c(-180, -90), 
  c(180, -90),
  c(180, 90),
  c(-180, 90),
  c(-180, -90)
),
proj = &amp;quot;EPSG:4326&amp;quot;,
geodesic = FALSE)

geom #vemos que es un objeto EarthEngine de tipo geometría&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## EarthEngine Object: Geometry&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# carpeta temporal de descarga
tmp &amp;lt;- tempdir()

# descargamos 
ic_drive_files_2 &amp;lt;- ee_imagecollection_to_local(
  ic = daily$filter(ee$Filter$date(rdate_to_eedate(today()), rdate_to_eedate(today()+days(2)))), # elegimos los próximos 4 días
  region = geom,
  scale = 20000, 
  lazy = FALSE,
  dsn = path(tmp, &amp;quot;drive_&amp;quot;),
  add_metadata = TRUE
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ───────────────────────────────────── Downloading ImageCollection - via drive ──- region parameters
##  sfg      : POLYGON ((-180 -90, 180 -90, 180 90, -180 90, -180 -90)) 
##  CRS      : GEOGCRS[&amp;quot;WGS 84&amp;quot;,
##     DATUM[&amp;quot;World Geodetic System 1984&amp;quot;,
##         ELLIPSOID[&amp;quot;WGS 84&amp;quot;,6378137,298.257223563, ..... 
##  geodesic : FALSE 
##  evenOdd  : TRUE 
## 
## Downloading: C:/Users/xeo19/AppData/Local/Temp/RtmpE9IUrn/drive_0.tif
## Downloading: C:/Users/xeo19/AppData/Local/Temp/RtmpE9IUrn/drive_1.tif
##  ────────────────────────────────────────────────────────────────────────────────&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;parte-ii.-visualización-en-forma-de-un-globo&#34; class=&#34;section level1&#34; number=&#34;3&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;3&lt;/span&gt; Parte II. Visualización en forma de un globo&lt;/h1&gt;
&lt;div id=&#34;datos&#34; class=&#34;section level2&#34; number=&#34;3.1&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.1&lt;/span&gt; Datos&lt;/h2&gt;
&lt;p&gt;El primer paso consiste en importar los datos con ayuda de &lt;code&gt;rast()&lt;/code&gt;. Además definimos el nombre de cada capa según su dimensión temporal correctamente.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# rutas a los datos descargados
forecast_world &amp;lt;- dir_ls(tmp, regexp = &amp;quot;tif&amp;quot;)

# garantizamos el orden y importamos
file_ord &amp;lt;- str_extract(forecast_world, &amp;quot;_[0-9]{1,2}&amp;quot;) |&amp;gt; parse_number()

forecast_rast &amp;lt;- rast(forecast_world[order(file_ord)])
forecast_rast&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class       : SpatRaster 
## dimensions  : 1002, 2004, 2  (nrow, ncol, nlyr)
## resolution  : 0.1796631, 0.1796631  (x, y)
## extent      : -180.0224, 180.0224, -90.01119, 90.01119  (xmin, xmax, ymin, ymax)
## coord. ref. : lon/lat WGS 84 (EPSG:4326) 
## sources     : drive_0.tif  
##               drive_1.tif  
## names       : temperature_2m_above_ground, temperature_2m_above_ground&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# definimos la dimensión temporal como nombre de cada capa
names(forecast_rast) &amp;lt;- seq(today(), today() + days(1), &amp;quot;day&amp;quot;)
forecast_rast&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class       : SpatRaster 
## dimensions  : 1002, 2004, 2  (nrow, ncol, nlyr)
## resolution  : 0.1796631, 0.1796631  (x, y)
## extent      : -180.0224, 180.0224, -90.01119, 90.01119  (xmin, xmax, ymin, ymax)
## coord. ref. : lon/lat WGS 84 (EPSG:4326) 
## sources     : drive_0.tif  
##               drive_1.tif  
## names       : 2023-02-23, 2023-02-24&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# ploteamos
plot(forecast_rast)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Ahora debemos definir la proyección ortográfica indicando con +lat_0 y +lon_0 el centro de la proyección. Después reproyectamos y convertimos el ráster en un &lt;em&gt;data.frame&lt;/em&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# definición de la proyección 
ortho_crs &amp;lt;-&amp;#39;+proj=ortho +lat_0=51 +lon_0=0.5 +x_0=0 +y_0=0 +R=6371000 +units=m +no_defs +type=crs&amp;#39;

# reproyectamos el ráster
ras_ortho &amp;lt;- project(forecast_rast, ortho_crs)

# convertimos el ráster en un data.frame de xyz
forecast_df &amp;lt;- as.data.frame(ras_ortho, xy = TRUE)

# transformamos a un formato largo
forecast_df &amp;lt;- pivot_longer(forecast_df, 3:length(forecast_df), names_to = &amp;quot;date&amp;quot;, values_to = &amp;quot;ta&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;límites-administrativos-y-retícula&#34; class=&#34;section level2&#34; number=&#34;3.2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.2&lt;/span&gt; Límites administrativos y retícula&lt;/h2&gt;
&lt;p&gt;Importamos los límites administrativos con &lt;code&gt;gisco_get_countries()&lt;/code&gt; los que debemos preparar para la proyección ortográfica. Del mismo modo creamos la retícula empleando &lt;code&gt;st_graticule()&lt;/code&gt;. Con el objetivo de preservar la geometría habrá que recortar a únicamente la parte visible. El océano se crea partiendo de un punto en 0,0 con el radio de la tierra. Empleando la función &lt;code&gt;st_intersection()&lt;/code&gt; reducimos a la parte visible y reproyectamos los límites.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# obtenemos los límites administrativos
world_poly &amp;lt;- gisco_get_countries(year = &amp;quot;2016&amp;quot;, epsg = &amp;quot;4326&amp;quot;, resolution = &amp;quot;10&amp;quot;) 

# obtenemos la retícula global
grid &amp;lt;- st_graticule()

# definimos lo que sería oceano 
ocean &amp;lt;- st_point(x = c(0,0)) |&amp;gt;
            st_buffer(dist = 6371000) |&amp;gt; # radio de la tierra
              st_sfc(crs = ortho_crs)
plot(ocean)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# seleccionamos sólo visible de los límites y reproyectamos
world &amp;lt;- world_poly |&amp;gt;
            st_intersection(st_transform(ocean, 4326)) |&amp;gt;
            st_transform(crs = ortho_crs) # 
plot(world)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/figure-html/unnamed-chunk-14-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Debemos repetir la misma selección visible para la retícula, aunque aquí antes limitamos las líneas de la retícula a los océanos. El límite del océano nos sirve para crear la sombra del globo, pero para usarlo en &lt;code&gt;geom_glowpath()&lt;/code&gt; es necesario convertirlo en un &lt;em&gt;data.frame&lt;/em&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# eliminamos las líneas que transcurren sobre los continentes
grid_crp &amp;lt;- st_difference(grid, st_union(world_poly))

# seleccionamos la parte visible
grid_crp &amp;lt;- st_intersection(grid_crp, st_transform(ocean, 4326)) |&amp;gt;
                  st_transform(crs = ortho_crs)

plot(grid_crp)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# convertimos el límite del globo en un data.frame
ocean_df &amp;lt;- st_cast(ocean, &amp;quot;LINESTRING&amp;quot;) |&amp;gt; st_coordinates() |&amp;gt; as.data.frame()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;construcción-del-mapa&#34; class=&#34;section level2&#34; number=&#34;3.3&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.3&lt;/span&gt; Construcción del mapa&lt;/h2&gt;
&lt;div id=&#34;selecionar-mañana&#34; class=&#34;section level3&#34; number=&#34;3.3.1&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.3.1&lt;/span&gt; Selecionar mañana&lt;/h3&gt;
&lt;p&gt;Primero seleccionamos el día de mañana, en mi caso cuando escribo este post es el 23 de febrero de 2023. Además, limitamos el rango de valores a -45ºC hasta +45ºC.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;forecast_tomorrow &amp;lt;- filter(forecast_df, date == today()+days(1)) |&amp;gt;
                        mutate(ta_limit = case_when(ta &amp;gt; 45 ~ 45,
                                              ta &amp;lt; -45 ~ -45,
                                               TRUE ~ ta))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;la-sombra-del-globo&#34; class=&#34;section level3&#34; number=&#34;3.3.2&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.3.2&lt;/span&gt; La sombra del globo&lt;/h3&gt;
&lt;p&gt;El efecto de sombra lo creamos usando la función &lt;code&gt;geom_glowpath()&lt;/code&gt; del paquete &lt;code&gt;{ggshadow}&lt;/code&gt;. Con el objetivo de una transición suave duplico esta capa con diferentes parámetros de transparencia y tamaño de sombra.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# construimos una sombra 
ggplot() + 
   geom_glowpath(data = ocean_df, 
                aes(X, Y, group = &amp;quot;L1&amp;quot;),
                shadowcolor=&amp;#39;grey90&amp;#39;,
                     colour = &amp;quot;white&amp;quot;,
                alpha = .01,
                shadowalpha=0.05,
                shadowsize = 1.5) +
   coord_sf() +
   theme_void()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# combinando varias capas de sobra
g &amp;lt;- ggplot() +
   geom_glowpath(data = ocean_df, 
                aes(X, Y, group = &amp;quot;L1&amp;quot;),
                shadowcolor=&amp;#39;grey90&amp;#39;,
                     colour = &amp;quot;white&amp;quot;,
                alpha = .01,
                shadowalpha=0.05,
                shadowsize = 1.8) +
   geom_glowpath(data = ocean_df, 
                aes(X, Y, group = &amp;quot;L1&amp;quot;),
                shadowcolor=&amp;#39;grey90&amp;#39;,
                       colour = &amp;quot;white&amp;quot;,
                alpha = .01,
                shadowalpha=0.02,
                shadowsize = 1) +
   geom_glowpath(data = ocean_df, 
                aes(X, Y, group = &amp;quot;L1&amp;quot;),
                shadowcolor=&amp;#39;grey90&amp;#39;,
                       colour = &amp;quot;white&amp;quot;,
                alpha = .01,
                shadowalpha=0.01,
                shadowsize = .5) &lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;otras-capas-del-mapa&#34; class=&#34;section level3&#34; number=&#34;3.3.3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.3.3&lt;/span&gt; Otras capas del mapa&lt;/h3&gt;
&lt;p&gt;En el próximo paso añadimos la capa de la temperatura de mañana y ambas capas vectoriales.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;g2 &amp;lt;- g + geom_raster(data = forecast_tomorrow, aes(x, y, fill = ta_limit)) +
          geom_sf(data = grid_crp, 
                  colour = &amp;quot;white&amp;quot;, 
                  linewidth = .2) +
          geom_sf(data = world, 
                   fill = NA,
                   colour = &amp;quot;grey10&amp;quot;,
                   linewidth = .2) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lo que nos falta por añadir son últimas definiciones de color, de la leyenda y el estilo general del mapa.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;g2 + scale_fill_distiller(palette = &amp;quot;RdBu&amp;quot;, 
                          limits = c(-45, 45),
                          breaks = c(-45, -25, 0, 25, 45)) +
     guides(fill = guide_colourbar(barwidth = 15, 
                                   barheight = .5, 
                                   title.position = &amp;quot;top&amp;quot;,
                                   title.hjust = .5)) +
  coord_sf() +
  labs(fill = str_wrap(&amp;quot;Temperatura máxima a 2 metros para el 14 de febrero&amp;quot;, 30)) +
  theme_void() +
  theme(legend.position = &amp;quot;bottom&amp;quot;,
        legend.title = element_text(size = 7),
        plot.margin = margin(10, 10, 10, 10)) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/figure-html/unnamed-chunk-19-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Si quisiéramos añadir etiquetas de los puntos con la temperatura más baja y más alta, necesitamos filtrar los extremos a partir de nuestra tabla.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;labeling &amp;lt;- slice(forecast_tomorrow, which.min(ta), which.max(ta))
labeling&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 5
##           x         y date          ta ta_limit
##       &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
## 1 -1397101.  3923352. 2023-02-24 -42.5    -42.5
## 2  2119554. -4121598. 2023-02-24  43.9     43.9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La función &lt;code&gt;geom_mark_circle()&lt;/code&gt; permite incluir una etiqueta con un círculo a cualquier posición. La etiqueta la creamos usando &lt;code&gt;str_glue()&lt;/code&gt; donde la variable será sustituida por cada temperatura de ambos extremos, al mismo tiempo podemos definir el formato de la cifra con &lt;code&gt;number()&lt;/code&gt; del paquete &lt;code&gt;{scales}&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;g2 +  geom_mark_circle(data = labeling, 
                       aes(x, y, 
                          description = str_glue(&amp;#39;{scales::number(ta, accuracy = .1, decimal.mark = &amp;quot;,&amp;quot;, style_positive = &amp;quot;plus&amp;quot;, suffix = &amp;quot;ºC&amp;quot;)}&amp;#39;)
                          ), 
                   expand = unit(1, &amp;quot;mm&amp;quot;), 
                   label.buffer = unit(4, &amp;quot;mm&amp;quot;),
                   label.margin = margin(1, 1, 1, 1, &amp;quot;mm&amp;quot;),
                   con.size = 0.3,
                   label.fontsize = 8,
                   label.fontface = &amp;quot;bold&amp;quot;,
                   con.type = &amp;quot;straight&amp;quot;,
                  label.fill = alpha(&amp;quot;white&amp;quot;, .5)) +
     scale_fill_distiller(palette = &amp;quot;RdBu&amp;quot;, 
                          limits = c(-45, 45),
                          breaks = c(-45, -25, 0, 25, 45)) +
     guides(fill = guide_colourbar(barwidth = 15, 
                                   barheight = .5, 
                                   title.position = &amp;quot;top&amp;quot;,
                                   title.hjust = .5)) +
  coord_sf(crs = ortho_crs) +
  labs(fill = str_wrap(&amp;quot;Temperatura mínima 2 metros para el 14 de febrero&amp;quot;, 30)) +
  theme_void() +
  theme(legend.position = &amp;quot;bottom&amp;quot;,
        legend.title = element_text(size = 7),
        plot.margin = margin(10, 10, 10, 10)) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2023/el-tiempo-de-manana/index.es_files/figure-html/unnamed-chunk-21-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.buymeacoffee.com/drxeo&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://cdn.buymeacoffee.com/buttons/default-orange.png&#34; alt=&#34;Buy Me A Coffee&#34; height=&#34;41&#34; width=&#34;174&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Efecto hillshade o sombras de laderas</title>
      <link>https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/</link>
      <pubDate>Wed, 20 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/</guid>
      <description>


&lt;p&gt;Es muy habitual ver mapas de relieve con efectos de sombras, también conocidos como ‘hillshade’ lo que genera una profundidad visual. ¿Cómo podemos crear estos efectos en R y visualizarlos en ggplot2?&lt;/p&gt;
&lt;div id=&#34;paquetes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Paquetes&lt;/h1&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;8%&#34; /&gt;
&lt;col width=&#34;91%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Paquete&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tidyverse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Conjunto de paquetes (visualización y manipulación de datos): ggplot2, dplyr, purrr,etc.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Simple Feature: importar, exportar y manipular datos vectoriales&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;elevatr&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Acceso a datos de elevación desde varias API&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;terra&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Importar, exportar y manipular raster (paquete sucesor de raster)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;whitebox&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Una interfaz R para la biblioteca ‘WhiteboxTools’, que es una plataforma avanzada de análisis de datos geoespaciales&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tidyterra&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Funciones auxilares para trabajar con {terra}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;giscoR&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Límites administrativos del mundo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ggnewscale&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Extensión para ggplot2 de múltiples ‘scales’&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# instalamos los paquetes si hace falta

if(!require(&amp;quot;tidyverse&amp;quot;)) install.packages(&amp;quot;tidyverse&amp;quot;)
if(!require(&amp;quot;sf&amp;quot;)) install.packages(&amp;quot;sf&amp;quot;)
if(!require(&amp;quot;elevatr&amp;quot;)) install.packages(&amp;quot;elevatr&amp;quot;)
if(!require(&amp;quot;terra&amp;quot;)) install.packages(&amp;quot;terra&amp;quot;)
if(!require(&amp;quot;whitebox&amp;quot;)) install.packages(&amp;quot;whitebox&amp;quot;)
if(!require(&amp;quot;tidyterra&amp;quot;)) install.packages(&amp;quot;tidyterra&amp;quot;)
if(!require(&amp;quot;giscoR&amp;quot;)) install.packages(&amp;quot;giscoR&amp;quot;)
if(!require(&amp;quot;ggnewscale&amp;quot;)) install.packages(&amp;quot;ggnewscale&amp;quot;)

# paquetes
library(sf)
library(elevatr)
library(tidyverse)
library(terra)
library(whitebox)
library(ggnewscale)
library(tidyterra)
library(giscoR)
library(units)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;datos&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Datos&lt;/h1&gt;
&lt;p&gt;Como área de interés usamos Suiza en este ejemplo. Con excepción de los límites de lagos &lt;a href=&#34;https://dominicroye.github.io/files/switzerland_lakes.zip&#34;&gt;descarga&lt;/a&gt;, los datos necesarios los obtenemos a través de APIs usando diferentes paquetes. El paquete &lt;code&gt;giscoR&lt;/code&gt; permite obtener los límites de países con diferentes resoluciones.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;suiz &amp;lt;- gisco_get_countries(country = &amp;quot;Switzerland&amp;quot;, resolution = &amp;quot;03&amp;quot;)

plot(suiz)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/index.es_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Los límites de los lagos corresponden a una capa de modelos cartográficos digitales (DKM500) que ofrece &lt;a href=&#34;https://www.swisstopo.admin.ch/&#34;&gt;swisstopo&lt;/a&gt;. El objetivo es quedar sólo con los grandes lagos, por tanto excluimos todos aquellos con menos de 50 km2 y también aquellos situados completamente en territorio italiano. Recuerda que con el paquete &lt;code&gt;units&lt;/code&gt; podemos indicar unidades y así hacer cálculos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# importamos los lagos
suiz_lakes &amp;lt;- st_read(&amp;quot;22_DKM500_GEWAESSER_PLY.shp&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Reading layer `22_DKM500_GEWAESSER_PLY&amp;#39; from data source 
##   `E:\GitHub\blog_update_2021\content\es\post\2022-07-19-hillshade-effect\22_DKM500_GEWAESSER_PLY.shp&amp;#39; 
##   using driver `ESRI Shapefile&amp;#39;
## Simple feature collection with 596 features and 14 fields
## Geometry type: POLYGON
## Dimension:     XY
## Bounding box:  xmin: 2480000 ymin: 1062000 xmax: 2865000 ymax: 1302000
## Projected CRS: CH1903+ / LV95&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# filtramos a grandes lagos
suiz_lakes &amp;lt;- mutate(suiz_lakes, areakm = set_units(SHP_AREA, &amp;quot;m2&amp;quot;) %&amp;gt;% 
                                          set_units(&amp;quot;km2&amp;quot;)) %&amp;gt;% 
                filter(areakm &amp;gt; set_units(50, &amp;quot;km2&amp;quot;),
                       !NAMN1 %in% c(&amp;quot;Lago di Como / Lario&amp;quot;,
                                     &amp;quot;Lago d&amp;#39;Iseo&amp;quot;,
                                     &amp;quot;Lago di Garda&amp;quot;))
plot(suiz_lakes)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: plotting the first 9 out of 15 attributes; use max.plot = 15 to plot
## all&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/index.es_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;modelo-digital-de-terreno-mdt&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Modelo digital de terreno (MDT)&lt;/h1&gt;
&lt;p&gt;La función &lt;code&gt;get_elev_raster()&lt;/code&gt; nos permite descargar un MDT de cualquier región del mundo a través de diferentes proveedores en formato de ráster. Por defecto usa &lt;a href=&#34;https://registry.opendata.aws/terrain-tiles/&#34;&gt;AWS&lt;/a&gt;. Un argumento esencial es la resolución que depende de la latitud, la que se puede indicar como nivel de zoom (véase la ayuda). Por ejemplo, aquí usamos nivel 10 que a una latitud de 45º correspondería a aproximadamente 100m.&lt;/p&gt;
&lt;p&gt;Después de obtener el MDT de Suiza debemos enmascarar los límites del país. La clase del objeto es &lt;em&gt;RasterLayer&lt;/em&gt; del paquete &lt;code&gt;raster&lt;/code&gt;, no obstante, el nuevo estándar es &lt;code&gt;terra&lt;/code&gt; con la clase &lt;em&gt;SpatRaster&lt;/em&gt;. Por eso lo convertimos y después aplicamos la máscara. Finalmente reproyectamos al sistema de coordenadas de Suiza obtenido de los datos vectoriales.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# obtenemos el mdt con 
mdt &amp;lt;- get_elev_raster(suiz, z = 10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Mosaicing &amp;amp; Projecting&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Note: Elevation units are in meters.&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mdt # clase antigua de RasterLayer&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class      : RasterLayer 
## dimensions : 3869, 7913, 30615397  (nrow, ncol, ncell)
## resolution : 0.0006219649, 0.0006219649  (x, y)
## extent     : 5.625, 10.54661, 45.58354, 47.98992  (xmin, xmax, ymin, ymax)
## crs        : +proj=longlat +datum=WGS84 +no_defs 
## source     : file3f7c489b49.tif 
## names      : file3f7c489b49 
## values     : -32768, 32767  (min, max)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(mdt)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/index.es_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# convertir a terra y enmascarar la zona de interés
mdt &amp;lt;- rast(mdt) %&amp;gt;% 
         mask(vect(suiz)) 

# reproyectamos
mdt &amp;lt;- project(mdt, crs(suiz_lakes))

# reproyectamos 
suiz &amp;lt;- st_transform(suiz, st_crs(suiz_lakes))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Antes de calcular el efecto de sombra, creamos un simple mapa de relieve. En &lt;code&gt;ggplot2&lt;/code&gt; empleamos la geometría &lt;code&gt;geom_raster()&lt;/code&gt; indicando la longitud, latitud y la variable para definir el color. Añadimos los límites de los lagos usando &lt;code&gt;geom_sf()&lt;/code&gt; dado que se trata de un objeto &lt;em&gt;sf&lt;/em&gt;. Aquí sólo indicamos el color de relleno con un azul claro. Con ayuda de &lt;code&gt;scale_fill_hypso_tint_c()&lt;/code&gt; aplicamos una gama de colores correspondientes a un relieve, también llamado tintas hipsométricas, y definimos los cortes en la leyenda. En el resto de funciones hacemos ajustes de aspecto en la leyenda y en el estilo del gráfico.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# convertimos nuestro ráster en data.frame de xyz
mdtdf &amp;lt;- as.data.frame(mdt, xy = TRUE)
names(mdtdf)[3] &amp;lt;- &amp;quot;alt&amp;quot;

# mapa
ggplot() +
  geom_raster(data = mdtdf,
              aes(x, y, fill = alt)) +
   geom_sf(data = suiz_lakes,
          fill = &amp;quot;#c6dbef&amp;quot;, 
          colour = NA) +
  scale_fill_hypso_tint_c(breaks = c(180, 250, 500, 1000,
                                     1500,  2000, 2500,
                                     3000, 3500, 4000)) +
  guides(fill = guide_colorsteps(barwidth = 20,
                                 barheight = .5,
                                 title.position = &amp;quot;right&amp;quot;)) +
  labs(fill = &amp;quot;m&amp;quot;) +
  coord_sf() +
  theme_void() +
  theme(legend.position = &amp;quot;bottom&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 1 rows containing missing values (geom_raster).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/index.es_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;calcular-el-hillshade&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Calcular el hillshade&lt;/h1&gt;
&lt;p&gt;Recordemos que el efecto hillshade es nada más que añadir una iluminación hipotética con respecto a una posición de una fuente de luz para así ganar profundidad. Las sombras dependen de dos variables, el acimut, el ángulo de la orientación sobra la superficie de una esfera, y la elevación, el ángulo de la altura de la fuente.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;hillshade_effect.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;La información requerida para simular la iluminación es el modelo digital de terreno. La pendiente y la orientación podemos derivar del MDT usando la función &lt;code&gt;terrain()&lt;/code&gt; del paquete &lt;code&gt;terra&lt;/code&gt;. La unidad debe ser radianes. Una vez que tenemos todos los datos podemos hacer uso de la función &lt;code&gt;shade()&lt;/code&gt; indicando el ángulo (elevación) y la dirección (acimut). El resultado es un ráster con valores entre 0 y 255, lo que nos indica sombras con bajos valores, siendo 0 negro y 255 blanco.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# estimamos la pendiente
sl &amp;lt;- terrain(mdt, &amp;quot;slope&amp;quot;, unit = &amp;quot;radians&amp;quot;)
plot(sl)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/index.es_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# estimamos la orientación
asp &amp;lt;- terrain(mdt, &amp;quot;aspect&amp;quot;, unit = &amp;quot;radians&amp;quot;)
plot(asp)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/index.es_files/figure-html/unnamed-chunk-7-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calculamos el efecto hillshade con 45º de elevación 
hill_single &amp;lt;- shade(sl, asp, 
      angle = 45, 
      direction = 300,
      normalize= TRUE)

# resultado final hillshade 
plot(hill_single, col = grey(1:100/100))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/index.es_files/figure-html/unnamed-chunk-7-3.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;combinar-el-relieve-y-el-efecto-de-sombra&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Combinar el relieve y el efecto de sombra&lt;/h1&gt;
&lt;p&gt;El problema para añadir al mismo tiempo el relieve con su tinta hipsométrica y el efecto hillshade dentro de &lt;code&gt;ggplot2&lt;/code&gt; es que tenemos dos diferentes rellenos para cada capa.
La solución consiste en usar la extensión &lt;code&gt;ggnewscale&lt;/code&gt; que permite añadir múltiples &lt;em&gt;scales&lt;/em&gt;. Primero añadimos con &lt;code&gt;geom_raster()&lt;/code&gt; el hillshade, después definimos los tonos grises y antes de añadir la altitud incluimos la función &lt;code&gt;new_scale_fill()&lt;/code&gt; para marcar otro relleno diferente. Para lograr el efecto es necesario dar un grado de transparencia a la capa del relieve, en este caso es del 70%. La elección de la dirección es importante, de ahí que debemos tener en cuenta siempre el lugar y el recorrido aparente del sol. (&lt;a href=&#34;https://www.sunearthtools.com/dp/tools/pos_sun.php?lang=es&#34;&gt;sunearthtools&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# convertimos el hillshade a xyz
hilldf_single &amp;lt;- as.data.frame(hill_single, xy = TRUE)

# mapa 
ggplot() +
  geom_raster(data = hilldf_single,
              aes(x, y, fill = lyr1),
              show.legend = FALSE) +
  scale_fill_distiller(palette = &amp;quot;Greys&amp;quot;) +
  new_scale_fill() +
  geom_raster(data = mdtdf,
              aes(x, y, fill = alt),
              alpha = .7) +
  scale_fill_hypso_tint_c(breaks = c(180, 250, 500, 1000,
                                     1500,  2000, 2500,
                                     3000, 3500, 4000)) +
  geom_sf(data = suiz_lakes,
          fill = &amp;quot;#c6dbef&amp;quot;, colour = NA) +
  guides(fill = guide_colorsteps(barwidth = 20,
                                 barheight = .5,
                                 title.position = &amp;quot;right&amp;quot;)) +
  labs(fill = &amp;quot;m&amp;quot;) +
  coord_sf() +
  theme_void() +
  theme(legend.position = &amp;quot;bottom&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/index.es_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;sombras-multidireccionales&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Sombras multidireccionales&lt;/h1&gt;
&lt;p&gt;Lo que hemos visto es un efecto unidireccional, aunque es lo más habitual, podemos crear un efecto más suave e incluso más realista combinando varias direcciones.&lt;/p&gt;
&lt;p&gt;Simplemente mapeamos sobre un vector de varias direcciones al que se aplica la función &lt;code&gt;shade()&lt;/code&gt; con una elevación fija. Después convertimos la lista de ráster en un objeto multidimensional de varias capas para reducirlas sumando todas las capas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# pasamos varias direcciones a shade()
hillmulti &amp;lt;- map(c(270, 15, 60, 330), function(dir){ 
                    shade(sl, asp, 
                          angle = 45, 
                          direction = dir,
                          normalize= TRUE)}
  )

# creamos un raster multidimensional y lo reducimos sumando
hillmulti &amp;lt;- rast(hillmulti) %&amp;gt;% sum()

# multidireccional
plot(hillmulti, col = grey(1:100/100))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/index.es_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# unidireccional
plot(hill_single, col = grey(1:100/100))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/index.es_files/figure-html/unnamed-chunk-9-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Hacemos lo mismo como antes para visualizar el relieve con sombras multidireccionales.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# convertimos el hillshade a xyz
hillmultidf &amp;lt;- as.data.frame(hillmulti, xy = TRUE)

# mapa
ggplot() +
  geom_raster(data = hillmultidf,
              aes(x, y, fill = sum),
              show.legend = FALSE) +
  scale_fill_distiller(palette = &amp;quot;Greys&amp;quot;) +
  new_scale_fill() +
  geom_raster(data = mdtdf,
              aes(x, y, fill = alt),
              alpha = .7) +
  scale_fill_hypso_tint_c(breaks = c(180, 250, 500, 1000,
                                     1500,  2000, 2500,
                                     3000, 3500, 4000)) +
  geom_sf(data = suiz_lakes,
          fill = &amp;quot;#c6dbef&amp;quot;, colour = NA) +
  guides(fill = guide_colorsteps(barwidth = 20,
                                 barheight = .5,
                                 title.position = &amp;quot;right&amp;quot;)) +
  labs(fill = &amp;quot;m&amp;quot;) +
  coord_sf() +
  theme_void() +
    theme(legend.position = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 1 rows containing missing values (geom_raster).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/index.es_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;otra-alternativa-para-direcciones-multidireccionales&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Otra alternativa para direcciones multidireccionales&lt;/h1&gt;
&lt;p&gt;Con menos control sobre las direcciones también sería posible aplicar la función &lt;code&gt;wbt_multidirectional_hillshade()&lt;/code&gt; del paquete &lt;code&gt;whitebox&lt;/code&gt;. WhiteboxTool contiene muchas herramientas como plataforma avanzada de análisis de datos geoespaciales. La desventaja es que perdemos control sobre las direcciones y que también es necesario exportar el MDT a geotiff para obtener otro ráster con las sombras.&lt;/p&gt;
&lt;p&gt;Primero instalamos la librería con la función &lt;code&gt;install_whitebox()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# instalar whitebox
install_whitebox()&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exportamos el mdt
writeRaster(mdt, &amp;quot;mdt.tiff&amp;quot;, overwrite = TRUE)

# iniciamos whitebox
wbt_init()

# creamos el hillshade
wbt_multidirectional_hillshade(&amp;quot;mdt.tiff&amp;quot;,
                               &amp;quot;hillshade.tiff&amp;quot;)

# volvemos a importar el hillshade
hillwb &amp;lt;- rast(&amp;quot;hillshade.tiff&amp;quot;)
plot(hillwb)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/index.es_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# volver a enmascarar
hillwb &amp;lt;- mask(hillwb, vect(suiz))
plot(hillwb)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/index.es_files/figure-html/unnamed-chunk-12-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# convertimos el hillshade a xyz
hillwbdf &amp;lt;- as.data.frame(hillwb, xy = TRUE)

# mapa
ggplot() +
  geom_raster(data = hillwbdf,
              aes(x, y, fill = hillshade),
              show.legend = FALSE) +
  scale_fill_distiller(palette = &amp;quot;Greys&amp;quot;) +
  new_scale_fill() +
  geom_raster(data = mdtdf,
              aes(x, y, fill = alt),
              alpha = .7) +
  scale_fill_hypso_tint_c(breaks = c(180, 250, 500, 1000,
                                     1500,  2000, 2500,
                                     3000, 3500, 4000)) +
  guides(fill = guide_colorsteps(barwidth = 20,
                                 barheight = .5,
                                 title.position = &amp;quot;right&amp;quot;)) +
  labs(fill = &amp;quot;m&amp;quot;) +
  coord_sf() +
  theme_void()  +
  theme(legend.position = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 1 rows containing missing values (geom_raster).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/efecto-hillshade-o-sombras-de-laderas/index.es_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.buymeacoffee.com/drxeo&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://cdn.buymeacoffee.com/buttons/default-orange.png&#34; alt=&#34;Buy Me A Coffee&#34; height=&#34;41&#34; width=&#34;174&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Uso de datos multidimensionales espaciales</title>
      <link>https://dominicroye.github.io/es/2022/uso-de-datos-multidimensionales-espaciales/</link>
      <pubDate>Tue, 08 Mar 2022 00:00:00 +0000</pubDate>
      <guid>https://dominicroye.github.io/es/2022/uso-de-datos-multidimensionales-espaciales/</guid>
      <description>
&lt;script src=&#34;https://dominicroye.github.io/es/2022/uso-de-datos-multidimensionales-espaciales/index.es_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;div id=&#34;consideraciones-iniciales&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Consideraciones iniciales&lt;/h1&gt;
&lt;p&gt;La información espacio-temporal es clave en muchas disciplinas, especialmente en la climatología o la meteorología, y ello hace necesario disponer de un formato que permita una estructura multidimensional. Además es importante que ese formato tenga un alto grado de compatibilidad de intercambio y pueda almacenar un elevado número de datos. Estas características llevaron al desarrollo del estándar abierto netCDF (NetworkCommon Data Form). El formato netCDF es un estándar abierto de intercambio de datos científicos multidimensionales que se utiliza con datos de observaciones o modelos, principalmente en disciplinas como la climatología, la meteorología y la oceanografía. La convención netCDF es gestionada por Unidata (unidata.ucar.edu/software/netcdf). Se trata de un formato espacio-temporal con una cuadrícula regular o irregular. La estructura multidimensional en forma de matriz (array) permite usar no sólo datos espacio-temporales, sino también multivariables. Las características generales del netCDF se refieren al uso de un sistema de coordenadas n-dimensional, de múltiples variables y de una rejilla regular o irregular. Además se incluyen metadatos que describen los contenidos. La extensión del formato netCDF es “nc”.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;3d_ncdf.es.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Recientemente hice uso de datos de sequía de España en formato netCDF con una resolución de 1 km para representar el estado de sequía de cada año desde 1960 (&lt;a href=&#34;https://monitordesequia.csic.es/historico/&#34; class=&#34;uri&#34;&gt;https://monitordesequia.csic.es/historico/&lt;/a&gt;). El índice SPEI (Standardized Precipitation-Evapotranspiration Index) es ampliamente usado para describir la situación de sequía con referencia a diferentes intervalos temporales (3, 6, 12 meses etc).&lt;/p&gt;
&lt;p&gt;{{&amp;lt; tweet 1490260694851362821 &amp;gt;}}&lt;/p&gt;
&lt;p&gt;He sido preguntado en varias ocaciones sobre el manejo del formato netCDF, por esta razón, en este post hacemos uso de un subconjunto, el año 2017 del SPEI 12 meses, de estos mismos datos.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;paquetes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Paquetes&lt;/h1&gt;
&lt;p&gt;El manejo de datos en formato netCDF es posible a través de varios paquetes de forma directa o indirecta. Destaca el paquete &lt;code&gt;{ncdf4}&lt;/code&gt; específicamente diseñado, del que hacen uso también otros paquetes aunque no lo veamos. El manejo con &lt;code&gt;{ncdf4}&lt;/code&gt; es algo complejo, particularmente por la necesidad de gestionar la memoria RAM cuando tratamos grandes conjuntos de datos o también por la forma de manejar la clase &lt;em&gt;array&lt;/em&gt;. Otro paquete muy potente es &lt;code&gt;{terra}&lt;/code&gt;, que conocemos cuando trabajamos con datos raster y permite usar sus funciones también para el manejo del formato netCDF.&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;10%&#34; /&gt;
&lt;col width=&#34;89%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Paquete&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tidyverse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Conjunto de paquetes (visualización y manipulación de datos): ggplot2, dplyr, purrr,etc.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Simple Feature: importar, exportar y manipular datos vectoriales&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;lubridate&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fácil manipulación de fechas y tiempos&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;terra&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Importar, exportar y manipular raster (paquete sucesor de raster)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;mapSpain&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Límites administrativos de España&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# instalamos los paquetes si hace falta

if(!require(&amp;quot;tidyverse&amp;quot;)) install.packages(&amp;quot;tidyverse&amp;quot;)
if(!require(&amp;quot;sf&amp;quot;)) install.packages(&amp;quot;sf&amp;quot;)
if(!require(&amp;quot;lubridate&amp;quot;)) install.packages(&amp;quot;lubridate&amp;quot;)
if(!require(&amp;quot;terra&amp;quot;)) install.packages(&amp;quot;terra&amp;quot;)
if(!require(&amp;quot;mapSpain&amp;quot;)) install.packages(&amp;quot;mapSpain&amp;quot;)

# paquetes
library(tidyverse)
library(sf)
library(terra)
library(lubridate)
library(mapSpain)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para aquellos con menos experiencia con &lt;code&gt;tidyverse&lt;/code&gt;, recomiendo una breve introducción en este blog &lt;a href=&#34;https://dominicroye.github.io/es/2020/una-muy-breve-introducci%C3%B3n-a-tidyverse/&#34;&gt;post&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;datos&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Datos&lt;/h1&gt;
&lt;p&gt;Primero descargamos los datos &lt;a href=&#34;https://www.dropbox.com/s/ioo2ky7wb3zxkdx/spei12_2017.nc?dl=0&#34;&gt;aquí&lt;/a&gt;. Importamos los datos del índice SPEI-12 del año 2017 usando la función &lt;code&gt;rast()&lt;/code&gt;. En realidad en este paso sólo hemos creado una referencia al archivo sin importar todos los datos a la memoria. Vemos en los metadatos el número de capas (&lt;em&gt;layers&lt;/em&gt;) disponibles. El índice SPEI-12 está calculado semanalmente con 4 semanas por mes. Si nos fijamos en los metadatos, falta la definicón del sistema de coordenadas, por ello la definimos asignando el código EPSG:25830 (ETRS89/UTM 30N).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# importamos
spei &amp;lt;- rast(&amp;quot;spei12_2017.nc&amp;quot;)
# metadatos
spei&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class       : SpatRaster 
## dimensions  : 834, 1115, 48  (nrow, ncol, nlyr)
## resolution  : 1100, 1100  (x, y)
## extent      : -80950, 1145550, 3979450, 4896850  (xmin, xmax, ymin, ymax)
## coord. ref. :  
## source      : spei12_2017.nc 
## names       : spei1~017_1, spei1~017_2, spei1~017_3, spei1~017_4, spei1~017_5, spei1~017_6, ... 
## time        : 2017-01-01 to 2017-12-23&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# definimos el sistema de coordenadas
crs(spei) &amp;lt;- &amp;quot;EPSG:25830&amp;quot;

# mapeamos las primeras semanas
plot(spei)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/uso-de-datos-multidimensionales-espaciales/index.es_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;extraer-metadatos&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Extraer metadatos&lt;/h1&gt;
&lt;p&gt;Existen diferentes funciones para acceder a metadatos como las fechas, los nombres de las capas o de las variables. Recordemos que los archivos netCDF también pueden contener varias variables.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# fechas
t &amp;lt;- time(spei)
head(t)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2017-01-01 UTC&amp;quot; &amp;quot;2017-01-09 UTC&amp;quot; &amp;quot;2017-01-16 UTC&amp;quot; &amp;quot;2017-01-23 UTC&amp;quot;
## [5] &amp;quot;2017-02-01 UTC&amp;quot; &amp;quot;2017-02-09 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# nombres de capas
names(spei) %&amp;gt;% head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;spei12_2017_1&amp;quot; &amp;quot;spei12_2017_2&amp;quot; &amp;quot;spei12_2017_3&amp;quot; &amp;quot;spei12_2017_4&amp;quot;
## [5] &amp;quot;spei12_2017_5&amp;quot; &amp;quot;spei12_2017_6&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# nombres de variables
varnames(spei)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;spei12_2017&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;extracción-de-series-temporales&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Extracción de series temporales&lt;/h1&gt;
&lt;p&gt;Una posibiliad que permiten los datos netCDF es la extracción de series temporales, bien a partir de puntos o áreas. Creamos la series temporales del SPEI-12 para la ciudad de Zaragoza y el promedio de toda la comunidad autónoma de Aragón.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# coordenadas de Zaragoza
zar &amp;lt;- st_point(c(-0.883333, 41.65)) %&amp;gt;% 
          st_sfc(crs = 4326) %&amp;gt;% 
           st_as_sf() %&amp;gt;% 
            st_transform(25830)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El paquete &lt;code&gt;{terra}&lt;/code&gt; sólo acepta su propia clase vectorial &lt;em&gt;SpatVector&lt;/em&gt;, por eso es necesario convertir el punto de clase &lt;em&gt;sf&lt;/em&gt; con la función &lt;code&gt;vect()&lt;/code&gt;. Para extraer la serie temporal empleamos la función &lt;code&gt;extract()&lt;/code&gt;. Los datos extraídos los encontramos en forma de una tabla, cada fila es un elemento de los datos vectoriales y cada columna una capa. En nuestro caso sólo es una fila correspondiente a la ciudad de Zaragoza.&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Algunas funciones pueden tener conflictos con nombres de otros paquetes, para evitarlo podemos escribir el nombre del paquete delante de la función que queremos usar, separados por el símbolo de dos puntos escrito dos veces (&lt;code&gt;package_name::function_name&lt;/code&gt;).
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# extraer la serie temporal
spei_zar &amp;lt;- terra::extract(spei, vect(zar))

# dimensiones
dim(spei_zar)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  1 49&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# creamos un data.frame
spei_zar &amp;lt;- tibble(date = t, zar = unlist(spei_zar)[-1])
head(spei_zar)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 2
##   date                  zar
##   &amp;lt;dttm&amp;gt;              &amp;lt;dbl&amp;gt;
## 1 2017-01-01 00:00:00 0.280
## 2 2017-01-09 00:00:00 0.25 
## 3 2017-01-16 00:00:00 0.220
## 4 2017-01-23 00:00:00 0.210
## 5 2017-02-01 00:00:00 0.350
## 6 2017-02-09 00:00:00 0.220&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El promedio de la comunidad autónoma de Aragón lo obtenemos usando la geometría de polígono e indicando el tipo de función con la que queremos resumir el área. La función &lt;code&gt;esp_get_ccaa()&lt;/code&gt; del paquete &lt;code&gt;mapSpain()&lt;/code&gt; es muy útil a la hora de importar límites administrativos españoles de diferentes niveles. En la extracción es importante que pasemos el argumento &lt;code&gt;na.rm = TRUE&lt;/code&gt; de la función &lt;code&gt;mean()&lt;/code&gt; para excluir píxeles sin valor.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# límites de Aragón
aragon &amp;lt;- esp_get_ccaa(&amp;quot;Aragón&amp;quot;) %&amp;gt;% 
            st_transform(25830)

# extraemos los valores medios del SPEI-12
spei_arag &amp;lt;- terra::extract(spei, vect(aragon), fun = &amp;quot;mean&amp;quot;, na.rm = TRUE)

# añadimos los nuevos valores a nuestro data.frame
spei_zar &amp;lt;- mutate(spei_zar, arag = unlist(spei_arag)[-1])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En el seguiente paso transformamos la tabla al formato largo con &lt;code&gt;pivot_longer()&lt;/code&gt;, fusionando el valor del índice SPEI de Zaragoza y Aragón. Además añadiremos una columna con la interpretación del índice y cambiaremos las etiquetas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spei_zar &amp;lt;-  pivot_longer(spei_zar, 2:3, names_to = &amp;quot;reg&amp;quot;, values_to = &amp;quot;spei&amp;quot;) %&amp;gt;%
             mutate(sign = case_when(spei &amp;lt; -0.5 ~ &amp;quot;sequía&amp;quot;, 
                                    spei &amp;gt; 0.5 ~ &amp;quot;húmedo&amp;quot;,
                                    TRUE ~ &amp;quot;normal&amp;quot;),
                    date = as_date(date),
                    reg = factor(reg, c(&amp;quot;zar&amp;quot;, &amp;quot;arag&amp;quot;), c(&amp;quot;Zaragoza&amp;quot;, &amp;quot;Aragón&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora falta por construir el gráfico en el que comparamos el SPEI-12 de Zaragoza con el promedio de Aragón. La función &lt;code&gt;geom_rect()&lt;/code&gt; nos ayuda a dibujar diferentes rectángulos de fondo para marcar la sequía, episodio normal o húmedo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# gráfico de serie temporal
ggplot(spei_zar) +
      geom_rect(aes(xmin = min(date), xmax = max(date), 
                    ymin = -0.5, ymax = 0.5), 
                fill = &amp;quot;#41ab5d&amp;quot;) +
      geom_rect(aes(xmin = min(date), xmax = max(date), 
                    ymin = -1, ymax = -0.5), 
                fill = &amp;quot;#ffffcc&amp;quot;) +
      geom_rect(aes(xmin = min(date), xmax = max(date), 
                    ymin = -1.5, ymax = -1), 
                fill = &amp;quot;#F3641D&amp;quot;) +
      geom_hline(yintercept = 0, size = 1, colour = &amp;quot;white&amp;quot;) +
      geom_line(aes(date, spei, linetype = reg), size = 1, alpha = .7) +
  scale_x_date(date_breaks = &amp;quot;month&amp;quot;, date_labels = &amp;quot;%b&amp;quot;) +
  labs(linetype = &amp;quot;&amp;quot;, y = &amp;quot;SPEI-12&amp;quot;, x = &amp;quot;&amp;quot;) +
  coord_cartesian(expand = FALSE) +
  theme_minimal() +
  theme(legend.position = c(.25, .9),
        panel.grid.minor = element_blank(),
        panel.ontop = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/uso-de-datos-multidimensionales-espaciales/index.es_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;mapa-de-sequía&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Mapa de sequía&lt;/h1&gt;
&lt;div id=&#34;españa&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;España&lt;/h2&gt;
&lt;p&gt;Con el objetivo de crear un mapa de la severidad de sequía en 2017, primero debemos hacer algunas modificaciones. Con la función &lt;code&gt;subset()&lt;/code&gt; obtenemos una capa o varias como subconjunto, aquí seleccionamos la última para poder ver el estado de sequía de todo el año.&lt;/p&gt;
&lt;p&gt;En el siguiente paso reemplazamos todos los valores mayores de -0,5 con &lt;code&gt;NA&lt;/code&gt;. Se considera sequía cuando el índice SPEI está debajo de -0,5 y, en cambio, si está encima de 0,5 hablaríamos de un período húmedo.&lt;/p&gt;
&lt;p&gt;La clase del raster no es directamente compatible con &lt;code&gt;ggplot&lt;/code&gt;, por eso, lo convertimos en una tabla xyz con longitud, latitud y la variable. Cuando hacemos la misma conversión de varias capas cada columna representaría una capa. Finalmente renombramos nuestra columna del índice y añadimos una nueva columna con distintos grados de severidad de sequía.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# extraemos capa(s) con su índice 
spei_anual &amp;lt;- subset(spei, 48) 

# sustituimos valores de no-sequía con NA
spei_anual[spei_anual &amp;gt; -0.5] &amp;lt;- NA

# convertimos nuestro raster en una tabla de xyz
spei_df &amp;lt;- as.data.frame(spei_anual, xy = TRUE)
head(spei_df)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##            x       y spei12_2017_48
## 38096 123100 4858900          -1.48
## 39195 105500 4857800          -1.59
## 39197 107700 4857800          -1.40
## 39211 123100 4857800          -1.47
## 39212 124200 4857800          -1.50
## 40310 105500 4856700          -1.63&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# cambiamos el nombre de la variable
names(spei_df)[3] &amp;lt;- &amp;quot;spei&amp;quot;

# categorizamos el índice y fijamos el orden del factor
spei_df &amp;lt;- mutate(spei_df, spei_cat = case_when(spei &amp;gt; -0.9 ~ &amp;quot;leve&amp;quot;,
                                                spei &amp;gt; -1.5 &amp;amp; spei &amp;lt; -0.9 ~ &amp;quot;moderada&amp;quot;,
                                                spei &amp;gt; -2 &amp;amp; spei &amp;lt;= -1.5 ~ &amp;quot;severa&amp;quot;,
                                                TRUE ~ &amp;quot;extrema&amp;quot;) %&amp;gt;% 
                                      fct_relevel(c(&amp;quot;leve&amp;quot;, &amp;quot;moderada&amp;quot;, &amp;quot;severa&amp;quot;, &amp;quot;extrema&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Un mapa de raster lo creamos con la geometría &lt;code&gt;geom_tile()&lt;/code&gt; indicando longitud, latitud y el color de los píxeles con nuestra variable categorizada.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ccaa &amp;lt;- esp_get_ccaa() %&amp;gt;% 
            filter(!ine.ccaa.name %in% c(&amp;quot;Canarias&amp;quot;, &amp;quot;Ceuta&amp;quot;, &amp;quot;Melilla&amp;quot;)) %&amp;gt;% 
              st_transform(25830)

# mapa
ggplot(spei_df) +
   geom_tile(aes(x , y, fill = spei_cat)) +
  geom_sf(data = ccaa, fill = NA, size = .1, colour = &amp;quot;white&amp;quot;, alpha = .4) +
  scale_fill_manual(values = c(&amp;quot;#ffffcc&amp;quot;, &amp;quot;#F3641D&amp;quot;, &amp;quot;#DE2929&amp;quot;, &amp;quot;#8B1A1A&amp;quot;),
                    na.value = NA) +
  guides(fill = guide_legend(keywidth = 2, keyheight = .3, label.position = &amp;quot;bottom&amp;quot;,
                             title.position = &amp;quot;top&amp;quot;)) +
  coord_sf() +
  labs(fill = &amp;quot;SEQUIA&amp;quot;) +
  theme_void() +
  theme(legend.position = &amp;quot;top&amp;quot;,
        legend.justification = 0.2,
        plot.background = element_rect(fill = &amp;quot;black&amp;quot;, colour = NA),
        legend.title = element_text(colour = &amp;quot;white&amp;quot;, size = 20, hjust = .5),
        legend.text = element_text(colour = &amp;quot;white&amp;quot;),
        plot.margin = margin(t = 10))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/uso-de-datos-multidimensionales-espaciales/index.es_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;758.4&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;aragón&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Aragón&lt;/h2&gt;
&lt;p&gt;En este último ejemplo, seleccionamos la situación de sequía a 12 meses vista, a principios y final de año. La función principal es &lt;code&gt;crop()&lt;/code&gt; que recorta a la extensión de un objeto espacial, en nuestro caso es Aragón, después aplicamos la función &lt;code&gt;mask()&lt;/code&gt; que enmascara todos aquellos píxeles dentro de los límites dejando en &lt;code&gt;NA&lt;/code&gt; los demás.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# subconjunto primera y ultima semana 2017
spei_sub &amp;lt;- subset(spei, c(1, 48)) 

# recortamos y enmascaramos Aragón
spei_arag &amp;lt;- crop(spei_sub, aragon) %&amp;gt;% 
                    mask(vect(aragon)) 

# convertimos los datos a xyz
spei_df_arag &amp;lt;- as.data.frame(spei_arag, xy = TRUE)

# renombramos las dos capas
names(spei_df_arag)[3:4] &amp;lt;- c(&amp;quot;Enero&amp;quot;, &amp;quot;Diciembre&amp;quot;)

# pasamos al formato de tabla larga fusionando ambos meses
spei_df_arag &amp;lt;- pivot_longer(spei_df_arag, 3:4, 
                             names_to = &amp;quot;mes&amp;quot;, 
                             values_to = &amp;quot;spei&amp;quot;) %&amp;gt;% 
                mutate(mes = fct_relevel(mes, c(&amp;quot;Enero&amp;quot;, &amp;quot;Diciembre&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Los dos mapas los hacemos de la misma forma como el de España. La diferencia principal es que usamos el índice SPEI directamente como variable continua. Además, para crear dos mapas con una fila añadimos la función &lt;code&gt;facet_grid()&lt;/code&gt;. Por último, el índice muestra valores negativos y positivos, por tanto, es necesario una gama divergente de colores. Con el objetivo de centrar el punto medio en 0 debemos reescalar con ayuda de la función &lt;code&gt;rescale()&lt;/code&gt; del paquete &lt;code&gt;scales&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# mapa de Aragón
ggplot(spei_df_arag) +
   geom_tile(aes(x , y, fill = spei)) +
  geom_sf(data = aragon, fill = NA, size = .1, colour = &amp;quot;white&amp;quot;, alpha = .4) +
  scale_fill_distiller(palette = &amp;quot;RdYlGn&amp;quot;, direction = 1, 
                       values = scales::rescale(c(-2.1, 0, 0.9)),
                       breaks = seq(-2, 1, .5)) +
  guides(fill = guide_colorbar(barwidth = 8, barheight = .3, label.position = &amp;quot;bottom&amp;quot;)) +
  facet_grid(. ~ mes) +
  coord_sf() +
  labs(fill = &amp;quot;SPEI-12&amp;quot;, title = &amp;quot;Aragón&amp;quot;) +
  theme_void() +
  theme(legend.position = &amp;quot;top&amp;quot;,
        legend.justification = 0.5,
        legend.title = element_text(colour = &amp;quot;white&amp;quot;, vjust = 1.1),
        strip.text = element_text(colour = &amp;quot;white&amp;quot;),
        plot.background = element_rect(fill = &amp;quot;black&amp;quot;, colour = NA),
        plot.title = element_text(colour = &amp;quot;white&amp;quot;, size = 20, hjust = .5, vjust = 2.5,
                                  margin = margin(b = 10, t = 10)),
        legend.text = element_text(colour = &amp;quot;white&amp;quot;),
        plot.margin = margin(10, 10, 10, 10))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/uso-de-datos-multidimensionales-espaciales/index.es_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;más-posibilidades&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Más posibilidades&lt;/h1&gt;
&lt;p&gt;Es posible agrupar las diferentes capas aplicando una función. Usando los meses de cada semana del SPEI-12 podemos calcular el promedio mensual en 2017. Para ello hacemos uso de la función &lt;code&gt;tapp()&lt;/code&gt; que a su vez aplica sobre índices otra función. Es imporante que el grupo o bien sea un factor o el índice de cada capa. Las funciónes &lt;code&gt;tapp()&lt;/code&gt; y &lt;code&gt;app()&lt;/code&gt; tienen un argumento para procesar en paralelo usando más de un núcleo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# meses como factor
mo &amp;lt;- month(t, label = TRUE)
mo&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] ene ene ene ene feb feb feb feb mar mar mar mar abr abr abr abr may may may
## [20] may jun jun jun jun jul jul jul jul ago ago ago ago sep sep sep sep oct oct
## [39] oct oct nov nov nov nov dic dic dic dic
## 12 Levels: ene &amp;lt; feb &amp;lt; mar &amp;lt; abr &amp;lt; may &amp;lt; jun &amp;lt; jul &amp;lt; ago &amp;lt; sep &amp;lt; ... &amp;lt; dic&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# promedio por mes
spei_mo &amp;lt;- tapp(spei, mo, mean)
spei_mo&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class       : SpatRaster 
## dimensions  : 834, 1115, 12  (nrow, ncol, nlyr)
## resolution  : 1100, 1100  (x, y)
## extent      : -80950, 1145550, 3979450, 4896850  (xmin, xmax, ymin, ymax)
## coord. ref. : ETRS89 / UTM zone 30N (EPSG:25830) 
## source      : memory 
## names       :     ene,     feb,     mar,     abr,     may,     jun, ... 
## min values  : -1.2800, -1.4675, -2.2400, -2.6500, -2.5775, -2.4675, ... 
## max values  :  1.3875,  1.9175,  1.7475,  1.8375,  1.7500,  1.7000, ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# mapas
plot(spei_mo)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/uso-de-datos-multidimensionales-espaciales/index.es_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;La función &lt;code&gt;mean()&lt;/code&gt; directamente usado sobre un objeto de clase &lt;code&gt;SpatRaster&lt;/code&gt; multidimensional devuelve el promedio por celda. El mismo resultado lo podemos obtener con la función &lt;code&gt;app()&lt;/code&gt; que aplica cualquier función. El número de capas resultante depende de la función, por ejemplo, al aplicar &lt;code&gt;range()&lt;/code&gt; el resultado son dos capas, una del valor mínimo y otra del máximo. Por último, la función &lt;code&gt;global()&lt;/code&gt; resume con la función indicada cada capa en forma de una tabla.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# promedio sobre capas
spei_mean &amp;lt;- mean(spei)
spei_mean&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class       : SpatRaster 
## dimensions  : 834, 1115, 1  (nrow, ncol, nlyr)
## resolution  : 1100, 1100  (x, y)
## extent      : -80950, 1145550, 3979450, 4896850  (xmin, xmax, ymin, ymax)
## coord. ref. : ETRS89 / UTM zone 30N (EPSG:25830) 
## source      : memory 
## name        :      mean 
## min value   : -2.127083 
## max value   :  1.568542&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# mapa
plot(spei_mean)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/uso-de-datos-multidimensionales-espaciales/index.es_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# alternativa
spei_min &amp;lt;- app(spei, min)
spei_min&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class       : SpatRaster 
## dimensions  : 834, 1115, 1  (nrow, ncol, nlyr)
## resolution  : 1100, 1100  (x, y)
## extent      : -80950, 1145550, 3979450, 4896850  (xmin, xmax, ymin, ymax)
## coord. ref. : ETRS89 / UTM zone 30N (EPSG:25830) 
## source      : memory 
## name        :   min 
## min value   : -3.33 
## max value   :  0.29&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spei_range &amp;lt;- app(spei, range)
names(spei_range) &amp;lt;- c(&amp;quot;min&amp;quot;, &amp;quot;max&amp;quot;)
spei_range&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class       : SpatRaster 
## dimensions  : 834, 1115, 2  (nrow, ncol, nlyr)
## resolution  : 1100, 1100  (x, y)
## extent      : -80950, 1145550, 3979450, 4896850  (xmin, xmax, ymin, ymax)
## coord. ref. : ETRS89 / UTM zone 30N (EPSG:25830) 
## source      : memory 
## names       :   min,   max 
## min values  : -3.33, -1.06 
## max values  :  0.29,  2.02&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# mapa
plot(spei_range)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2022/uso-de-datos-multidimensionales-espaciales/index.es_files/figure-html/unnamed-chunk-15-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# resumen estadístico por capa
global(spei, &amp;quot;mean&amp;quot;, na.rm = TRUE) %&amp;gt;% head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                      mean
## spei12_2017_1 -0.03389126
## spei12_2017_2 -0.17395742
## spei12_2017_3 -0.13228593
## spei12_2017_4 -0.07536089
## spei12_2017_5  0.06718260
## spei12_2017_6 -0.03461822&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://www.buymeacoffee.com/drxeo&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://cdn.buymeacoffee.com/buttons/default-orange.png&#34; alt=&#34;Buy Me A Coffee&#34; height=&#34;41&#34; width=&#34;174&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Calcular la distancia al mar en R</title>
      <link>https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/</link>
      <pubDate>Tue, 08 Jan 2019 00:00:00 +0000</pubDate>
      <guid>https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/</guid>
      <description>
&lt;script src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;En geografía, la distancia al mar es una variable fundamental, especialmente relevante a la hora de modelizar. Por ejemplo, en interpolaciones de la temperatura del aire habitualmente se hace uso de la distancia al mar como variable predictora, ya que existe una relación casual entre ambas que explica la variación espacial. ¿Cómo podemos estimar la distancia (más corta) a la costa en R?&lt;/p&gt;
&lt;div id=&#34;paquetes&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Paquetes&lt;/h2&gt;
&lt;p&gt;En este post usaremos los siguientes paquetes:&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;14%&#34; /&gt;
&lt;col width=&#34;85%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Paquete&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Descripción&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;tidyverse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Conjunto de librerías (visualización y manipulación de datos): ggplot2, dplyr, etc.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Simple Feature: importar, exportar y manipular datos vectoriales&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;raster&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Importar, exportar y manipular raster&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;rnaturalearth&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Conjunto de mapas vectoriales ‘natural earth’&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;RColorBrewer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Paletas de colores&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#instalamos los paquetes si hace falta
if(!require(&amp;quot;tidyverse&amp;quot;)) install.packages(&amp;quot;tidyverse&amp;quot;)
if(!require(&amp;quot;sf&amp;quot;)) install.packages(&amp;quot;sf&amp;quot;)
if(!require(&amp;quot;raster&amp;quot;)) install.packages(&amp;quot;raster&amp;quot;)
if(!require(&amp;quot;rnaturalearth&amp;quot;)) install.packages(&amp;quot;rnaturalearth&amp;quot;)

#paquetes
library(rnaturalearth)
library(sf)
library(raster)
library(tidyverse)
library(RColorBrewer)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;la-costa-de-islandia-como-ejemplo&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;La costa de Islandia como ejemplo&lt;/h2&gt;
&lt;p&gt;Nuestro ejemplo en este post será Islandia, como es un territorio insular facilitará el ensayo y de este modo es posible mostrar el proceso de forma sencilla. La librería &lt;em&gt;rnaturalearth&lt;/em&gt; permite importar los límites de países (con diferentes niveles administrativos) de todo el mundo. Los datos vienen de la plataforma &lt;a href=&#34;http://www.naturalearthdata.com/&#34;&gt;naturalearthdata.com&lt;/a&gt;. Recomiendo explorar la librería, más info &lt;a href=&#34;https://github.com/ropensci/rnaturalearth&#34;&gt;aquí&lt;/a&gt;. La función &lt;code&gt;ne_countries( )&lt;/code&gt; importa los límites de países. En este caso indicamos con el argumento &lt;em&gt;scale&lt;/em&gt; la resolución (10,50 o 110m), con &lt;em&gt;country&lt;/em&gt; indicamos el país concreto de interés y con &lt;em&gt;returnclass&lt;/em&gt; determinamos que clase queremos (&lt;em&gt;sf&lt;/em&gt; o &lt;em&gt;sp&lt;/em&gt;), en nuestro caso &lt;em&gt;sf&lt;/em&gt; (simple feature).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;world &amp;lt;- ne_countries(scale = 50) #mapamundi con 50m de resolución

plot(world) #tiene clase sp por defecto&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#importamos los límites de Islandia 
iceland &amp;lt;- ne_countries(scale = 10,country = &amp;quot;Iceland&amp;quot;, returnclass = &amp;quot;sf&amp;quot;)

#info del objeto vectorial
iceland&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 1 feature and 94 fields
## Geometry type: MULTIPOLYGON
## Dimension:     XY
## Bounding box:  xmin: -24.53991 ymin: 63.39671 xmax: -13.50292 ymax: 66.56415
## CRS:           +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0
##          featurecla scalerank labelrank sovereignt sov_a3 adm0_dif level
## 188 Admin-0 country         0         3    Iceland    ISL        0     2
##                  type   admin adm0_a3 geou_dif geounit gu_a3 su_dif subunit
## 188 Sovereign country Iceland     ISL        0 Iceland   ISL      0 Iceland
##     su_a3 brk_diff    name name_long brk_a3 brk_name brk_group  abbrev postal
## 188   ISL        0 Iceland   Iceland    ISL  Iceland      &amp;lt;NA&amp;gt; Iceland     IS
##               formal_en formal_fr name_ciawf note_adm0 note_brk name_sort
## 188 Republic of Iceland      &amp;lt;NA&amp;gt;    Iceland      &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;   Iceland
##     name_alt mapcolor7 mapcolor8 mapcolor9 mapcolor13 pop_est pop_rank
## 188     &amp;lt;NA&amp;gt;         1         4         4          9  339747       10
##     gdp_md_est pop_year lastcensus gdp_year                    economy
## 188      16150     2017         NA     2016 2. Developed region: nonG7
##               income_grp wikipedia fips_10_ iso_a2 iso_a3 iso_a3_eh iso_n3
## 188 1. High income: OECD        NA       IC     IS    ISL       ISL    352
##     un_a3 wb_a2 wb_a3   woe_id woe_id_eh                   woe_note adm0_a3_is
## 188   352    IS   ISL 23424845  23424845 Exact WOE match as country        ISL
##     adm0_a3_us adm0_a3_un adm0_a3_wb continent region_un       subregion
## 188        ISL         NA         NA    Europe    Europe Northern Europe
##                 region_wb name_len long_len abbrev_len tiny homepart min_zoom
## 188 Europe &amp;amp; Central Asia        7        7          7   NA        1        0
##     min_label max_label      ne_id wikidataid name_ar name_bn name_de name_en
## 188         2         7 1159320917       Q189    &amp;lt;NA&amp;gt;    &amp;lt;NA&amp;gt;  Island Iceland
##      name_es name_fr name_el name_hi name_hu  name_id name_it name_ja name_ko
## 188 Islandia Islande    &amp;lt;NA&amp;gt;    &amp;lt;NA&amp;gt;  Izland Islandia Islanda    &amp;lt;NA&amp;gt;    &amp;lt;NA&amp;gt;
##     name_nl  name_pl  name_pt name_ru name_sv name_tr name_vi name_zh
## 188 IJsland Islandia Islândia    &amp;lt;NA&amp;gt;  Island Izlanda Iceland    &amp;lt;NA&amp;gt;
##                           geometry
## 188 MULTIPOLYGON (((-14.56363 6...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#aquí Islandia
plot(iceland)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/figure-html/unnamed-chunk-3-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Por defecto, la función &lt;code&gt;plot( )&lt;/code&gt; con la clase &lt;em&gt;sf&lt;/em&gt; nos crea tantas facetas del mapa como variables tiene. Para limitarlo podemos usar o bien con el nombre de una variable &lt;code&gt;plot(iceland[&#34;admin&#34;])&lt;/code&gt; o el argumento &lt;em&gt;max.plot&lt;/em&gt; &lt;code&gt;plot(iceland,max.plot=1)&lt;/code&gt;. Con el argumento &lt;em&gt;max.plot=1&lt;/em&gt; la función usa la primera variable disponible del mapa.&lt;/p&gt;
&lt;p&gt;Además, vemos en la información del objeto &lt;em&gt;sf&lt;/em&gt; que la proyección es WGS84 con grados decimales (código EPSG:4326). Para el cálculo de distancias es más conveniente usar metros en lugar de grados. Debido a ello, lo primero que hacemos es transformar el mapa de Islandia a UTM Zona 27 (código EPSG:3055). Más información sobre EPSG y proyecciones &lt;a href=&#34;http://spatialreference.org/ref/epsg/wgs-84/&#34;&gt;aquí&lt;/a&gt;. Con ese objetivo, usamos la función &lt;code&gt;st_transform( )&lt;/code&gt;. Simplemente indicamos el mapa y el código EPSG.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#transformamos a UTM
iceland &amp;lt;- st_transform(iceland, 3055)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;crear-una-red-de-puntos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Crear una red de puntos&lt;/h2&gt;
&lt;p&gt;Todavía necesitamos los puntos donde queremos conocer la distancia. En nuestro caso será una red regular de puntos en Islandia con una resolución de 5km. Esa tarea la hacemos con la función &lt;code&gt;st_make_grid( )&lt;/code&gt;, indicando con el argumento &lt;em&gt;cellsize&lt;/em&gt; la resolución en la unidad del sistema de coordenadas (metros en nuestro caso) y qué geometría nos gustaría crear &lt;em&gt;what&lt;/em&gt; (poligonos, centros o esquinas).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#crear red de puntos
grid &amp;lt;- st_make_grid(iceland,cellsize = 5000, what = &amp;quot;centers&amp;quot;)

#nuestra red sobre la extensión de Islandia
plot(grid)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#exraemos sólamente los puntos en los límites de Islandia
grid &amp;lt;- st_intersection(grid, iceland)   

#nuestra red ahora
plot(grid)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;calcular-la-distancia&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Calcular la distancia&lt;/h2&gt;
&lt;p&gt;Para estimar la distancia usamos la función &lt;code&gt;st_distance( )&lt;/code&gt; que nos devuelve un vector de distancias para todos nuestros puntos de la red. Pero antes es necesario transformar el mapa de Islandia de una forma de polígono (MULTIPOLYGON) a línea (MULTILINESTRING). Más detalles con &lt;code&gt;?st_cast&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#convertimos Islandia de geometría poligono a línea
iceland &amp;lt;- st_cast(iceland, &amp;quot;MULTILINESTRING&amp;quot;)

#cálculo de la distancia entre la costa y nuestros puntos
dist &amp;lt;- st_distance(iceland, grid)

#distancia con unidad en metros
head(dist[1,])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Units: [m]
## [1]  790.7906 1151.4360 1270.7603 3128.9057 2428.5677 4197.7472&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;visualizar-la-distancia-calculada&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Visualizar la distancia calculada&lt;/h2&gt;
&lt;p&gt;Una vez obtenida la distancia para nuestros puntos, podemos combinarlos con las coordenadas y plotearlos en &lt;em&gt;ggplot2&lt;/em&gt;. Para ello, creamos un &lt;em&gt;data.frame&lt;/em&gt;. El objeto &lt;em&gt;dist&lt;/em&gt; es una matriz de una columna, por eso, tenemos que convertirla a vector con la función &lt;code&gt;as.vector( )&lt;/code&gt;. Además, dividimos por 1000 para convertir la distancia en metros a km. La función &lt;code&gt;st_coordinates( )&lt;/code&gt; extrae las coordenadas de nuestros puntos. Para la visualización usamos un vector de colores con la gama RdGy (más &lt;a href=&#34;http://colorbrewer2.org&#34;&gt;aquí&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#creamos un data.frame con la distancia y las coorendas de los puntos
df &amp;lt;- data.frame(dist = as.vector(dist)/1000,
                    st_coordinates(grid))

#estructura
str(df)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    4104 obs. of  3 variables:
##  $ dist: num  0.791 1.151 1.271 3.129 2.429 ...
##  $ X   : num  608796 613796 583796 588796 593796 ...
##  $ Y   : num  7033371 7033371 7038371 7038371 7038371 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#colores 
col_dist &amp;lt;- brewer.pal(11, &amp;quot;RdGy&amp;quot;)


ggplot(df, aes(X, Y,fill = dist))+ #variables
         geom_tile()+ #geometría
           scale_fill_gradientn(colours = rev(col_dist))+ #colores para la distancia
             labs(fill = &amp;quot;Distance (km)&amp;quot;)+ #nombre de la leyenda
             theme_void()+ #estilo del mapa
              theme(legend.position = &amp;quot;bottom&amp;quot;) #posición de la leyenda&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;exportar-la-distancia-como-raster&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Exportar la distancia como raster&lt;/h2&gt;
&lt;p&gt;Para poder exportar la distancia con respecto al mar de Islandia, debemos usar la función &lt;code&gt;rasterize( )&lt;/code&gt; de la librería &lt;em&gt;raster&lt;/em&gt;.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Primero, es necesario crear un raster vacío. En este raster debemos indicar la resolución, en nuestro caso es de 5000m, la proyección y la extensión del raster.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: lower-alpha&#34;&gt;
&lt;li&gt;&lt;p&gt;La proyección la podemos extraer de la información del mapa de Islandia.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;La extensión la conseguimos extraer de nuestros puntos &lt;em&gt;grid&lt;/em&gt; con la función &lt;code&gt;extent( )&lt;/code&gt;. No obstante, esta última función necesita la clase &lt;em&gt;sp&lt;/em&gt;, por eso pasamos el objeto &lt;em&gt;grid&lt;/em&gt; en formato &lt;em&gt;sf&lt;/em&gt;, únicamente para ello, a la clase &lt;em&gt;sp&lt;/em&gt; usando la función &lt;code&gt;as( )&lt;/code&gt; y el argumento “Spatial”.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Además de lo anterior, el &lt;em&gt;data.frame&lt;/em&gt; &lt;strong&gt;df&lt;/strong&gt; que creamos antes debemos convertir en clase &lt;em&gt;sf&lt;/em&gt;. Por eso, aplicamos la función &lt;code&gt;st_as_sf( )&lt;/code&gt; con el argumento &lt;em&gt;coords&lt;/em&gt; indicando los nombres de las coordenadas. Adicionalmente, también definimos el sistema de coordenadas que conocemos.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#obtenemos la extensión
ext &amp;lt;- extent(as(grid, &amp;quot;Spatial&amp;quot;))

#objeto extent
ext&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class      : Extent 
## xmin       : 338795.6 
## xmax       : 848795.6 
## ymin       : 7033371 
## ymax       : 7383371&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#raster destino
r &amp;lt;- raster(resolution = 5000, ext = ext, crs = &amp;quot;+proj=utm +zone=27 +ellps=intl +towgs84=-73,47,-83,0,0,0,0 +units=m +no_defs&amp;quot;)

#convertimos los puntos a un spatial object clase sf
dist_sf &amp;lt;- st_as_sf(df, coords = c(&amp;quot;X&amp;quot;,&amp;quot;Y&amp;quot;)) %&amp;gt;%
                      st_set_crs(3055)

#creamos el raster de la distancia
dist_raster &amp;lt;- rasterize(dist_sf, r, &amp;quot;dist&amp;quot;, fun = mean)

#raster
dist_raster&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class      : RasterLayer 
## dimensions : 70, 102, 7140  (nrow, ncol, ncell)
## resolution : 5000, 5000  (x, y)
## extent     : 338795.6, 848795.6, 7033371, 7383371  (xmin, xmax, ymin, ymax)
## crs        : +proj=utm +zone=27 +ellps=intl +units=m +no_defs 
## source     : memory
## names      : layer 
## values     : 0.006124901, 115.1712  (min, max)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#plotear el raster
plot(dist_raster)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#exportamos el raster
writeRaster(dist_raster, file = &amp;quot;dist_islandia.tif&amp;quot;, format = &amp;quot;GTiff&amp;quot;, overwrite = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La función &lt;code&gt;rasterize( )&lt;/code&gt; está pensada para crear rasters a partir de un grid irregular. En caso que tengamos un grid regular, como este mismo, podemos usar una alternativa más fácil. La función &lt;code&gt;rasterFromXYZ( )&lt;/code&gt; convierte un &lt;em&gt;data.frame&lt;/em&gt; con longitud, latitud y la variable &lt;em&gt;Z&lt;/em&gt; en un raster. Es importante que el orden debe ser longitud, latitud, variables.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;r &amp;lt;- rasterFromXYZ(df[, c(2:3, 1)], crs = &amp;quot;+proj=utm +zone=27 +ellps=intl +towgs84=-73,47,-83,0,0,0,0 +units=m +no_defs&amp;quot;)

plot(r)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dominicroye.github.io/es/2019/calcular-la-distancia-al-mar-en-r/index.es_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Con el cálculo de la distancia podemos llegar crear &lt;em&gt;arte&lt;/em&gt;, como se ve en la cabezera de este post, que incluye un mapamundi únicamente con la distancia al mar de todos los continentes. Una perspectiva diferente a nuestro mundo (&lt;a href=&#34;https://www.geografiainfinita.com/2017/06/una-radiografia-del-mundo-a-traves-de-la-distancia-al-mar/&#34;&gt;aquí más&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.buymeacoffee.com/drxeo&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://cdn.buymeacoffee.com/buttons/default-orange.png&#34; alt=&#34;Buy Me A Coffee&#34; height=&#34;41&#34; width=&#34;174&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
